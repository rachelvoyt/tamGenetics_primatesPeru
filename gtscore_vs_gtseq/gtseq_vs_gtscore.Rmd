---
title: "tamGenetics_gtseq_vs_gtscore"
author: "Rachel Voyt"
date: "`r Sys.Date()`"
output: 
  rmdformats::downcute:
    downcute_theme: "chaos"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1 Overview

## 1.1 General info

The current document provides a comparison of GTscore vs. GTseq data analysis pipelines, with the goal of determining whether one or the other (or a combination of both) is best to use for the analysis of GT-seq data.

## 1.2 Background on GTseq vs. GTscore pipelines

There are two main pipelines for the analysis of data acquired via genotyping-in-thousands by sequencing (GT-seq). The original pipeline is the "GTseq pipeline" ([GitHub link](https://github.com/GTseq/GTseq-Pipeline)) created by Nate Campbell, who developed the original protocol for GT-seq. The second pipeline is the "GTscore pipeline" ([Github link](https://github.com/gjmckinney/GTscore)) created by Garrett McKinney, Carita Pascal, and Lisa Seeb.

The GTscore pipeline follows the same general format as GTseq, but includes the following additions:

-   Determines genotypes for both multi-SNP haplotypes and single-SNP genotypes
-   Retains phase for multi-SNP haplotypes
-   Handles genotypes for loci with varying ploidy levels
-   Provides detailed summaries and plots and optional diagnostics

Beyond these additions, there are a few other differences to keep in mind:

-   Overall, documentation for the GTscore pipeline is much more thorough; as a bioinformatics novice, I found it much easier to follow
-   Both pipelines rely on perl scripts, but the GTscore pipeline is based in R
-   Both pipelines provide scripts to help with locus/sample diagnostics and primer optimization; these scripts are built into the GTscore pipeline, but analysis via the GTseq pipeline requires additional steps
-   GTscore does not include a coverage cutoff when genotyping samples, but GTseq excludes loci with less than 10x coverage

## 1.3 Summary of findings

# 2 Packages

```{r}
library(data.table)
library(ggpubr)
library(ggthemes)
library(gsubfn)
library(magrittr)
library(tidyverse)
```

# 3 Data

To compare the GTseq and GTscore pipelines, I'm using sequencing data from tamRun3, the third MiSeq sequencing run for the saddleback (LWED) and emperor (SIMP) tamarin population at the Estación Biológica Río Los Amigos in Perú.

This run has a total of \*\*438 samples\*\*, including 235 hair samples (138 LWED, 97 SIMP), 194 blood samples (112 LWED, 82 SIMP), and 9 negative controls.

## 3.1 Metadata & sample lists

**Metadata**

```{r}
md_tamRun3 <- read.csv("./03_tamRun3/03_run3GTscore/tamRun3_metadata_12Jan2023.csv") %>%
  mutate(sampleID = gsub("_","\\.", sampleID))
```

**Sample lists**

```{r}
samples_noNeg <- md_tamRun3 %>%
  filter(species %in% c("LWED", "SIMP")) %>%
  select(sampleID)

samplesLWED <- md_tamRun3 %>%
  filter(species == "LWED") %>%
  select(sampleID)

samplesSIMP <- md_tamRun3 %>%
  filter(species == "SIMP") %>%
  select(sampleID)
```

## 3.2 GTseq data

### Genotypes

```{r}
genos_gtseq <- read.csv("./gtscore_vs_gtseq/compiledGenos_gtseq_tamRun3.csv", header = T) %>%
  mutate(Sample = sub("\\_.*", "", Sample))
```

### Locus summaries

From what I could tell, the GTseq pipeline doesn't have a script that provides metrics per locus. Instead, we need to create this based on the results from seqTest and genos files. We can use the seqTest files to give us total read counts per locus and the genos files to give read counts for each allele per locus.

#### Locus read counts

GTseq_seqTest.pl outputs files for each sample that contain three columns, which represent counts of the following:

-   primer reads
-   probe reads
-   reads when both primer and probe occur in the sequence

We can sum these sample-specific read counts to get loci-specific read counts by combining all of the different seqTest sample files. I've also included species-specific subsets, where read counts per locus include only those from LWED or SIMP samples.

```{r}
# use full.names = T to list full sample path (avoid changing wd)
seqTestFiles_gtseq <- list.files(path = "/home/rachelvoyt/Documents/UT-Grad/Development/repos/tamGenetics_primatesPeru/gtscore_vs_gtseq/seqTest", pattern = "*.csv", full.names = T)

# Read in individual sample seqTest files and combine
seqTest_compiled <- lapply(seqTestFiles_gtseq, fread, select = c("V1", "V2", "V3", "V4")) %>%
  set_names(seqTestFiles_gtseq) %>%
  rbindlist(idcol = "sample") %>%
  as.data.frame() %>%
  dplyr::mutate(sample = sub(".*seqTest/", "", sample)) %>%
  dplyr::mutate(sample = sub("\\_.*", "", sample)) %>%
  dplyr::mutate(sample = gsub("-","\\.", sample)) %>%
  dplyr::rename("locus" = "V1",
                "primerReads" = "V2",
                "probeReads" = "V3", 
                "primerProbeReads" = "V4") %>%
  dplyr::mutate(sample = sub("\\_.*", "", sample)) %>%
  dplyr::mutate(sample = sub("-", "\\.", sample))

# Remove negative controls
lociReadCounts_lwedSIMP <- seqTest_compiled %>%
  filter(sample %in% samples_noNeg$sample) %>%
  dplyr::group_by(locus) %>%
  dplyr::summarise_if(is.numeric, sum) %>%
  as.data.frame() %>%
  dplyr::mutate(primerProbeProportion = primerProbeReads/primerReads)

# Loci counts for LWED samples only
lociReadCounts_lwed <- seqTest_compiled %>%
  filter(sample %in% samplesLWED$sampleID) %>%
  dplyr::group_by(locus) %>%
  dplyr::summarise_if(is.numeric, sum) %>%
  as.data.frame() %>%
  dplyr::mutate(primerProbeProportion = primerProbeReads/primerReads)

# Loci counts for SIMP samples only
lociReadCounts_simp <- seqTest_compiled %>%
  filter(sample %in% samplesSIMP$sampleID) %>%
  dplyr::group_by(locus) %>%
  dplyr::summarise_if(is.numeric, sum) %>%
  as.data.frame() %>%
  dplyr::mutate(primerProbeProportion = primerProbeReads/primerReads)
```

Using the species-subsets created above, we can then create a final locus read-count summary that's species-specific, such that:

-   values for LWED-specific loci reflect performance with LWED individuals only
-   values for SIMP-specific loci reflect performance with SIMP individuals only
-   all other loci reflect performance with LWED and SIMP individuals combined

```{r}
lociRC <- lociReadCounts_lwedSIMP %>%
  filter(!str_detect(locus, "LWED|SIMP"))
lociRC_lwed <- lociReadCounts_lwed %>%
  filter(str_detect(locus, "LWED"))
lociRC_simp <- lociReadCounts_simp %>%
  filter(str_detect(locus, "SIMP"))

lociReadCounts_combine <- rbind(lociRC, lociRC_lwed, lociRC_simp)
```

#### Allele frequencies

We also need allele frequency metrics per locus. To do this, we need to get the allele count data from the .genos files and compile.

*Note that reading in all of the .genos files will give a warning; this is because these files are output with two extra (empty) columns*

```{r}
# use full.names = T to list full sample path (avoid changing wd)
genoFiles_gtseq <- list.files(path = "/home/rachelvoyt/Documents/UT-Grad/Development/repos/tamGenetics_primatesPeru/gtscore_vs_gtseq/genos", pattern = "*interleaved.genos", full.names = T)

# use skip = 1 to skip reading the header
alleleReads_gtseq <- lapply(genoFiles_gtseq, fread, skip = 1, sep = ",", header = F, select = c("V1", "V2", "V3")) %>%
  set_names(genoFiles_gtseq) %>%
  rbindlist(idcol = "sample") %>%
  as.data.frame() %>%
  dplyr::mutate(sample = sub(".*genos/", "", sample)) %>%
  dplyr::mutate(sample = sub("\\_.*", "", sample)) %>%
  dplyr::mutate(sample = gsub("-","\\.", sample)) %>%
  dplyr::rename("locus" = "V1") %>%
  dplyr::mutate(allele1 = substr(V2, 1, 1)) %>%
  dplyr::mutate(allele2 = substr(V3, 1, 1)) %>%
  dplyr::mutate(allele1Reads = sub(".*=", "", V2)) %>%
  dplyr::mutate(allele2Reads = sub(".*=", "", V3)) %>%
  dplyr::mutate_at(c("allele1Reads", "allele2Reads"), as.numeric) %>%
  select(c(sample, locus, allele1, allele2, allele1Reads, allele2Reads))

alleleReads_lwedSIMP <- alleleReads_gtseq %>%
  filter(sample %in% samples_noNeg$sampleID) %>%
  dplyr::group_by(locus, allele1, allele2) %>%
  dplyr::summarise_if(is.numeric, sum) %>%
  as.data.frame()

alleleReads_lwed <- alleleReads_gtseq %>%
  filter(sample %in% samplesLWED$sampleID) %>%
  dplyr::group_by(locus, allele1, allele2) %>%
  dplyr::summarise_if(is.numeric, sum) %>%
  as.data.frame()

alleleReads_simp <- alleleReads_gtseq %>%
  filter(sample %in% samplesSIMP$sampleID) %>%
  dplyr::group_by(locus, allele1, allele2) %>%
  dplyr::summarise_if(is.numeric, sum) %>%
  as.data.frame()
```

Now we can combine the allele read-counts per locus, again species-specific so that species-specific loci only reflect read counts for samples of that species:

```{r}
alleleRC <- alleleReads_lwedSIMP %>%
  filter(!str_detect(locus, "LWED|SIMP"))
alleleRC_lwed <- alleleReads_lwed %>%
  filter(str_detect(locus, "LWED"))
alleleRC_simp <- alleleReads_simp %>%
  filter(str_detect(locus, "SIMP"))

alleleReads_combine <- rbind(alleleRC, alleleRC_lwed, alleleRC_simp)
```

#### Locus summary

And finally we can combine total read counts and allele read counts into a single locus summary file for GTseq:

```{r}
# Combined
locusSum_gtseq <- merge(lociReadCounts_combine, alleleReads_combine, by = "locus") %>%
  dplyr::mutate(alleleReadsTotal = allele1Reads + allele2Reads) %>%
  dplyr::mutate(maf_gtseq = pmax(allele1Reads, allele2Reads)/alleleReadsTotal)
```

## 3.3 GTscore data

### Genotypes

```{r}
# Genotypes
genos_gtscore <- read.table("./03_tamRun3/03_run3GTscore/fullSet_polyGenResults_singleSNP.txt", header = T)
```

### Locus summaries

The GTscore pipeline includes scripts that provide locus-specific metrics; e.g., primer reads, probe reads, genotype rate, etc. per locus.

I compiled the locus-specific metrics from the GTscore pipeline into a "master summary", in which...

-   values for LWED-specific loci reflect performance with LWED individuals only
-   values for SIMP-specific loci reflect performance with SIMP individuals only
-   all other loci reflect performance with LWED and SIMP individuals combined

```{r}
locusSum_gtscore <- read.csv("/home/rachelvoyt/Documents/UT-Grad/Development/repos/tamGenetics_primatesPeru/03_tamRun3/03_run3GTscore/summaryFiles/master_locusSummary.csv")
```

### Sample summaries

```{r}
# GTscore individual (sample) summary
indivSum_gtscore <- read.delim("./03_tamRun3/03_run3GTscore/fullSet_GTscore_individualSummary.txt",header=TRUE,stringsAsFactors=FALSE)

# GTscore single-SNP summary
ssSum_gtscore <- read.csv("./03_tamRun3/03_run3GTscore/fullSet_singleSNP_sampleSummary.csv")
```

# 4 Loci performance

For the first set of comparisons between the two pipelines, I'm going to look at results in relative to loci (vs. relative to samples, which is in the next section). Specifically, I'm looking at what each pipeline shows relative to:

1.  The proportion of primer-probe reads relative to primer reads
2.  Whether an loci have fixed alleles
3.  Whether particular loci are overamplifying relative to the others

## 4.1 Primer-probe proportion

The proportion of primer-probe reads to primer reads is helpful in assessing primer performance, where large discrepancies in primer, probe, and primer-probe reads can indicate artifact sequences, unaccounted for in-silico probe variations, or an in-silico probe sequence that's not specific to the target amplicon. As such, it's important to determine whether the GTseq and GTscore pipelines are providing similar values for primer, probe, and primer-probe reads.

GTseq documentation provides the following as examples:

-   Example 1: Artifact sequences.
    -   LocusName1, 325096 ,2609, 2367\
-   Example 2: Unaccounted for in-silico probe variation or possibly entirely off-target amplification.
    -   LocusName2, 32252, 0, 0
-   Example 3: in-silico probe not specific enough.
    -   LocusName3, 34435, 3400826, 33213

The proportion of primer-probe reads to primer reads was overall LOWER with GTscore vs. GTseq, but the mean difference was less than 1%. As such, it looks like both are providing similar values for locus reads.

```{r}
ppProp <- locusSum_gtscore %>%
  select(c(Locus, Primer.Probe.Proportion)) %>%
  dplyr::rename("locus" = "Locus") %>%
  dplyr::rename("ppProp_gtscore" = "Primer.Probe.Proportion") %>%
  merge(., locusSum_gtseq[, c("locus", "primerProbeProportion")], by = "locus") %>%
  dplyr::rename("ppProp_gtseq" = "primerProbeProportion") %>%
  mutate(ppProp_diff = ppProp_gtscore - ppProp_gtseq) %>%
  mutate_if(is.numeric, round, 2)
```

```{r}
summary(ppProp$ppProp_diff)
t.test(ppProp$ppProp_gtscore, ppProp$ppProp_gtseq, paired = T)
```

## 4.2 Fixed alleles

Any loci with fixed alleles are ones that we would ultimately want to take out of the primer pool; however, if they're not 100% fixed it would likely be better to keep them, since individuals with variations.

GTscore gives two loci as fixed. GTseq, however, shows these same loci as *almost* fixed, but not 100%. Given that there aren't any mismatched genotypes (see section 5.5), we can assume that the allele reads for those "almost-fixed" loci are from the cases where GTseq gave a genotype, but GTscore did not.

```{r}
maf <- locusSum_gtscore %>%
  dplyr::rename("locus" = "Locus") %>%
  dplyr::rename("maf_gtscore" = "majAF") %>%
  select(c(locus, maf_gtscore)) %>%
  merge(., locusSum_gtseq[, c("locus", "maf_gtseq")], by = "locus") %>%
  dplyr::mutate(mafDiff = maf_gtscore - maf_gtseq) %>%
  mutate_if(is.numeric, round, 2)

summary(maf$mafDiff)
```

## 4.3 Overamplifiers

To identify loci that are overamplifying in each pipeline, we'll be looking at primer-probe read counts for each locus in each pipeline.

### Primer-probe reads

First we'll set up species-specific dataframes for primer-probe reads from GTseq and GTscore and GTscore pipelines

GTseq & GTscore full dataframes

```{r}
# GTseq
ppReads_gtseq <- seqTest_compiled %>%
  select(!c(primerReads, probeReads)) %>%
  mutate(primerProbeReads =
           ifelse(sample %in% samplesLWED$sampleID & grepl("SIMP", locus), NA, 
                  ifelse(sample %in% samplesSIMP$sampleID & grepl("LWED", locus), NA, primerProbeReads))) %>%
  dplyr::rename("ppReads_gtseq" = "primerProbeReads")
  
# GTscore
repl <- function(x) gsubfn("(\\d+),(\\d+)", ~ as.numeric(x) + as.numeric(y), paste(x))

ppReads_gtscore <- read.table("./03_tamRun3/03_run3GTscore/fullSet_AlleleReads_singleSNPs.txt") %>%
  replace(., TRUE, lapply(., repl)) %>%
  rownames_to_column("Locus") %>%
  mutate(Locus = sub("_[^_]+$", "\\1", Locus)) %>%
  column_to_rownames("Locus") %>%
  rownames_to_column("locus") %>%
  pivot_longer(!locus,
               names_to = "sample",
               values_to = "ppReads_gtscore") %>%
  mutate(ppReads_gtscore =
           ifelse(sample %in% samplesLWED$sampleID & grepl("SIMP", locus), NA, 
                  ifelse(sample %in% samplesSIMP$sampleID & grepl("LWED", locus), NA, ppReads_gtscore)))
```

Merge dataframes & add species

```{r}
ppReads_seqScore <- merge(ppReads_gtseq, ppReads_gtscore, by = c("sample", "locus")) %>%
  mutate(species = ifelse(sample %in% samplesLWED$sampleID, "LWED",
                          ifelse(sample %in% samplesSIMP$sampleID, "SIMP", NA)))
```

Species-specific dataframes

```{r}
# LWED
ppReads_seqScore_lwed <- ppReads_seqScore %>%
  filter(species == "LWED") %>%
  select(!c(sample, species)) %>%
  mutate(ppReads_gtseq = as.numeric(ppReads_gtseq)) %>%
  mutate(ppReads_gtscore = as.numeric(ppReads_gtscore)) %>%
  dplyr::group_by(locus) %>%
  dplyr::summarise_if(is.numeric, sum) %>%
  as.data.frame() %>%
  na.omit()

# SIMP
ppReads_seqScore_simp <- ppReads_seqScore %>%
  filter(species == "SIMP") %>%
  select(!c(sample, species)) %>%
  mutate(ppReads_gtseq = as.numeric(ppReads_gtseq)) %>%
  mutate(ppReads_gtscore = as.numeric(ppReads_gtscore)) %>%
  dplyr::group_by(locus) %>%
  dplyr::summarise_if(is.numeric, sum) %>%
  as.data.frame() %>%
  na.omit()
```

Summary dataframe with species-specific read counts for each locus

```{r}
ppReads_seqScore_summary <- rbind(ppReads_seqScore_lwed %>%
                                    mutate(species = "LWED"), ppReads_seqScore_simp %>%
                                    mutate(species = "SIMP"))
```

Next we need define a function to find outliers. The function is set so that it will return the name of the locus when applied to our dataset.

```{r}
findoutlier <- function(x) {
  return(x < quantile(x, .25) - 1.5*IQR(x) | x > quantile(x, .75) + 1.5*IQR(x))
}
```

After applying the function, we can see that the same outliers occur in both pipelines for each species.

```{r}
# LWED
ppReads_outliers_lwed <- ppReads_seqScore_lwed %>%
  mutate(gtseqOutlier = ifelse(findoutlier(ppReads_gtseq), locus, NA)) %>%
  mutate(gtscoreOutlier = ifelse(findoutlier(ppReads_gtscore), locus, NA)) %>%
  mutate(species = "LWED")

# SIMP
ppReads_outliers_simp <- ppReads_seqScore_simp %>%
  mutate(gtseqOutlier = ifelse(findoutlier(ppReads_gtseq), locus, NA)) %>%
  mutate(gtscoreOutlier = ifelse(findoutlier(ppReads_gtscore), locus, NA)) %>%
  mutate(species = "SIMP")
```

Below is a summary dataframe containing the following:

-   Generic loci (i.e., those that are informative for both species), with species-specific read counts from each pipeline
-   Species-specific loci, with species-specific read counts from each pipeline

```{r}
ppReads_outliers_summary <- ppReads_outliers_lwed %>%
  filter(gtseqOutlier %in% ppReads_outliers_simp$gtseqOutlier) %>%
  rbind(.,
        ppReads_outliers_simp %>%
          filter(gtseqOutlier %in% ppReads_outliers_lwed$gtseqOutlier)) %>%
  rbind(.,
        ppReads_outliers_lwed %>%
          filter(str_detect(gtseqOutlier, "LWED"))) %>%
  rbind(.,
        ppReads_outliers_simp %>%
          filter(str_detect(gtseqOutlier, "SIMP"))) %>%
  na.omit()
```

### Plots


```{r}
ggplot(ppReads_seqScore_summary, aes(x=ppReads_gtscore, y=species)) +
  geom_boxplot() +
  geom_point(data = ppReads_outliers_summary %>%
               filter(!str_detect(locus, "LWED|SIMP")) %>%
               na.omit(),
             aes(color = locus)) +
  labs(title = "Total reads per locus (GTscore)", x = "Total number of reads", y = "") +
  theme_bw()
```

# 5 Sample performance

## 5.1 Total reads per sample

Both GTseq and GTscore pipelines give the same number of total reads per sample.

```{r, echo = F}
totalReads <- indivSum_gtscore %>%
  select(c(Sample, Total.Reads)) %>%
  dplyr::rename("totalReads_gtscore" = "Total.Reads") %>%
  merge(., genos_gtseq[, c("Sample", "Raw.Reads")], by = "Sample") %>%
  dplyr::rename("totalReads_gtseq" = "Raw.Reads") %>%
  mutate(totalReads_diff = totalReads_gtseq - totalReads_gtscore) %>%
  mutate(totalReads_avg = (totalReads_gtseq + totalReads_gtscore)/2)
```

```{r}
summary(totalReads$totalReads_diff)
```

## 5.2 On-target reads per sample

On-target read counts are usually HIGHER for GTseq vs. GTscore. This difference is proportional, where GTseq has 0.33% more on-target reads for any given number of on-target reads from GTscore.

```{r, echo = F}
otReads <- indivSum_gtscore %>%
  select(c(Sample, Primer.Probe.Reads)) %>%
  dplyr::rename("otReads_gtscore" = "Primer.Probe.Reads") %>%
  select(c(Sample, otReads_gtscore)) %>%
  merge(., genos_gtseq[, c("Sample", "On.Target.Reads")], by = "Sample") %>%
  dplyr::rename("otReads_gtseq" = "On.Target.Reads") %>%
  mutate(otReads_avg = (otReads_gtseq + otReads_gtscore)/2) %>%
  mutate(otReads_diff = otReads_gtseq - otReads_gtscore) %>%
  mutate(otReads_propDiff = (otReads_diff)/otReads_avg)
```

```{r}
summary(otReads$otReads_propDiff)
t.test(otReads$otReads_gtseq, otReads$otReads_gtscore, paired = T)
```

Quick normality test - neither GTseq or GTscore on-target reads have a normal distribution

```{r}
shapiro.test(otReads$otReads_gtseq)
shapiro.test(otReads$otReads_gtscore)
```

### Visualize otReads_diff

Plotting the log-transformed on-target reads show that GTseq on-target reads increase 1% for every 1% increase in GTscore on-target reads

```{r, echo = F}
ggplot(otReads, aes(x = log(otReads_gtseq), y = log(otReads_gtscore))) +
  geom_point() +
  geom_smooth(method = "lm", se=FALSE, color="mediumvioletred", formula = y ~ x, size = 0.75) +
  ggpubr::stat_regline_equation(label.y = 11, aes(label = ..eq.label..)) +
  ggpubr::stat_regline_equation(label.y = 10, aes(label = ..rr.label..)) +
  xlab("log(GTseq) on-target read counts per sample") +
  ylab("log(GTscore) on-target read counts per sample") +
  theme_pander()
```

And a Bland-Altman analysis shows us that on average, GTseq has 0.33% higher on-target reads relative to GTscore.

*Note that the "Percent difference" here is equivalent to log(GTseq) - log(GTscore)*

```{r, echo = F}
ggplot(otReads, aes(x = otReads_avg, y = otReads_propDiff)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = mean(otReads$otReads_propDiff, na.rm = T), colour = "mediumvioletred", size = 0.5) +
  geom_hline(yintercept = mean(otReads$otReads_propDiff, na.rm = T) - (1.96 * sd(otReads$otReads_propDiff, na.rm = T)), colour = "cornflowerblue", size = 0.5) +
  geom_hline(yintercept = mean(otReads$otReads_propDiff, na.rm = T) + (1.96 * sd(otReads$otReads_propDiff, na.rm = T)), colour = "cornflowerblue", size = 0.5) +
  annotate(geom = "label", label = "Mean % diff = 0.33%", x = 90000, y = mean(otReads$otReads_propDiff, na.rm = T), hjust = 0, vjust = 0) +
  ylab("Percent difference \n (GTseq - GTscore)/((GTseq + GTscore)/2)") +
  xlab("Mean on-target read counts per sample \n ((GTseq + GTscore)/2)") +
  theme_pander()

ggplot(otReads, aes(x = otReads_avg, y = otReads_diff)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = mean(otReads$otReads_diff, na.rm = T), colour = "mediumvioletred", size = 0.5) +
  geom_hline(yintercept = mean(otReads$otReads_diff, na.rm = T) - (1.96 * sd(otReads$otReads_diff, na.rm = T)), colour = "cornflowerblue", size = 0.5) +
  geom_hline(yintercept = mean(otReads$otReads_diff, na.rm = T) + (1.96 * sd(otReads$otReads_diff, na.rm = T)), colour = "cornflowerblue", size = 0.5) +
  annotate(geom = "label", label = "Mean % diff = 0.33%", x = 90000, y = mean(otReads$otReads_diff, na.rm = T), hjust = 0, vjust = 0) +
  ylab("Percent difference \n (GTseq - GTscore)/((GTseq + GTscore)/2)") +
  xlab("Mean on-target read counts per sample \n ((GTseq + GTscore)/2)") +
  theme_pander()
```

## 5.4 Genotype success per sample

Genotype success per sample was LOWER for GTseq vs. GTscore. This difference is proportional, where the proportion of loci genotyped by GTscore is 7.3% lower than by GTseq.

```{r}
genoRate <- ssSum_gtscore %>%
  select(c(sample, GenotypeRate)) %>%
  dplyr::rename("Sample" = "sample") %>%
  dplyr::rename("genoRate_gtscore" = "GenotypeRate") %>%
  select(c(Sample, genoRate_gtscore)) %>%
  merge(., genos_gtseq[, c("Sample", "X.GT")], by = "Sample") %>%
  dplyr::rename("genoRate_gtseq" = "X.GT") %>%
  mutate(genoRate_gtseq = genoRate_gtseq/100) %>%
  mutate_if(is.numeric, round, 2) %>%
  mutate(genoRate_avg = (genoRate_gtseq + genoRate_gtscore)/2) %>%
  mutate(genoRate_diff = genoRate_gtseq - genoRate_gtscore) %>%
  mutate(genoRate_propDiff = genoRate_diff/genoRate_avg)
```

```{r}
summary(genoRate$genoRate_diff, na.rm = T)
t.test(genoRate$genoRate_gtseq, genoRate$genoRate_gtscore, paired = T)
```

Quick normality test - neither GTseq or GTscore genotype rates have a normal distribution

```{r}
shapiro.test(genoRate$genoRate_gtseq)
shapiro.test(genoRate$genoRate_gtscore)
```

### Visualize genoRate_diff

Plotting the log-transformed genotype rates show that GTseq on-target reads increase 1% for every 1% increase in GTscore on-target reads

```{r, echo = F}
ggplot(genoRate, aes(x = log(genoRate_gtseq), y = log(genoRate_gtscore))) +
  geom_point() +
  geom_smooth(method = "lm", se=FALSE, color="mediumvioletred", formula = y ~ x, size = 0.75) +
  ggpubr::stat_regline_equation(label.y = -0.5, aes(label = ..eq.label..)) +
  ggpubr::stat_regline_equation(label.y = -1, aes(label = ..rr.label..)) +
  xlab("log(GTseq) % loci genotyped per sample") +
  ylab("log(GTscore) % loci genotyped per sample") +
  theme_pander()
```

And a Bland-Altman analysis shows us that on average, GTseq provides 7.3% FEWER genotypes per sample relative to GTscore.

*Note that the "Percent difference" here is equivalent to log(GTseq) - log(GTscore)*

```{r}
ggplot(genoRate, aes(x = genoRate_avg, y = genoRate_diff)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = mean(genoRate$genoRate_diff, na.rm = T), colour = "springgreen4", size = 0.5) +
  geom_hline(yintercept = mean(genoRate$genoRate_diff, na.rm = T) - (1.96 * sd(genoRate$genoRate_diff, na.rm = T)), colour = "cornflowerblue", size = 0.5) +
  geom_hline(yintercept = mean(genoRate$genoRate_diff, na.rm = T) + (1.96 * sd(genoRate$genoRate_diff, na.rm = T)), colour = "cornflowerblue", size = 0.5) +
  annotate(geom = "label", label = "Mean % diff = -7.3%", x = 0, y = mean(genoRate$genoRatgenoRate_diffe_propDiff, na.rm = T), hjust = 0, vjust = 0, fontface = "bold") +
  ylab("Percent difference \n (GTseq - GTscore)/((GTseq + GTscore)/2)") +
  xlab("Mean % loci genotyped per sample \n ((GTseq + GTscore)/2)") +
  theme_pander()

ggplot(genoRate, aes(x = genoRate_avg, y = genoRate_propDiff)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = mean(genoRate$genoRate_propDiff, na.rm = T), colour = "springgreen4", size = 0.5) +
  geom_hline(yintercept = mean(genoRate$genoRate_propDiff, na.rm = T) - (1.96 * sd(genoRate$genoRate_propDiff, na.rm = T)), colour = "cornflowerblue", size = 0.5) +
  geom_hline(yintercept = mean(genoRate$genoRate_propDiff, na.rm = T) + (1.96 * sd(genoRate$genoRate_propDiff, na.rm = T)), colour = "cornflowerblue", size = 0.5) +
  annotate(geom = "label", label = "Mean % diff = -7.3%", x = 0, y = mean(genoRate$genoRate_propDiff, na.rm = T), hjust = 0, vjust = 0, fontface = "bold") +
  ylab("Percent difference \n (GTseq - GTscore)/((GTseq + GTscore)/2)") +
  xlab("Mean % loci genotyped per sample \n ((GTseq + GTscore)/2)") +
  theme_pander()
```

## 5.5 Genotypes assigned per sample

Despite the differences in read counts and genotype success, there were no sample/loci combinations where gtscore and gtseq made different genotype calls.

```{r}
genos_gtscore_l <- genos_gtscore %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub("_[^_]+$", "", locus)) %>%
  column_to_rownames("locus") %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  pivot_longer(!sample,
               names_to = "locus",
               values_to = "genotype") %>%
  dplyr::rename("gtscore" = "genotype") %>%
  mutate(gtscore = sub(",", "", gtscore))
  
genos_gtseq_l <- genos_gtseq %>%
  select(!c(Raw.Reads, On.Target.Reads, X.On.Target, X.GT, IFI)) %>%
  pivot_longer(!Sample,
               names_to = "locus",
               values_to = "genotype") %>%
  dplyr::rename("gtseq" = "genotype") %>%
  mutate(Sample = sub("-", "\\.", Sample)) %>%
  rename("sample" = "Sample")

genos_seqScore <- merge(genos_gtscore_l, genos_gtseq_l, by = c("sample", "locus"), all = T) %>%
  mutate(genosCalled = rowSums(select(., -sample, -locus) != 0, na.rm = T)) %>%
  mutate(zerosCalled = rowSums(select(., -sample, -locus, -genosCalled) == 0, na.rm = T)) %>%
  rowwise() %>%
  mutate(uniqueGenos = ifelse(zerosCalled > 0,
                              (n_distinct(c_across(gtscore:gtseq), na.rm = T)) - 1,
                              (n_distinct(c_across(gtscore:gtseq), na.rm = T))
                              ))

max(genos_seqScore$uniqueGenos)
```

However, there were 3262 sample/loci combinations where only one pipeline called a genotype.

Of these, GTseq called 87 genotypes where GTscore did not, and GTscore called 3175 genotypes when GTseq did not.

Perhaps of note, of the instances where GTseq called genotypes when GTscore didn't, the vast majority were homozygous.

```{r}
genos_seqScore_zeros <- genos_seqScore %>%
  filter(genosCalled == 1)

length(genos_seqScore_zeros$sample)
length(which(genos_seqScore_zeros$gtscore == 0))
length(which(genos_seqScore_zeros$gtseq == 0))
```

# X Compare genotypes without the 10x gtscore cutoff

There were still no sample/loci combinations where gtscore and gtseq made different genotype calls.

```{r}
genos_gtscore_no10x <- read.table("./03_tamRun3/03_run3GTscore/fullSet_polyGenResults_singleSNP_no10x.txt", header = T)

genos_gtscore_no10x_l <- genos_gtscore_no10x %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub("_[^_]+$", "", locus)) %>%
  column_to_rownames("locus") %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  pivot_longer(!sample,
               names_to = "locus",
               values_to = "genotype") %>%
  dplyr::rename("gtscore" = "genotype") %>%
  mutate(gtscore = sub(",", "", gtscore))

genos_seqScore_no10x <- merge(genos_gtscore_no10x_l, genos_gtseq_l, by = c("sample", "locus"), all = T) %>%
  mutate(genosCalled = rowSums(select(., -sample, -locus) != 0, na.rm = T)) %>%
  mutate(zerosCalled = rowSums(select(., -sample, -locus, -genosCalled) == 0, na.rm = T)) %>%
  rowwise() %>%
  mutate(uniqueGenos = ifelse(zerosCalled > 0,
                              (n_distinct(c_across(gtscore:gtseq), na.rm = T)) - 1,
                              (n_distinct(c_across(gtscore:gtseq), na.rm = T))
                              ))

max(genos_seqScore_no10x$uniqueGenos)
```

However, there were 14,700 (vs. 3262) sample/loci combinations where only one pipeline called a genotype.

Of these, GTseq called 57 (vs. 87) genotypes where GTscore did not, and GTscore called 14,643 (vs. 3175) genotypes when GTseq did not.

Similar to the 10x gtseq genotype comparison, of the instances where GTseq called genotypes when GTscore didn't, all calls were homozygous.

```{r}
genos_seqScore_zeros_no10x <- genos_seqScore_no10x %>%
  filter(genosCalled == 1)

length(genos_seqScore_zeros_no10x$sample)
length(which(genos_seqScore_zeros_no10x$gtscore == 0))
length(which(genos_seqScore_zeros_no10x$gtseq == 0))

genos_no10x_zeros_score <- genos_seqScore_zeros_no10x %>%
  filter(gtscore == 0)
table(genos_no10x_zeros_score$gtseq)

genos_no10x_zeros_seq <- genos_seqScore_zeros_no10x %>%
  filter(gtseq == 0)
```
