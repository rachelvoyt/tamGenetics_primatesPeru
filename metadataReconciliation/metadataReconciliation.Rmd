---
title: "metadataReconciliation"
author: "Rachel Voyt"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1 Overview

This set of scripts is to address metadata discrepancies that I discovered for the samples I used for the tamGenetics project. The main issue is that some samples were assigned the same tube or envelope number when originally collected in the field.

For blood samples, these tube numbers were differentiated by "a" or "b" - thinking that a/b referred to additional sample material from the same individual, I used whichever version I could find. However, a/b instead referred to a different individual entirely, which means that some of my metadata is incorrect.

In the case of hair samples, I had noticed the issue of duplicated envelope numbers when first identifying which samples to include. The envelope numbers had additional metadata written, which made things a bit easier. Based on **sampleNotes_RV.docx**, I caught all of these duplicates and used only one envelope per duplicate pair except for env_301, where I needed to use both. There are additional details on that document, but the summary I gave is as follows:

"A handful of samples from 2017 share an envelope number, and in some cases the dates/names may be switched between them (based on dates listed in the AllCaptures_2019 file and the hair sample files). For the samples that we need, I took the envelope that matched all other info but the date. The other samples I put in a separate bag within the original 2017 bag."

# 2 Packages

```{r}
library(janitor)
library(tidyverse)
```

# 3 Data

## 3.1 Metadata

### md_tamRun5

tamRun5 has 440 total samples

```{r}
md_tamRun5_original <- read.csv("./metadataReconciliation/tamRun5_metadata_original.csv") %>%
  arrange(sampleID) %>%
  separate("captureDate", into = c("captureMonth", "captureDay", "captureYear"), sep = "/") %>%
  mutate(
    captureDate = as.Date(with(., paste(captureYear, captureMonth, captureDay, sep="-")), "%Y-%m-%d")
  ) %>%
  relocate(captureDate, .before = group) %>%
  select(-captureDay, -captureMonth, -captureYear)
```

### capData_byIndiv

Import latest cleaned version of capData_byIndiv (v5)

```{r}
capData_byIndiv_v5 <- read.csv("./paper3_demographics/01_dataOrganization/02_dataCleaning/captureData_byIndividual_v5.csv")

capData_byIndiv_v5_firstEntry <- capData_byIndiv_v5[match(unique(capData_byIndiv_v5$animalID), capData_byIndiv_v5$animalID),]
```

Get a clean list of metadata for each unique animalID

```{r}
capData_byIndiv_v5_byAnimalID <- capData_byIndiv_v5 %>%
  select(animalID, species, sex) %>%
  distinct() %>%
  # remove UNK animalIDs
  filter(animalID != "UNK") %>%
  arrange(as.numeric(animalID))

# confirm that each animalID is associated with only one set of species/sex info (not including UNK animalIDs)
capData_byIndiv_v5_byAnimalID %>%
  select(animalID) %>%
  get_dupes(animalID)
```

## 3.2 Samples

### samples_tamRun5

In reconciling any metadata issues, I'm working under the assumption that samples extracted by Mini have their correct metadata and thus am not including them in my checks - plus, I don't have the original sample names she used for those extractions.

I am adding some sample names here though because for earlier years, hair envelopes didn't have sample numbers - as such, I originally left the "sampleName" variable as NA. Here I'm assigning their sampleName based on their animalName (env_animalName).

In total then, we have n = 285 unique samples in tamRun5.

```{r}
md_tamRun5_v1 <- md_tamRun5_original %>%
  mutate(
    sampleName = case_when(
      is.na(sampleName) & !is.na(lysisDate) & sampleType == "hair" ~ str_c("env_", animalName),
      .default = sampleName
    )
  )

write.csv(md_tamRun5_v1, "./metadataReconciliation/tamRun5_metadata_v1.csv", row.names = F)
```

```{r}
samples_tamRun5 <- md_tamRun5_v1 %>%
  # remove samples that I didn't extract
  filter(!is.na(lysisDate)) %>%
  # remove a/b from sampleNames
  mutate(
    sampleName = case_when(
      str_detect(sampleName, "a") ~ gsub("a", "", sampleName),
      str_detect(sampleName, "b") ~ gsub("b", "", sampleName),
      .default = sampleName
    )
  ) %>%
  mutate(
    animalID_sampleName = str_c(animalID, "_", sampleName)
  ) %>%
  select(sampleID, captureDate, animalID, animalName, sampleName, animalID_sampleName) %>%
  na.omit()
```

### samples_capData

To help with metadata reconciliation, I also went through the trapping sheets and recorded the sample names listed; this information is on the google sheet captureData_samples within the tamGenetics_demographics_dataCleaning file. For the sake of time, I only went through trap sheets from 2012 to 2019 (earlier years don't list sample names, only the number of samples collected per sample type).

```{r}
capData_sampleFile <- read.csv("./metadataReconciliation/captureData_samples_15May2024.csv", na.strings = c("", "NA")) %>%
  filter(!str_detect(captureDate, "2021"))

# reformat data
## blood samples
capData_samplesBlood <- capData_sampleFile %>%
  select(rowID, animalID, samplesLongmire) %>%
  na.omit() %>%
  separate("samplesLongmire", into = c("lm1", "lm2", "lm3", "lm4", "lm5"), sep = ", ") %>%
  pivot_longer(!c(rowID, animalID),
               names_to = "lm_version",
               values_to = "sampleName") %>%
  na.omit() %>%
  select(-lm_version) %>%
  mutate(sampleName = str_c("lm_", sampleName))

## hair samples
capData_samplesHair <- capData_sampleFile %>%
  select(rowID, animalID, samplesHairDNA) %>%
  dplyr::rename("sampleName" = "samplesHairDNA") %>%
  na.omit() %>%
  arrange(as.numeric(animalID)) %>%
  mutate(sampleName = str_c("env_", sampleName))

# FULL LIST SAMPLENAMES
samples_capData <- rbind(capData_samplesBlood, capData_samplesHair) %>%
  merge(., capData_sampleFile[, c("rowID", "captureDate")], by = "rowID") %>%
  relocate(captureDate, .after = rowID) %>%
  mutate(
    animalID_sampleName = str_c(animalID, "_", sampleName)
  )
```

### CICRA files

from /sampleOrganization/originalData

```{r}
hairSamples_2013to2019_file <- read.csv("./sampleOrganization/originalData/hairSamples_CICRA_2013-2019.csv") %>%
  dplyr::rename("sampleName" = "envelopeNo.") %>%
  mutate(
    sampleName = str_c("env_", sampleName),
    animalID_sampleName = str_c(animalID, sampleName, sep = "_")
    )

bloodSamples_2013to2019_file <- read.csv("./sampleOrganization/originalData/longmireLog_CICRA_2013-2019.csv") %>%
  dplyr::rename("sampleName" = "tubeNo.") %>%
  mutate(
    sampleName = str_c("lm_", sampleName),
    animalID_sampleName = str_c(animalID, sampleName, sep = "_")
    )
```

### xtns

...I'm also going to need to update this

```{r}
xtnMaster_blood <- read.csv("/home/rachelvoyt/Documents/UT-Grad/Development/repos/tamGenetics_primatesPeru/extractions/tamGenetics_xtnsBlood_master_updated22Aug2023.csv")

xtnMaster_hair <- read.csv("/home/rachelvoyt/Documents/UT-Grad/Development/repos/tamGenetics_primatesPeru/extractions/tamGenetics_xtnsHair_master_updated22Aug2023.csv")
```

# 4 Check sampleName assignments

## 4.1 errorChecks

### errorChecks1: sampleNames not in capData

Any sampleNames in md_tamRun5 that aren't in capData_samples?

**n = 18 sampleNames in md_tamRun5 that are not in capData_samples**

```{r}
errorChecks1_sampleNames_tamRun5_notIn_capData <- samples_tamRun5 %>%
  filter(!sampleName %in% samples_capData$sampleName) %>%
  # remove sampleNames w/o env number
  filter(!sampleName %in% grep("\\d+", sampleName, value = TRUE, invert = TRUE)) %>%
  arrange(sampleName)

nrow(errorChecks1_sampleNames_tamRun5_notIn_capData)
```

We can go through these one by one to see what the issue might be - after looking through all of the capData records, it seems safe to assume that the sampleNames that I have in my records are correct.

We can also check the hairSamples_CICRA_2013-2019.csv file to see if they were recorded in there. No samples were missing aside from those with env_animalName; 

```{r}
samples_tamRun5 %>%
  filter(str_detect(sampleName, "env")) %>%
  filter(!sampleName %in% hairSamples_2013to2019_file$sampleName)

samples_tamRun5 %>%
  filter(str_detect(sampleName, "lm")) %>%
  filter(!sampleName %in% bloodSamples_2013to2019_file$sampleName)
```

I'm adding a column to list potential alternative animalIDs just in case though - this is only when capData has a sampleName listed for the individual in question as well as another individual in the datasheet (even if I've determined that the sampleName assigned is likely incorrect).

```{r}
errorChecks1_actionList <- errorChecks1_sampleNames_tamRun5_notIn_capData %>%
  mutate(
    notes_mdReconciliation = case_when(
      # hair samples
      sampleName == "env_13" ~ "no hair sample listed on trapping sheet; assume env_13 is likely correct",
      sampleName == "env_534" ~ "no hair sample listed on trapping sheet; assume env_534 is likely correct",
      sampleName == "env_567" ~ "no hair sample listed on trapping sheet; assume env_567 is likely correct",
      sampleName == "env_573" ~ "trapping sheet has env_572 (dup w/animalID 283); assume env_573 is likely correct",
      sampleName == "env_574" ~ "trapping sheet has env_542 (not found w/any other animalIDs); given that env_574 makes more sense given the other envelope names assigned around this time, assume env_574 is likely correct",
      sampleName == "env_589" ~ "no hair sample listed on trapping sheet; assume env_589 is likely correct",
      sampleName == "env_611" ~ "trapping sheet has env_591 (dup w/animalID 275); assume env_611 is likely correct",
      
      # blood samples
      sampleName == "lm_350" ~ "trapping sheet notes have '550??, 551' highlighted yellow right below '515, 551'; lm_515 is also assigned to animalID 167/RBG captureDate 6/28/2016 and lm_550 is also assigned to animalID 179/LRC3 captureDate 6/09/2017; given that lm_350 makes more sense with regard to other longmire sampleNames assigned during the 2015 captureYear, AND it's what I have in my records, assume lm_350 as likely correct",
      sampleName == "lm_383" ~ "trapping sheet has lm_382 (dup w/animalID 144); assume lm_383 is likely correct",
      sampleName == "lm_414" ~ "trapping sheet has lm_415 (dup w/animalID 15/YRC_SPS); assume lm_414 is likely correct",
      sampleName == "lm_910" ~ "trapping sheet missing; assume lm_910 is likely correct",
      sampleName == "lm_1135" ~ "trapping sheet missing; assume lm_1135 is likely correct",
      sampleName == "lm_1136" ~ "trapping sheet missing; assume lm_1136 is likely correct",
      sampleName == "lm_1140" ~ "trapping sheet missing; assume lm_1140 is likely correct",
      sampleName == "lm_1148" ~ "trapping sheet missing; assume lm_1148 is likely correct",
      sampleName == "lm_1150" ~ "trapping sheet missing; assume lm_1150 is likely correct",
      sampleName == "lm_1170" ~ "trapping sheet missing; assume lm_1170 is likely correct ",
      sampleName == "lm_1171" ~ "trapping sheet missing; assume lm_1171 is likely correct",
      .default = NA
      )
  ) %>%
  # add animalID_alt just in case
  mutate(
    animalID_alt = case_when(
      # hair samples
      sampleName == "env_13" ~ NA,
      sampleName == "env_534" ~ NA,
      sampleName == "env_567" ~ NA,
      sampleName == "env_573" ~ "283",
      sampleName == "env_574" ~ NA,
      sampleName == "env_589" ~ NA,
      sampleName == "env_611" ~ "275",
      
      # blood samples
      sampleName == "lm_1135" ~ NA,
      sampleName == "lm_1136" ~ NA,
      sampleName == "lm_1140" ~ NA,
      sampleName == "lm_1148" ~ NA,
      sampleName == "lm_1150" ~ NA,
      sampleName == "lm_1170" ~ NA,
      sampleName == "lm_1171" ~ NA,
      sampleName == "lm_350" ~ "167, 179",
      sampleName == "lm_383" ~ "144",
      sampleName == "lm_414" ~ "15",
      #sampleName == "env_56" ~ "50",
      sampleName == "lm_910" ~ NA,
      
      .default = NA
      )
  ) %>%
  mutate(
    flagged_in = "errorChecks1",
    action = case_when(
      is.na(animalID_alt) ~ "keepOriginal",
      .default = "tbd"
      )
  ) %>%
  arrange(sampleID)
```

### errorChecks2: animalID_sampleNames not in capData

Now we can check to see if any animalID/sampleName combos in md_tamRun5 don't exist in capData, excluding those that we addressed in the section above. **We find n = 4 animalID/sampleName combos in md_tamRun5 don't exist in capData.**

```{r}
errorChecks2_animalID_sampleNames_tamRun5_notIn_capData <- samples_tamRun5 %>%
  # remove entries resolved in errorChecks1
  filter(!sampleID %in% errorChecks1_actionList$sampleID) %>%
  # remove sampleNames w/o env number
  filter(!sampleName %in% grep("\\d+", sampleName, value = TRUE, invert = TRUE)) %>%
  # identify animalID/sampleName combos not in capData
  filter(!animalID_sampleName %in% samples_capData$animalID_sampleName) %>%
  arrange(sampleName)

errorChecks2_animalID_sampleNames_tamRun5_notIn_capData

nrow(errorChecks2_animalID_sampleNames_tamRun5_notIn_capData)
```

When checking the CICRA sample files, there don't appear to be any discrepancies between animalID/sampleName combos in these files vs. those in md_tamRun5; this means that whatever issues exist in tamRun5 likely also exist in the CICRA files.

```{r}
samples_tamRun5 %>%
  filter(str_detect(sampleName, "env")) %>%
  filter(!animalID_sampleName %in% hairSamples_2013to2019_file$animalID_sampleName)

samples_tamRun5 %>%
  filter(str_detect(sampleName, "lm")) %>%
  filter(!animalID_sampleName %in% bloodSamples_2013to2019_file$animalID_sampleName)
```

Given that the sampleNames in the list above must exist in capData (since any that didn't were resolved in errorChecks1), this means that they must be assigned to a different animalID in md_tamRun5 than in capData. We can see which ones those are below:

```{r}
samples_capData %>%
  filter(sampleName %in% errorChecks2_animalID_sampleNames_tamRun5_notIn_capData$sampleName) %>%
  arrange(sampleName)
```

And with that (plus double-checking all of the trapping sheets), we can create the actionList for errorChecks2:

```{r}
errorChecks2_actionList <- errorChecks2_animalID_sampleNames_tamRun5_notIn_capData %>%
  mutate(
    notes_mdReconciliation = case_when(
      sampleName == "env_27" ~ "Trapping sheets show that env_27 belongs to animalID 27/OBL, while animalID 98/OBG captureDate 7/06/2013 has env_33; update animalID 98 to 27",
      sampleName == "env_28" ~ "Trapping sheets show that env_28 belongs to animalID 69/OBO, while animalID 70/OBW captureDate 7/06/2013 has env_29; update animalID 70 to 69",
      sampleName == "env_298" ~ "Trapping sheets show that env_298 belongs to animalID 200/OBR_RC, while animalID 169 has env_261; 169 has captureDate 6/19/2017 while 200 has 6/16/2017 has env_298, suggesting that env_298 does belong to 200; supported by sampleNotes which says that env label had 'OBR SFUS AR6 on label', which is animalID 200's group; update animalID 169 to 200",
      sampleName == "env_32" ~ "Trapping sheets show that env_32 belongs to animalID 26/OBY, while animalID 69/OBO captureDate 7/06/2013 has env_28; update animalID 69 to 26",
      .default = NA
      )
  ) %>%
  mutate(
    animalID_alt = case_when(
      sampleName == "env_27" ~ "27",
      sampleName == "env_28" ~ "69",
      sampleName == "env_298" ~ "200",
      sampleName == "env_32" ~ "26",
      .default = NA
      )
  ) %>%
  mutate(
    flagged_in = "errorChecks2",
    action = "update_toAlt"
  )
```

### errorChecks3: dupSampleNames

In capData_samples, where sampleNames are taken directly from the trapping sheet for each individual, there are **40 duplicated blood sample names** and **17 duplicated hair sample names**. Each has been assigned to two animalIDs.

```{r}
# DUP SAMPLE NAMES
capData_sampleNames_dups <- samples_capData %>%
  get_dupes(sampleName) %>%
  select(rowID, animalID, sampleName, dupe_count)

## blood samples - 40 dup sampleNames
capData_sampleNames_dupes_blood <- capData_sampleNames_dups %>%
  filter(str_detect(sampleName, "lm"))

capData_sampleNames_dupes_blood %>%
  select(sampleName) %>%
  distinct() %>%
  nrow()

## hair samples - 17 dup sampleNames
capData_sampleNames_dupes_hair <- capData_sampleNames_dups %>%
  filter(str_detect(sampleName, "env"))

capData_sampleNames_dupes_hair %>%
  select(sampleName) %>%
  distinct() %>%
  nrow()
```

We already resolved a few of these in errorChecks1 (and errorChecks2 sampleNames didn't have dupes), but we can check to see if there are any that we missed -- **there are n = 21 sampleNames within md_tamRun5 that are in the capData_sampleNames_dup list.**

```{r}
errorChecks3_dupSampleNames <- samples_tamRun5 %>%
  # remove entries resolved in errorChecks1
#  filter(!sampleID %in% errorChecks1_actionList$sampleID) %>%
  # remove entries resolved in errorChecks2
#  filter(!sampleID %in% errorChecks2_actionList$sampleID) %>%
  # identify samples in capData_sampleNames_dups
  filter(sampleName %in% capData_sampleNames_dups$sampleName) %>%
  arrange(sampleName)
errorChecks3_dupSampleNames

nrow(errorChecks3_dupSampleNames)

# get capData for above sampleNames
errorChecks3_dupSampleNames_capData <- capData_sampleNames_dups %>%
  filter(sampleName %in% errorChecks3_dupSampleNames$sampleName) %>%
  select(-dupe_count) %>%
  merge(., errorChecks3_dupSampleNames[, c("animalID", "sampleName", "animalID_sampleName")], by = c("animalID", "sampleName"), all.x = T) %>%
  mutate(
    temp = case_when(
      !is.na(animalID_sampleName) ~ "animalID_tamRun5",
      .default = "animalID_alt"
    )
  ) %>%
  select(-animalID_sampleName) %>%
  # remove env_301 for now
  filter(sampleName != "env_301") %>%
  pivot_wider(id_cols = -rowID,
              names_from = temp,
              values_from = animalID) %>%
  rbind(., c("env_301", "54", "91")) %>%
  rbind(., c("env_301", "91", "54")) %>%
  merge(., samples_capData[, c("sampleName", "animalID", "rowID")], by.x = c("animalID_alt", "sampleName"), by.y = c("animalID", "sampleName"), all.x = T) %>%
  relocate(c(sampleName, animalID_tamRun5)) %>%
  arrange(sampleName)
```

For the hair samples, I can confirm that at least some of the duplicated envelope numbers did actually end up on the physical envelopes - I have notes on 10 of these in sampleNotes_RV.docx (env_292, env_293, env_294, env_295, env_302, env_303, env_306, env_307, env_308, env_309).

For the blood samples, I discovered (post-sequencing) that for the handful of longmire tubes that had an "a" or "b" after the number (n = 8), those a's and b's were not in fact referring to additional tubes for the same individual, but instead were differentiating between two entirely different individuals. Those samples include: lm_582b, lm_583a, lm_585b, lm_586a, lm_588a, lm_592a, lm_596a, and lm_600a. Some of these match the individual that I originally used for the metadata, but some don't.

```{r}
errorChecks3_actionList <- errorChecks3_dupSampleNames %>%
  mutate(
    notes_mdReconciliation = case_when(
      # hair samples
      sampleName == "env_233" ~ "env_233 makes more sense numerically for animalID 190, but can't say for sure that animalID 2 isn't possible - with that said, animalID 190 is LWED and 2 is SIMP, so that should help",
      sampleName == "env_294" ~ "sampleName also assigned to animalID 107, but notes on env align with 142; assume that animalID 142 is likely correct",
      sampleName == "env_295" ~ "sampleName also assigned to animalID 199, but notes on env align with 9; assume that animalID 9 is likely correct",
      animalID_sampleName == "54_env_301" ~ "sampleName also assigned to animalID 91, but notes on env align with 54; assume that animalID 54 is likely correct",
      animalID_sampleName == "91_env_301" ~ "sampleName also assigned to animalID 54, but notes on env align with 91; assume that animalID 91 is likely correct",
      sampleName == "env_306" ~ "sampleName also assigned to animalID 63, but notes on env align with 205; assume that animalID 205 is likely correct",
      sampleName == "env_572" ~ "sampleName also assigned to animalID 34; however, errorChecks1 suggests that animalID 34 should have env_573; this plus the fact that I assume the env notes aligned w/283 suggests that animalID 283 is correct here, but since these indivs were part of the same capture, might be good to look at both",
      sampleName == "env_591" ~ "sampleName also assigned to animalID 289; however errorChecks1 suggests that animalID 289 should have env_611; this plus the fact that I assume the env notes aligned w/275 suggests that animalID 275 is correct here, but good to look at both just in case",
      sampleName == "env_77" ~ "sampleName also assigned to animalID 24; animalID 24 is NOT present in other errorChecks; 134 should be male & 24 should be female, which should help",
      
      # blood samples
      sampleName == "lm_1225" ~ "trapping sheet for animalID 34 has lm_1225 and lm_1226 listed (both also found on animalID 283's trapping sheet), but below has lm_1227, lm_1228, and lm_1232 all highlighted in red; a closer look shows that all sample info on 34's trapping sheet follows this pattern - looks like 283's trapping sheet was copy/pasted, with updated values for 34 in red highlight; assume animalID 283 for lm_1225 is likely correct",
      sampleName == "lm_1229" ~ "trapping sheet for animalID 74 has lm_1233 and lm_1229 listed (both also found on animalID 195's trapping sheet), but below has lm_1221 highlighted in red; same pattern follows with some (but not all) other sample info (looks like 195's info was copy/pasted, with updated values for 74 in red highlight); assume animalID 195 for lm_1229 is likely correct",
      sampleName == "lm_434" ~ "listed on trapping sheets for both animalID 8 (which I have on md_tamRun5) as well as animalID 135; can't find any info to suggest that one or the other is correct, though 8 is LWED and 135 is SIMP which should help",
      sampleName == "lm_515" ~ "while lm_515 is also listed for animalID 139, this is likely incorrect and should be lm_350 (see notes from errorChecks1 on lm_350 for details); can therefore assume that animalID 167 for lm_515 is likely correct",
      sampleName == "lm_582" ~ "listed for both animalID 74 & 169; md_tamRun5 has lm_582b, suggesting that it belongs to the individual with the later captureDate (i.e., 169) - species/sex assignments support this assignment; assume that animalID 169 for lm_582 is likely correct",
      sampleName == "lm_583" ~ "listed for both animalID 22 & 169; md_tamRun5 has lm_583a, suggesting that it belongs to the individual with the earlier captureDate (i.e., 22) - species/sex assignments support this assignment; assume that animalID 22 for lm_583 is likely correct",
      sampleName == "lm_585" ~ "listed for both animalID 12 & 26; md_tamRun5 has lm_585b, suggesting that it belongs to the individual with the later captureDate (i.e., 26) - species/sex assignments support this assignment; update animalID 12 to 26",
      sampleName == "lm_586" ~ "listed for both animalID 196 & 212; md_tamRun5 has lm_586a, suggesting that it belongs to the individual with the earlier captureDate (i.e., 196) - species/sex assignments support this assignment; update animalID 212 to 196",
      sampleName == "lm_588" ~ "listed for both animalID 171 & 211; md_tamRun5 has lm_588a, suggesting that it belongs to the individual with the earlier captureDate (i.e., 171) - species/sex assignments support this assignment; update animalID 211 to 171",
      sampleName == "lm_592" ~ "listed for both animalID 200 & 215; md_tamRun5 has lm_592a, suggesting that it belongs to the individual with the earlier captureDate (i.e., 200) - species/sex assignments support this assignment; update animalID 215 to 200",
      sampleName == "lm_596" ~ "listed for both animalID 107 & 213; md_tamRun5 has lm_596a, suggesting that it belongs to the individual with the earlier captureDate (i.e., 107) - species/sex assignments support this assignment; update animalID 213 to 107",
      sampleName == "lm_600" ~ "listed for both animalID 27 & 214; md_tamRun5 has lm_600a, suggesting that it belongs to the individual with the earlier captureDate (i.e., 27) - species/sex assignments support this assignment; update animalID 214 to 27",
      .default = NA
      )
  ) %>%
  mutate(
    animalID_alt = case_when(
      # hair samples
      animalID_sampleName == "190_env_233" ~ "2",
      animalID_sampleName == "142_env_294" ~ "107",
      animalID_sampleName == "9_env_295" ~ "199",
      animalID_sampleName == "54_env_301" ~ "91",
      animalID_sampleName == "91_env_301" ~ "54",
      animalID_sampleName == "205_env_306" ~ "63",
      animalID_sampleName == "283_env_572" ~ "34",
      animalID_sampleName == "275_env_591" ~ "289",
      animalID_sampleName == "134_env_77" ~ "24",
      
      # blood samples
      animalID_sampleName == "283_lm_1225" ~ "34",
      animalID_sampleName == "195_lm_1229" ~ "74",
      animalID_sampleName == "8_lm_434" ~ "135",
      animalID_sampleName == "167_lm_515" ~ "139",
      animalID_sampleName == "169_lm_582" ~ "74",
      animalID_sampleName == "22_lm_583" ~ "169",
      animalID_sampleName == "12_lm_585" ~ "26",
      animalID_sampleName == "212_lm_586" ~ "196",
      animalID_sampleName == "211_lm_588" ~ "171",
      animalID_sampleName == "215_lm_592" ~ "200",
      animalID_sampleName == "213_lm_596" ~ "107",
      animalID_sampleName == "214_lm_600" ~ "27",
      .default = NA
      )
  ) %>%
  mutate(
    flagged_in = "errorChecks3",
    action = case_when(
      sampleName == "env_233" ~ "tbd",
      sampleName == "env_294" ~ "keepOriginal",
      sampleName == "env_295" ~ "keepOriginal",
      animalID_sampleName == "54_env_301" ~ "keepOriginal",
      animalID_sampleName == "91_env_301" ~ "keepOriginal",
      sampleName == "env_306" ~ "keepOriginal",
      sampleName == "env_572" ~ "tbd",
      sampleName == "env_591" ~ "tbd",
      sampleName == "env_77" ~ "tbd",
      sampleName == "lm_1225" ~ "keepOriginal",
      sampleName == "lm_1229" ~ "keepOriginal",
      sampleName == "lm_434" ~ "tbd",
      sampleName == "lm_515" ~ "keepOriginal",
      sampleName == "lm_582" ~ "keepOriginal",
      sampleName == "lm_583" ~ "keepOriginal",
      sampleName == "lm_585" ~ "update_toAlt",
      sampleName == "lm_586" ~ "update_toAlt",
      sampleName == "lm_588" ~ "update_toAlt",
      sampleName == "lm_592" ~ "update_toAlt",
      sampleName == "lm_596" ~ "update_toAlt",
      sampleName == "lm_600" ~ "update_toAlt",
      .default = NA
      )
  )
```

### errorChecks_fullList_v1

In total, there were 43 entries that needed checking - based on what I found, I think that it's safe to keep the original metadata for 23 of these entries. There are 10 entries where I think I should check both the original metadata and that for the alternate animalID for that sample, and 10 entries where I think the original metadata is incorrect and should be updated to the alternate animalID.

For entries that need to be updated, the following columns will need to be changed: animalID, animalName, species, sex, group, captureDate, fieldNotes

```{r}
errorChecks_fullList_v1 <- rbind(errorChecks1_actionList,
                              errorChecks2_actionList,
                              errorChecks3_actionList) %>%
  relocate(flagged_in, .after = animalID_sampleName) %>%
  relocate(c(animalID_alt, action), .before = notes_mdReconciliation) %>%
  merge(., capData_byIndiv_v5_byAnimalID, by.x = "animalID_alt", by.y = "animalID", all.x = T) %>%
  mutate(
    md_alt = str_c(animalID_alt, species, sex, sep = "_")
  ) %>%
  select(-species, -sex) %>%
  
  # add species/sex for original entry & create short md col
  merge(.,
        md_tamRun5_v1[, c("sampleID", "species", "sex")], by = "sampleID", all.x = T) %>%
  mutate(
    md_original = str_c(animalID, species, sex, sep = "_")
  ) %>%
  select(-species, -sex) %>%
  
  # add rowIDs so can add alt group & captureDate
  ## rowIDs errorChecks1
  mutate(
    rowID = case_when(
      #sampleName == "env_56" ~ "207",
      sampleName == "lm_350" ~ "379, 401",
      sampleName == "lm_383" ~ "307",
      sampleName == "lm_414" ~ "336",
      sampleName == "env_573" ~ "576",
      sampleName == "env_611" ~ "553",
    )
  ) %>%
  ## rowIDs errorChecks2 & 3
  merge(., samples_capData[, c("animalID", "sampleName", "rowID")], by.x = c("animalID_alt", "sampleName"), by.y = c("animalID", "sampleName"), all.x = T) %>%
  
  mutate(
    rowID = coalesce(as.character(rowID.x), as.character(rowID.y)),
    .keep = "unused"
  ) %>%
  
  # now add captureDate & group alt info
  merge(., capData_byIndiv_v5[, c("rowID", "animalName1", "animalName2", "captureDate", "groupName")], by = "rowID", all.x = T) %>%
  mutate(
    animalName_alt = case_when(
      is.na(animalName2) ~ animalName1,
      !is.na(animalName2) ~ str_c(animalName1, animalName2, sep = "/"),
      .default = NA
    )
  ) %>%
  select(-animalName1, -animalName2) %>%
  dplyr::rename(
    "captureDate" = "captureDate.x",
    "captureDate_alt" = "captureDate.y",
    "group_alt" = "groupName",
    "rowID_alt" = "rowID"
    ) %>%
  
  # add lm_350 alt info separately since has two alt animalIDs
  mutate(
    md_alt = case_when(
      sampleName == "lm_350" ~ "167_SIMP_M, 179_LWED_F",
      .default = md_alt
    ),
    animalName_alt = case_when(
      sampleName == "lm_350" ~ "RBG, LRC3/LPY",
      .default = animalName_alt
    ),
    captureDate_alt = case_when(
      sampleName == "lm_350" ~ "2016-06-28, 2017-06-09",
      .default = captureDate_alt
    ),
    group_alt = case_when(
      sampleName == "lm_350" ~ "Ji, Ghosts",
      .default = group_alt
    )
  ) %>%
  relocate(c(sampleID, md_original, animalID, animalName, sampleName, animalID_sampleName, captureDate, action, flagged_in, animalID_alt, animalName_alt, md_alt, group_alt, captureDate_alt, rowID_alt, notes_mdReconciliation)) %>%
  arrange(sampleID)

table(errorChecks_fullList_v1$action)

# export
write.csv(errorChecks_fullList_v1, "./metadataReconciliation/master_metadataReconciliation_actionList_v1.csv", row.names = F)
```

## 4.2 Confirm w/species/sex assignments

Confirm whether md should be updated by checking species & sex assignments

### Genotypes

Include GTscore polygen results for both 10x and 0x cutoffs

```{r}
genos_tamRun5_0x <- read.table("./05_tamRun5/03_run5GTscore/fullSet_polyGenResults_singleSNP_0x.txt", header = T) %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub('[_][^_]+$', '', locus)) %>%
  column_to_rownames("locus")

genos_tamRun5_10x <- read.table("./05_tamRun5/03_run5GTscore/fullSet_polyGenResults_singleSNP_10x.txt", header = T) %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub('[_][^_]+$', '', locus)) %>%
  column_to_rownames("locus")
```

### Species assignments

```{r}
source("./my_sourceScripts/assignSpecies.R")
speciesKey <- read.csv("./03_tamRun3/04_genoAnalyses/speciesSNP_key_14Dec2022.csv")
```

```{r}
# 10x cutoff
speciesCheck_tamRun5_10x <- assignSpecies(genos_tamRun5_10x, mdFile = md_tamRun5_v1, speciesKeyFile = speciesKey) %>%
  merge(., errorChecks_fullList_v1[, c("sampleID", "action", "md_original", "md_alt")], by = "sampleID", all.x = T) %>%
  relocate(c(action, md_original, md_alt), .after = sampleID) %>%
  filter(!is.na(md_alt)) %>%
  mutate(
    action_spCheck = case_when(
      
      str_detect(md_original, "LWED") & str_detect(md_alt, "SIMP") & spAssigned == "SIMP" ~ "update_toAlt",
      str_detect(md_original, "SIMP") & str_detect(md_alt, "LWED") & spAssigned == "LWED" ~ "update_toAlt",
      
      str_detect(md_original, "LWED") & str_detect(md_alt, "SIMP") & spAssigned == "LWED" ~ "keepOriginal",
      str_detect(md_original, "SIMP") & str_detect(md_alt, "LWED") & spAssigned == "SIMP" ~ "keepOriginal",
      
      str_detect(md_original, "LWED") & str_detect(md_alt, "LWED") & mdMatch == "TRUE" ~ "tbd",
      str_detect(md_original, "SIMP") & str_detect(md_alt, "SIMP") & mdMatch == "TRUE" ~ "tbd",
      
      .default = NA
    )
  ) %>%
  relocate(action_spCheck, .after = action) %>%
  # adjust action_spCheck for tamRun5.125 (suggests that the SIMP option is out, but still can't say whether to keep original or go with the LWED alt)
  mutate(
    action_spCheck = case_when(
      sampleID == "tamRun5.125" ~ "tbd",
      .default = action_spCheck
    )
  )

# 0x cutoff
speciesCheck_tamRun5_0x <- assignSpecies(genos_tamRun5_0x, mdFile = md_tamRun5_v1, speciesKeyFile = speciesKey) %>%
  merge(., errorChecks_fullList_v1[, c("sampleID", "action", "md_original", "md_alt")], by = "sampleID", all.x = T) %>%
  relocate(c(action, md_original, md_alt), .after = sampleID) %>%
  filter(!is.na(md_alt)) %>%
  mutate(
    action_spCheck = case_when(
      
      str_detect(md_original, "LWED") & str_detect(md_alt, "SIMP") & spAssigned == "SIMP" ~ "update_toAlt",
      str_detect(md_original, "SIMP") & str_detect(md_alt, "LWED") & spAssigned == "LWED" ~ "update_toAlt",
      
      str_detect(md_original, "LWED") & str_detect(md_alt, "SIMP") & spAssigned == "LWED" ~ "keepOriginal",
      str_detect(md_original, "SIMP") & str_detect(md_alt, "LWED") & spAssigned == "SIMP" ~ "keepOriginal",
      
      str_detect(md_original, "LWED") & str_detect(md_alt, "LWED") & mdMatch == "TRUE" ~ "tbd",
      str_detect(md_original, "SIMP") & str_detect(md_alt, "SIMP") & mdMatch == "TRUE" ~ "tbd",
      
      .default = NA
    )
  ) %>%
  relocate(action_spCheck, .after = action) %>%
  # adjust action_spCheck for tamRun5.125 (suggests that the SIMP option is out, but still can't say whether to keep original or go with the LWED alt)
  mutate(
    action_spCheck = case_when(
      sampleID == "tamRun5.125" ~ "tbd",
      .default = action_spCheck
    )
  )
```

#### 10x vs. 0x

All species assignments were the same b/t 10x and 0x cutoffs; no cases in which spAssignment occurred in one cutoff but not the other

```{r}
speciesCheck_tamRun5_10.0x <- speciesCheck_tamRun5_10x %>%
  select(sampleID, mdMatch) %>%
  merge(., speciesCheck_tamRun5_0x[, c("sampleID", "mdMatch")], by = "sampleID", all.x = T, all.y = T) %>%
  dplyr::rename("mdMatch_10x" = "mdMatch.x",
                "mdMatch_0x" = "mdMatch.y") %>%
  mutate(
    match10.0x = case_when(
      mdMatch_10x == mdMatch_0x ~ "yes",
      is.na(mdMatch_10x) | is.na(mdMatch_0x) ~ NA,
      .default = "no"
    )
  )
```

### Sex assignments

```{r}
source("./my_sourceScripts/assignSex.R")

primerList_v3 <- read.csv("./primers/03_lociChoices/tamGenetics_primerList_v3.csv")

sexKey <- read.csv("./03_tamRun3/04_genoAnalyses/sexSNP_key_8Dec2022.csv") %>%
  na.omit() %>%
  unique() %>%
  filter(Locus %in% primerList_v3$locus) %>%
  dplyr::rename("locus" = "Locus")
```

```{r}
# 10x cutoff
sexCheck_tamRun5_10x <- assignSex(genos_tamRun5_10x, mdFile = md_tamRun5_v1, sexKeyFile = sexKey) %>%
  merge(., errorChecks_fullList_v1[, c("sampleID", "action", "md_original", "md_alt")], by = "sampleID", all.x = T) %>%
  relocate(c(action, md_original, md_alt), .after = sampleID) %>%
  filter(!is.na(md_alt)) %>%
  mutate(
    action_sexCheck = case_when(
      
      str_detect(md_original, "_F") & str_detect(md_alt, "_M") & sexAssigned == "M" ~ "update_toAlt",
      str_detect(md_original, "_M") & str_detect(md_alt, "_F") & sexAssigned == "F" ~ "update_toAlt",
      
      str_detect(md_original, "_F") & str_detect(md_alt, "_M") & sexAssigned == "F" ~ "keepOriginal",
      str_detect(md_original, "_M") & str_detect(md_alt, "_F") & sexAssigned == "M" ~ "keepOriginal",
      
      str_detect(md_original, "_F") & str_detect(md_alt, "_F") & mdMatch == "TRUE" ~ "tbd",
      str_detect(md_original, "_M") & str_detect(md_alt, "_M") & mdMatch == "TRUE" ~ "tbd",
      
      # in some cases, neither original nor alt sex matches assignment
      str_detect(md_original, "_F") & str_detect(md_alt, "_F") & mdMatch == "FALSE" ~ "tbd_neitherMatch",
      str_detect(md_original, "_M") & str_detect(md_alt, "_M") & mdMatch == "FALSE" ~ "tbd_neitherMatch",
      
      .default = NA
    )
  ) %>%
  relocate(action_sexCheck, .after = action)

# 0x cutoff
sexCheck_tamRun5_0x <- assignSex(genos_tamRun5_0x, mdFile = md_tamRun5_v1, sexKeyFile = sexKey) %>%
  merge(., errorChecks_fullList_v1[, c("sampleID", "action", "md_original", "md_alt")], by = "sampleID", all.x = T) %>%
  relocate(c(action, md_original, md_alt), .after = sampleID) %>%
  filter(!is.na(md_alt)) %>%
  mutate(
    action_sexCheck = case_when(
      
      str_detect(md_original, "_F") & str_detect(md_alt, "_M") & sexAssigned == "M" ~ "update_toAlt",
      str_detect(md_original, "_M") & str_detect(md_alt, "_F") & sexAssigned == "F" ~ "update_toAlt",
      
      str_detect(md_original, "_F") & str_detect(md_alt, "_M") & sexAssigned == "F" ~ "keepOriginal",
      str_detect(md_original, "_M") & str_detect(md_alt, "_F") & sexAssigned == "M" ~ "keepOriginal",
      
      str_detect(md_original, "_F") & str_detect(md_alt, "_F") & mdMatch == "TRUE" ~ "tbd",
      str_detect(md_original, "_M") & str_detect(md_alt, "_M") & mdMatch == "TRUE" ~ "tbd",
      
      # in some cases, neither original nor alt sex matches assignment
      str_detect(md_original, "_F") & str_detect(md_alt, "_F") & mdMatch == "FALSE" ~ "tbd_neitherMatch",
      str_detect(md_original, "_M") & str_detect(md_alt, "_M") & mdMatch == "FALSE" ~ "tbd_neitherMatch",
      
      .default = NA
    )
  ) %>%
  relocate(action_sexCheck, .after = action)
```

#### 10x vs. 0x

All sex assignments were the same b/t 10x and 0x cutoffs EXCEPT for sampleID tamRun5.060; 10x had TRUE while 0x had FALSE - this is b/c 060 had one more sex geno assigned (5 assigned vs. 4), and that extra assignment was F, resulting in a "MIX" of sex assignments.

There were also two samples that had sexAssignments w/0x but not w/10x:
-   tamRun5.305; mdMatch = TRUE; both options are LWED_M so doesn't matter
-   tamRun5.374; mdMatch = FALSE; both options are LWED_M but go MIX

```{r}
sexCheck_tamRun5_10.0x <- sexCheck_tamRun5_10x %>%
  select(sampleID, mdMatch) %>%
  merge(., sexCheck_tamRun5_0x[, c("sampleID", "mdMatch")], by = "sampleID", all.x = T, all.y = T) %>%
  dplyr::rename("mdMatch_10x" = "mdMatch.x",
                "mdMatch_0x" = "mdMatch.y") %>%
  mutate(
    match10.0x = case_when(
      mdMatch_10x == mdMatch_0x ~ "yes",
      is.na(mdMatch_10x) | is.na(mdMatch_0x) ~ NA,
      .default = "no"
    )
  )
```

### Combine results

Can just go w/0x cutoff results here

```{r}
# 10x cutoff
spSexChecks_tamRun5_0x <- speciesCheck_tamRun5_0x %>%
  select(sampleID, action, md_original, md_alt, action_spCheck) %>%
  merge(., sexCheck_tamRun5_0x[, c("sampleID", "action_sexCheck")], by = "sampleID", all = T) %>%
  mutate(
    action_spSexChecks = case_when(
      
      # change lm_350/tamRun5.125 to tbd b/c one of the two options is LWED_F
      sampleID == "tamRun5.125" ~ "tbd_sexMismatch",
      
      action_spCheck == "update_toAlt" & action_sexCheck == "update_toAlt" ~ "update_toAlt",
      action_spCheck == "keepOriginal" & action_sexCheck == "keepOriginal" ~ "keepOriginal",
      
      action_spCheck == "tbd" & action_sexCheck == "update_toAlt" ~ "update_toAlt",
      action_spCheck == "update_toAlt" & action_sexCheck == "tbd" ~ "update_toAlt",
      
      action_spCheck == "tbd" & action_sexCheck == "keepOriginal" ~ "keepOriginal",
      action_spCheck == "keepOriginal" & action_sexCheck == "tbd" ~ "keepOriginal",
      
      # there were a few cases where neither md's sex matched assignment
      action_spCheck == "update_toAlt" & action_sexCheck == "tbd_neitherMatch" ~ "update_toAlt_sexMismatch",
      action_spCheck == "keepOriginal" & action_sexCheck == "tbd_neitherMatch" ~ "keepOriginal_sexMismatch",
      
      .default = "tbd"
    )
  )
```

## 4.3 Update errorChecks_fullList_v2

After spcies/sex checks, we end up with the following final actions regarding changes to md:

n = 28 keep original md n = 1 keep original md, but sex assignment matches neither original nor alt md

n = 5 update to alt md n = 1 update to alt md, but sex assignment matches neither original nor alt md

n = 8 tbd (pending relatedness analyses) n = 1 tbd where species assignment suggests keepOriginal, but sex assignment matches neither original nor alt (this is lm_350, which has two possible alts - one SIMP_M and one LWED_F; spAssigment suggests LWED, but sexAssignment says M)

**TOTAL UPDATED: 6** **TOTAL KEPT: 28** **TOTAL TBD: 9**

Samples that are TBD are usually bc the two options have the same species and sex; the only other case is tamRun5.125 (lm_350), which has two potential alts, but species/sex assignments don't clear anything up.

```{r}
errorChecks_fullList_v2 <- errorChecks_fullList_v1 %>%
  merge(., spSexChecks_tamRun5_0x[, c("sampleID", "action_spSexChecks")], by = "sampleID", all.x = T) %>%
  mutate(
    action_final = case_when(
      
      action == action_spSexChecks ~ action,
      
      action == "tbd" & action_spSexChecks == "update_toAlt" ~ "update_toAlt",
      action == "tbd" & action_spSexChecks == "keepOriginal" ~ "keepOriginal",
      
      # for cases where had sex mismatch
      str_detect(action_spSexChecks, "sexMismatch") ~ action_spSexChecks,
      
      # for errorChecks1 where no alt md was available
      action == "keepOriginal" & flagged_in == "errorChecks1" ~ action,
      
      .default = "tbd"
    )
  ) %>%
  relocate(c(action_spSexChecks, action_final), .after = action)

table(errorChecks_fullList_v2$action_final)

# export
write.csv(errorChecks_fullList_v2, "./metadataReconciliation/master_metadataReconciliation_actionList_v2.csv", row.names = F)
```

## 4.4 Update md_tamRun5_v2

```{r}
md_tamRun5_v2 <- md_tamRun5_v1 %>%
  select(sampleID, animalID, animalName, species, sex, group, captureDate, fieldNotes) %>%
  merge(., errorChecks_fullList_v2[, c("sampleID", "action_final", "md_original", "rowID_alt", "md_alt", "animalName_alt", "group_alt", "captureDate_alt")], by = "sampleID", all.x = T) %>%
  separate("md_alt", into = c("animalID_alt", "species_alt", "sex_alt"), sep = "_") %>%
  # adjust cols for lm_350
  mutate(
    animalID_alt = case_when(
      sampleID == "tamRun5.125" ~ "167.179",
      .default = animalID_alt
    ),
    species_alt = case_when(
      sampleID == "tamRun5.125" ~ "SIMP.LWED",
      .default = species_alt
    ),
    sex_alt = case_when(
      sampleID == "tamRun5.125" ~ "M.F",
      .default = sex_alt
    )
  ) %>%
  mutate(
    animalID = case_when(
      str_detect(action_final, "update_toAlt") ~ animalID_alt,
      .default = animalID
    ),
    animalName = case_when(
      str_detect(action_final, "update_toAlt") ~ animalName_alt,
      .default = animalName
    ),
    species = case_when(
      str_detect(action_final, "update_toAlt") ~ species_alt,
      .default = species
    ),
    sex = case_when(
      str_detect(action_final, "update_toAlt") ~ sex_alt,
      .default = sex
    ),
    group = case_when(
      str_detect(action_final, "update_toAlt") ~ group_alt,
      .default = group
    ),
    captureDate = case_when(
      str_detect(action_final, "update_toAlt") ~ as.character(captureDate_alt),
      .default = as.character(captureDate)
    ),
    fieldNotes = case_when(
      str_detect(action_final, "update_toAlt") ~ NA,
      .default = fieldNotes
    )
  ) %>%
  relocate(animalName, .before = group) %>%
  mutate(
    md_alt = str_c(rowID_alt, animalID_alt, species_alt, sex_alt, animalName_alt, group_alt, captureDate_alt, sep = "_"),
    md_alt = str_c("rowID", md_alt)
         ) %>%
  select(-c(rowID_alt, animalID_alt, species_alt, sex_alt, animalName_alt, group_alt, captureDate_alt)) %>%
  
  # add other md back in
  merge(., md_tamRun5_v1[c("sampleID",
                                 "sampleFile",
                                 "i5_index",
                                 "i7_index",
                                 "well",
                                 "sampleName",
                                 "sampleType",
                                 "sampleNotes",
                                 "lysisDate",
                                 "lysisType",
                                 "lysisLoc",
                                 "lysisRow",
                                 "lysisCol",
                                 "lysisVol_ul",
                                 "lysisDuration",
                                 "lysis_prokProp",
                                 "lysisProtocol",
                                 "lysisNotes",
                                 "xtnDate",
                                 "xtnYear",
                                 "xtnType",
                                 "xtnLoc",
                                 "eltn",
                                 "xtnRow",
                                 "xtnCol",
                                 "xtnProtocol",
                                 "xtnNotes",
                                 "qubit_ng.ul",
                                 "qubitDate",
                                 "pico_ng.ul",
                                 "picoDate",
                                 "purity_260.280",
                                 "purity_260.230",
                                 "purityDate")], by = "sampleID") %>%
  dplyr::rename("mdAction_final" = "action_final")
```

Export

```{r}
write.csv(md_tamRun5_v2, "./metadataReconciliation/tamRun5_metadata_v2.csv", row.names = F)
```

# 5 Check groupNames

## 5.1 Data

```{r}
# load in updated md from above
md_tamRun5_v2 <- read.csv("./metadataReconciliation/tamRun5_metadata_v2.csv")

# group key from google sheet
groupKey <- read.csv("./paper3_demographics/01_dataOrganization/02_dataCleaning/tamGenetics_demographics_dataCleaning _groupKey.csv")
```

## 5.2 errorChecks4

There are a total of n = 7 sampleIDs with group names that don't match the associated animalID/captureDate combo from capData_byIndiv.

Two sampleIDs (tamRun5.396 & tamRun5.399) were just missing their groupName (animalName was entered instead of group); all of the others are related to the duplicate hair envelope sampleNames, where in some cases the captureDate on the enveloped appeared to be swapped despite the rest of the metadata matching capture records.

```{r}
errorChecks4_groupNames_mismatch <- md_tamRun5_v2 %>%
  # filter to blood/hair samples only
  filter(sampleType %in% c("blood", "hair")) %>%
  select(sampleID, captureDate, animalID, animalName, group) %>%
  merge(., capData_byIndiv_v5[, c("rowID", "captureDate", "animalID", "groupName")], by = c("captureDate", "animalID"), all.x = T) %>%
  mutate(
    match = case_when(
      group == groupName ~ "yes",
      .default = "no"
    )
  ) %>%
  filter(match == "no") %>%
  arrange(sampleID)

errorChecks4_groupNames_mismatch
```

Of these 7 total sampleIDs, n = 4 are already in the errorChecks_fullList_v2

```{r}
errorChecks4_actionList <-  errorChecks4_groupNames_mismatch %>%
  select(sampleID, captureDate, animalID, animalName) %>%
  filter(sampleID %in% errorChecks4_groupNames_mismatch$sampleID) %>%
  mutate(
    notes_mdReconciliation = case_when(
      sampleID == "tamRun5.146" ~ "[captureDate notes: animalID 535 is the SAME as 234; update animalID to 234 and re-check]",
      sampleID == "tamRun5.200" ~ "[captureDate notes: animalID 535 is the SAME as 234; update animalID to 234 and re-check]",
      sampleID == "tamRun5.234" ~ "[captureDate notes: sampleNotes say 'date switched? Envelope says 6/15/17; assumming animalID is correct, should update captureDate to 6/27/17]",
      sampleID == "tamRun5.261" ~ "[captureDate notes: sampleNotes say 'date switched? envelope has 6/27/17 for date, though other 301 envelope has the 6/15/17 date'...but this env is env_294 (maybe doesn't matter, env_294 also has a 6/15 and 6/27/17 versions, maybe just a copy/paste issue; assumming animalID is correct, should update captureDate to 6/27/17]",
      sampleID == "tamRun5.278" ~ "[captureDate notes: sampleNotes say 'date switched? Envelope says 6/22/17; assumming animalID is correct, should update captureDate to 6/22/17]",
      sampleID == "tamRun5.396" ~ "[captureDate notes: groupName not previously listed; update to WhiteSf]",
      sampleID == "tamRun5.399" ~ "[captureDate notes: groupName not previously listed; update to WhiteSf]",
      .default = NA
    ),
    action_final = case_when(
        sampleID %in% c("tamRun5.396", "tamRun5.399") ~ "update_groupName",
        as.character(animalID) == "535" ~ "update_animalID",
        .default = "update_captureDate"
        ),
      flagged_in = "errorChecks4"
  )
```

## 5.3 Update errorChecks_fullList_v3

```{r}
errorChecks_fullList_v3 <- errorChecks_fullList_v2 %>%
  merge(., errorChecks4_actionList, by = "sampleID", all = T) %>%
  mutate(
    animalID = coalesce(animalID.x, animalID.y),
    .keep = "unused"
  ) %>%
  relocate(animalID, .after = sampleID) %>%
  
  mutate(
    animalName = coalesce(animalName.x, animalName.y),
    .keep = "unused"
  ) %>%
  relocate(animalName, .after = animalID) %>%
  
  mutate(
    captureDate = coalesce(as.character(captureDate.x), as.character(captureDate.y)),
    .keep = "unused"
  ) %>%
  relocate(captureDate, .before = action) %>%
  
  mutate(
    action_final = case_when(
      is.na(action_final.x) ~ action_final.y,
      is.na(action_final.y) ~ action_final.x,
      .default = str_c(action_final.x, "; ", action_final.y)
    )
  ) %>%
  relocate(action_final, .after = action_spSexChecks) %>%
  
  mutate(
    flagged_in = case_when(
      is.na(flagged_in.x) ~ flagged_in.y,
      is.na(flagged_in.y) ~ flagged_in.x,
      .default = str_c(flagged_in.x, "; ", flagged_in.y)
    )
  ) %>%
  relocate(flagged_in, .after = action_final) %>%
  
  mutate(
    notes_mdReconciliation = case_when(
      is.na(notes_mdReconciliation.x) ~ notes_mdReconciliation.y,
      is.na(notes_mdReconciliation.y) ~ notes_mdReconciliation.x,
      .default = str_c(notes_mdReconciliation.x, "; ", notes_mdReconciliation.y)
    )
  ) %>%
  relocate(notes_mdReconciliation, .after = rowID_alt) %>%
  select(!contains(".x")) %>%
  select(!contains(".y"))

# export
write.csv(errorChecks_fullList_v3, "./metadataReconciliation/master_metadataReconciliation_actionList_v3.csv", row.names = F)
```

## 5.4 Update md_tamRun5_v3

```{r}
md_tamRun5_v3 <- md_tamRun5_v2 %>%
  merge(., errorChecks4_actionList[, c("sampleID", "action_final")], by = "sampleID", all.x = T) %>%
  mutate(
    mdAction_final = case_when(
      is.na(mdAction_final) & !is.na(action_final) ~ action_final,
      !is.na(mdAction_final) & is.na(action_final) ~ mdAction_final,
      .default = str_c(mdAction_final, "; ", action_final)
    )
  ) %>%
  # update animalID 535 to 234
  mutate(
    animalID = case_when(
      as.character(animalID) == "535" ~ "234",
      .default = as.character(animalID)
    )
  ) %>%
  # update captureDates
  mutate(
    captureDate = case_when(
      sampleID == "tamRun5.234" ~ "2017-06-27",
      sampleID == "tamRun5.261" ~ "2017-06-27",
      sampleID == "tamRun5.278" ~ "2017-06-22",
      .default = captureDate
    )
  ) %>%
  # update groupName
  mutate(
    group = case_when(
      sampleID %in% c("tamRun5.396", "tamRun5.399") ~ "WhiteSf",
      .default = group
    )
  ) %>%
  # add in notes_mdReconciliation
  merge(., errorChecks_fullList_v3[, c("sampleID", "notes_mdReconciliation")], by = "sampleID", all.x = T) %>%
  relocate(notes_mdReconciliation, .after = md_alt) %>%
  # remove action_final
  select(-action_final)
```

Ensure no other animalID/captureDate combos return incorrect groupName - success!

```{r}
md_tamRun5_v3 %>%
  # filter to blood/hair samples only
  filter(sampleType %in% c("blood", "hair")) %>%
  select(sampleID, captureDate, animalID, animalName, group) %>%
  merge(., capData_byIndiv_v5[, c("rowID", "captureDate", "animalID", "groupName")], by = c("captureDate", "animalID"), all.x = T) %>%
  mutate(
    match = case_when(
      group == groupName ~ "yes",
      .default = "no"
    )
  ) %>%
  filter(match == "no") %>%
  arrange(sampleID)
```

Export md_tamRun5_v3

```{r}
write.csv(md_tamRun5_v3, "./metadataReconciliation/tamRun5_metadata_v3.csv", row.names = F)
```

# 6 Duptest

Next step is to run the GTscore duptest to see if that can 1) confirm actions for samples marked as "update_toAlt" and "keepOriginal", 2) resolve actions for samples marked as "tbd", and 3) flag any additional samples that pop up as likely dups but have different animalIDs.

## 6.1 Data

### GTscore.R

```{r}
source("./GTscore_sourceScripts/GTscore_modified.R") # NOTE- added N=ATGC to script for later analyses (not included in original)
```

### md_tamRun5_v3

```{r}
md_tamRun5_v3 <- read.csv("./metadataReconciliation/tamRun5_metadata_v3.csv")
```

### Polygen results

First step is to run polygen so that the polygen results are in this Rmd environment and can be used as input for the duptest

**0x cutoff**

```{r}
#load locus table and 0x allele reads file
fullSet_singleSNP_locusTable <- read.delim("./05_tamRun5/03_run5GTscore/fullSet_LocusTable_singleSNPs.txt", header = TRUE, stringsAsFactors = FALSE)

fullSet_singleSNP_alleleReads_0x <- read.delim("./05_tamRun5/03_run5GTscore/fullSet_AlleleReads_singleSNPs.txt", header = TRUE, row.names = 1, stringsAsFactors = FALSE)

#generate singleSNP genotypes using the polyGen algorithm, adjust "0" formatting
fullSet_polyGenResults_singleSNP_0x <- polyGen(fullSet_singleSNP_locusTable, fullSet_singleSNP_alleleReads_0x)
```

**10x cutoff**

```{r}
#load locus table and 10x allele reads file
fullSet_singleSNP_locusTable <- read.delim("./05_tamRun5/03_run5GTscore/fullSet_LocusTable_singleSNPs.txt", header = TRUE, stringsAsFactors = FALSE)

fullSet_singleSNP_alleleReads_10x <- read.delim("./05_tamRun5/03_run5GTscore/fullSet_AlleleReads_singleSNPs_10x.txt", header = TRUE, row.names = 1, stringsAsFactors = FALSE)

#generate singleSNP genotypes using the polyGen algorithm, adjust "0" formatting
fullSet_polyGenResults_singleSNP_10x <- polyGen(fullSet_singleSNP_locusTable, fullSet_singleSNP_alleleReads_10x)
```

### GTscore duptest

## 6.2 Run duptest

Then can run duptest

**0x cutoff**

```{r identify duplicate samples,eval=FALSE}
#convert missing genotypes "0" to NA
polyGenResults_0x_NA <- fullSet_polyGenResults_singleSNP_0x
polyGenResults_0x_NA[polyGenResults_0x_NA == "0"] <- NA

#compare all samples, for each comparison get proportion of loci that have genotypes
#in both samples (proportionCommon) and proportion of shared loci that have identical
#genotypes (proportionMatch).
#Samples with a high proportionCommon and high proportionMatch are likely duplicates
polyGenResults_0x_dupTest <- IDduplicateSamples(polyGenResults_0x_NA)
```

```{r duplicate sample results}
write.table(polyGenResults_0x_dupTest,"./metadataReconciliation/dupTest_polyGenResults_0x.txt", quote = FALSE, sep = "\t", row.names = FALSE)

# polyGenResults_dupTest<-read.delim("./05_tamRun5/03_run5GTscore/run5_polyGenResults_dupTest.txt",stringsAsFactors=FALSE)
# head(polyGenResults_dupTest)
```

**10x cutoff**

```{r identify duplicate samples,eval=FALSE}
#convert missing genotypes "0" to NA
polyGenResults_10x_NA <- fullSet_polyGenResults_singleSNP_10x
polyGenResults_10x_NA[polyGenResults_10x_NA == "0"] <- NA

#compare all samples, for each comparison get proportion of loci that have genotypes
#in both samples (proportionCommon) and proportion of shared loci that have identical
#genotypes (proportionMatch).
#Samples with a high proportionCommon and high proportionMatch are likely duplicates
polyGenResults_10x_dupTest <- IDduplicateSamples(polyGenResults_10x_NA)
```

```{r duplicate sample results}
write.table(polyGenResults_10x_dupTest,"./metadataReconciliation/dupTest_polyGenResults_10x.txt", quote = FALSE, sep = "\t", row.names = FALSE)

# polyGenResults_dupTest<-read.delim("./05_tamRun5/03_run5GTscore/run5_polyGenResults_dupTest.txt",stringsAsFactors=FALSE)
# head(polyGenResults_dupTest)
```

## 6.3 Plots

Plot results of IDduplicateSamples

McKinney says that he generally sets thresholds of proportionMatch \> 0.8 and proportionCommon \> 0.75 to identify duplicate sample pairs, but the appropriate thresholds will depend on the marker set being used and the relatedness among samples. In this plot, he notes that it is possible that individuals at the lower range of identical genotypes (\~0.85) are relatives rather than duplicated samples.

```{r plot IDduplicateSamples results}
#potential duplicates are proportionMatch>0.8 and proportionCommon>0.75
#feel free to adjust these thresholds as needed
matchThresh = 0.8
commonThresh = 0.56 # species-specific loci mean that total loci = 154 for both LWED & SIMP sets (which is already 0.74 of 208 total loci); setting threshold instead to 0.56 (0.75*154 = 115.5; 115.5/208 = 0.56)

# 0x plot
ggplot() +
  geom_point(data = polyGenResults_0x_dupTest,
             aes(x = proportionCommon, y = proportionMatch)) +
  geom_segment(aes(x = commonThresh, xend = 1, y = matchThresh, yend = matchThresh), lty = "dashed") +
  geom_segment(aes(x = commonThresh, xend = commonThresh, y = matchThresh, yend = 1), lty = "dashed")

## 10x plot
ggplot() +
  geom_point(data = polyGenResults_10x_dupTest,
             aes(x = proportionCommon, y = proportionMatch)) +
  geom_segment(aes(x = commonThresh, xend = 1, y = matchThresh, yend = matchThresh), lty = "dashed") +
  geom_segment(aes(x = commonThresh, xend = commonThresh, y = matchThresh, yend = 1), lty = "dashed")
```

## 6.4 Assess dups

### likely dups

Going to identify duplicate sample pairs with matchThresh >= 0.8 (same as before) but a lower commonThresh; choosing commonGenotypes >= 50 (vs. commonThresh = 0.56). From there, going to see how many duplicate pairs are ones that we expect (i.e., same animalID - either blood/hair pair or accidental duplicate due to metadata issues addressed earlier in this document).

I want to go through the ones with different animalIDs and address any whose mdAction_final was set to "tbd", or perhaps set to "update_toAlt" and shouldn't have been.

**Full set**

0x cutoff genos: - n = 184 duplicate pairs total - n = 94 w/same animalID - n = 90 w/different animalID

10x cutoff genos: - n = 199 duplicate pairs total - n = 120 w/same animalID - n = 79 w/different animalID

```{r}
# n = 184 dup pairs for 0x
likelyDups_0x <- polyGenResults_0x_dupTest %>%
  filter(proportionMatch >= 0.8,
         commonGenotypes >= 50) %>%
  merge(., md_tamRun5_v3[, c("sampleID", "sampleType", "animalID", "md_alt", "mdAction_final", "md_original", "notes_mdReconciliation")], by.x = "Sample1", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType1" = "sampleType",
                "animalID1" = "animalID",
                "md_alt1" = "md_alt",
                "mdAction_final1" = "mdAction_final",
                "md_original1" = "md_original",
                "notes_mdReconciliation1" = "notes_mdReconciliation") %>%
  merge(., md_tamRun5_v3[, c("sampleID", "sampleType", "animalID", "md_alt", "mdAction_final", "md_original", "notes_mdReconciliation")], by.x = "Sample2", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType2" = "sampleType",
                "animalID2" = "animalID",
                "md_alt2" = "md_alt",
                "mdAction_final2" = "mdAction_final",
                "md_original2" = "md_original",
                "notes_mdReconciliation2" = "notes_mdReconciliation") %>%
  relocate(sampleType2, .after = sampleType1) %>%
  relocate(animalID2, .after = animalID1) %>%
  relocate(md_alt2, .after = md_alt1) %>%
  relocate(mdAction_final2, .after = mdAction_final1) %>%
  relocate(md_original2, .after = md_original1) %>%
  relocate(notes_mdReconciliation2, .after = notes_mdReconciliation1) %>%
  mutate(
    animalID_match = case_when(
      animalID1 == animalID2 ~ "yes",
      .default = "no"
    )
  ) %>%
  relocate(animalID_match, .after = animalID2) %>%
  relocate(Sample1)

# n = 199 dup pairs for 10x
likelyDups_10x <- polyGenResults_10x_dupTest %>%
  filter(proportionMatch >= 0.8,
         commonGenotypes >= 50) %>%
  merge(., md_tamRun5_v3[, c("sampleID", "sampleType", "animalID", "md_alt", "mdAction_final", "md_original", "notes_mdReconciliation")], by.x = "Sample1", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType1" = "sampleType",
                "animalID1" = "animalID",
                "md_alt1" = "md_alt",
                "mdAction_final1" = "mdAction_final",
                "md_original1" = "md_original",
                "notes_mdReconciliation1" = "notes_mdReconciliation") %>%
  merge(., md_tamRun5_v3[, c("sampleID", "sampleType", "animalID", "md_alt", "mdAction_final", "md_original", "notes_mdReconciliation")], by.x = "Sample2", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType2" = "sampleType",
                "animalID2" = "animalID",
                "md_alt2" = "md_alt",
                "mdAction_final2" = "mdAction_final",
                "md_original2" = "md_original",
                "notes_mdReconciliation2" = "notes_mdReconciliation") %>%
  relocate(sampleType2, .after = sampleType1) %>%
  relocate(animalID2, .after = animalID1) %>%
  relocate(md_alt2, .after = md_alt1) %>%
  relocate(mdAction_final2, .after = mdAction_final1) %>%
  relocate(md_original2, .after = md_original1) %>%
  relocate(notes_mdReconciliation2, .after = notes_mdReconciliation1) %>%
  mutate(
    animalID_match = case_when(
      animalID1 == animalID2 ~ "yes",
      .default = "no"
    )
  ) %>%
  relocate(animalID_match, .after = animalID2) %>%
  relocate(Sample1)

# tables
table(likelyDups_0x$animalID_match)
table(likelyDups_10x$animalID_match)
```

### matchCompare

**0x cutoff**

```{r}
# create df of dups w/highest propMatch PER SAMPLEID
## ensure df arranged properly
temp1 <- likelyDups_0x %>%
  dplyr::rename("Sample1" = "Sample2",
                "Sample2" = "Sample1") %>%
  relocate(Sample1)

temp2 <- rbind(likelyDups_0x, temp1) %>%
  arrange(Sample1, desc(proportionMatch))

## extract pairs w/highest match
likelyDups_0x_highest <- temp2[match(unique(temp2$Sample1), temp2$Sample1),]

# temp dfs for hair and blood samples
temp1 <- md_tamRun5_v3 %>%
  select(sampleID, animalID, sampleType) %>%
  mutate(
    pairTo = case_when(
      sampleType == "blood" ~ "hair",
      sampleType == "hair" ~ "blood"
    )
  )

# create comparison dataframe
matchCompare_0x <- md_tamRun5_v3 %>%
  select(sampleID, animalID, sampleType) %>%
  filter(sampleType %in% c("blood", "hair")) %>%
  merge(., temp1, by.x = c("animalID", "sampleType"), by.y = c("animalID", "pairTo"), all.x = T) %>%
  dplyr::rename("sampleID_base" = "sampleID.x",
                "animalID_base" = "animalID",
                "sampleID_typeMatch" = "sampleID.y",
                "sampleType_base" = "sampleType",
                "sampleType_typeMatch" = "sampleType.y"
                ) %>%
  
  # first add type match
  merge(., polyGenResults_0x_dupTest[, c("Sample1", "Sample2", "commonGenotypes", "proportionMatch")], by.x = c("sampleID_base", "sampleID_typeMatch"), by.y = c("Sample1", "Sample2"), all.x = T) %>%
  merge(., polyGenResults_0x_dupTest[, c("Sample1", "Sample2", "commonGenotypes", "proportionMatch")], by.x = c("sampleID_base", "sampleID_typeMatch"), by.y = c("Sample2", "Sample1"), all.x = T) %>%
  mutate(
    commonGenotypes = coalesce(commonGenotypes.x, commonGenotypes.y),
    .keep = "unused"
  ) %>%
  mutate(
    proportionMatch = coalesce(proportionMatch.x, proportionMatch.y),
    .keep = "unused"
  ) %>%
  dplyr::rename("common_typeMatch" = "commonGenotypes",
                "propMatch_typeMatch" = "proportionMatch") %>%
  
  # now add top match (when available)
  merge(., likelyDups_0x_highest[, c("Sample1", "Sample2", "commonGenotypes", "proportionMatch", "animalID2")], by.x = "sampleID_base", by.y = "Sample1", all.x = T) %>%
  dplyr::rename("sampleID_topMatch" = "Sample2",
                "animalID_topMatch" = "animalID2",
                "common_topMatch" = "commonGenotypes",
                "propMatch_topMatch" = "proportionMatch") %>%
  merge(., temp1[, c("sampleID", "sampleType")], by.x = "sampleID_topMatch", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType_topMatch" = "sampleType") %>%
  
  mutate(
    baseTop_match = case_when(
      is.na(animalID_topMatch) ~ NA,
      animalID_base == animalID_topMatch ~ "yes",
      .default = "no"
    )
  ) %>%
  
  # add errorChecks
  merge(., errorChecks_fullList_v3[, c("sampleID", "action_final", "md_original", "md_alt", "notes_mdReconciliation")], by.x = "sampleID_base", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("actionFinal_base" = "action_final",
                "mdOrig_base" = "md_original",
                "mdAlt_base" = "md_alt",
                "notes_base" = "notes_mdReconciliation") %>%
  merge(., errorChecks_fullList_v3[, c("sampleID", "action_final", "md_original", "md_alt", "notes_mdReconciliation")], by.x = "sampleID_typeMatch", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("actionFinal_typeMatch" = "action_final",
                "mdOrig_typeMatch" = "md_original",
                "mdAlt_typeMatch" = "md_alt",
                "notes_typeMatch" = "notes_mdReconciliation") %>%
  merge(., errorChecks_fullList_v3[, c("sampleID", "action_final", "md_original", "md_alt", "notes_mdReconciliation")], by.x = "sampleID_topMatch", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("actionFinal_topMatch" = "action_final",
                "mdOrig_topMatch" = "md_original",
                "mdAlt_topMatch" = "md_alt",
                "notes_topMatch" = "notes_mdReconciliation") %>%
  
  relocate(c("sampleID_base",
             "sampleID_typeMatch",
             "sampleID_topMatch",
             
             "sampleType_base",
             "sampleType_typeMatch",
             "sampleType_topMatch",
             
             "animalID_base",
             "animalID_topMatch",
             "baseTop_match",
             
             "propMatch_typeMatch",
             "propMatch_topMatch",
             "common_typeMatch",
             "common_topMatch",
             
             "actionFinal_base",
             "mdOrig_base",
             "mdAlt_base",
             "notes_base",
             
             "actionFinal_typeMatch",
             "mdOrig_typeMatch",
             "mdAlt_typeMatch",
             "notes_typeMatch",
             
             "actionFinal_topMatch",
             "mdOrig_topMatch",
             "mdAlt_topMatch",
             "notes_topMatch"))
```

**10x cutoff**

```{r}
# create df of dups w/highest propMatch
## ensure df arranged properly
temp1 <- likelyDups_10x %>%
  dplyr::rename("Sample1" = "Sample2",
                "Sample2" = "Sample1") %>%
  relocate(Sample1)

temp2 <- rbind(likelyDups_10x, temp1) %>%
  arrange(Sample1, desc(proportionMatch))

## extract pairs w/highest match
likelyDups_10x_highest <- temp2[match(unique(temp2$Sample1), temp2$Sample1),]

# temp dfs for hair and blood samples
temp1 <- md_tamRun5_v3 %>%
  select(sampleID, animalID, sampleType) %>%
  mutate(
    pairTo = case_when(
      sampleType == "blood" ~ "hair",
      sampleType == "hair" ~ "blood"
    )
  )

# create comparison dataframe
matchCompare_10x <- md_tamRun5_v3 %>%
  select(sampleID, animalID, sampleType) %>%
  filter(sampleType %in% c("blood", "hair")) %>%
  merge(., temp1, by.x = c("animalID", "sampleType"), by.y = c("animalID", "pairTo"), all.x = T) %>%
  dplyr::rename("sampleID_base" = "sampleID.x",
                "animalID_base" = "animalID",
                "sampleID_typeMatch" = "sampleID.y",
                "sampleType_base" = "sampleType",
                "sampleType_typeMatch" = "sampleType.y"
                ) %>%
  
  # first add type match
  merge(., polyGenResults_10x_dupTest[, c("Sample1", "Sample2", "commonGenotypes", "proportionMatch")], by.x = c("sampleID_base", "sampleID_typeMatch"), by.y = c("Sample1", "Sample2"), all.x = T) %>%
  merge(., polyGenResults_10x_dupTest[, c("Sample1", "Sample2", "commonGenotypes", "proportionMatch")], by.x = c("sampleID_base", "sampleID_typeMatch"), by.y = c("Sample2", "Sample1"), all.x = T) %>%
  mutate(
    commonGenotypes = coalesce(commonGenotypes.x, commonGenotypes.y),
    .keep = "unused"
  ) %>%
  mutate(
    proportionMatch = coalesce(proportionMatch.x, proportionMatch.y),
    .keep = "unused"
  ) %>%
  dplyr::rename("common_typeMatch" = "commonGenotypes",
                "propMatch_typeMatch" = "proportionMatch") %>%
  
  # now add top match (when available)
  merge(., likelyDups_10x_highest[, c("Sample1", "Sample2", "commonGenotypes", "proportionMatch", "animalID2")], by.x = "sampleID_base", by.y = "Sample1", all.x = T) %>%
  dplyr::rename("sampleID_topMatch" = "Sample2",
                "animalID_topMatch" = "animalID2",
                "common_topMatch" = "commonGenotypes",
                "propMatch_topMatch" = "proportionMatch") %>%
  merge(., temp1[, c("sampleID", "sampleType")], by.x = "sampleID_topMatch", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType_topMatch" = "sampleType") %>%
  
  mutate(
    baseTop_match = case_when(
      is.na(animalID_topMatch) ~ NA,
      animalID_base == animalID_topMatch ~ "yes",
      .default = "no"
    )
  ) %>%
  
  # add errorChecks
  merge(., errorChecks_fullList_v3[, c("sampleID", "action_final", "md_original", "md_alt", "notes_mdReconciliation")], by.x = "sampleID_base", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("actionFinal_base" = "action_final",
                "mdOrig_base" = "md_original",
                "mdAlt_base" = "md_alt",
                "notes_base" = "notes_mdReconciliation") %>%
  merge(., errorChecks_fullList_v3[, c("sampleID", "action_final", "md_original", "md_alt", "notes_mdReconciliation")], by.x = "sampleID_typeMatch", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("actionFinal_typeMatch" = "action_final",
                "mdOrig_typeMatch" = "md_original",
                "mdAlt_typeMatch" = "md_alt",
                "notes_typeMatch" = "notes_mdReconciliation") %>%
  merge(., errorChecks_fullList_v3[, c("sampleID", "action_final", "md_original", "md_alt", "notes_mdReconciliation")], by.x = "sampleID_topMatch", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("actionFinal_topMatch" = "action_final",
                "mdOrig_topMatch" = "md_original",
                "mdAlt_topMatch" = "md_alt",
                "notes_topMatch" = "notes_mdReconciliation") %>%
  
  relocate(c("sampleID_base",
             "sampleID_typeMatch",
             "sampleID_topMatch",
             
             "sampleType_base",
             "sampleType_typeMatch",
             "sampleType_topMatch",
             
             "animalID_base",
             "animalID_topMatch",
             "baseTop_match",
             
             "propMatch_typeMatch",
             "propMatch_topMatch",
             "common_typeMatch",
             "common_topMatch",
             
             "actionFinal_base",
             "mdOrig_base",
             "mdAlt_base",
             "notes_base",
             
             "actionFinal_typeMatch",
             "mdOrig_typeMatch",
             "mdAlt_typeMatch",
             "notes_typeMatch",
             
             "actionFinal_topMatch",
             "mdOrig_topMatch",
             "mdAlt_topMatch",
             "notes_topMatch"))
```

## 6.5 errorChecks5 - Address tbd

### Resolve action_final = tbd

There are 9 samples with action_final = tbd; duptest results should hopefully help resolve these

```{r}
tbdAction_list <- errorChecks_fullList_v3 %>%
  filter(str_detect(action_final, "(?i)tbd"))

polyGenResults_0x_dupTest_animalIDs <- polyGenResults_0x_dupTest %>%
  merge(., md_tamRun5_v3[, c("sampleID", "animalID")], by.x = "Sample1", by.y = "sampleID", all.x = T) %>%
  merge(., md_tamRun5_v3[, c("sampleID", "animalID")], by.x = "Sample2", by.y = "sampleID", all.x = T, suffixes = c("1", "2")) %>%
  relocate(Sample1)
```

**tamRun5.125 / 139 vs. 167, 179 - keepOriginal**

topMatch = tamRun5.321 / 139

```{r}
View(polyGenResults_0x_dupTest_animalIDs %>%
       filter(animalID1 == 139 | animalID2 == 139) %>%
       arrange(desc(proportionMatch)))
```

**tamRun5.142 / 195 vs. 74 - keepOriginal**

topMatch = tamRun5.286 / 195

```{r}
View(polyGenResults_0x_dupTest_animalIDs %>%
       filter(animalID1 %in% c(195, 74) & animalID2  %in% c(195, 74)) %>%
       arrange(desc(proportionMatch)))
```

**tamRun5.202 / 54 vs. 91 - keepOriginal**

topMatch = tamRun5.202 / 54

```{r}
View(polyGenResults_0x_dupTest_animalIDs %>%
       filter(animalID1 %in% c(54, 91) & animalID2  %in% c(54, 91)) %>%
       arrange(desc(proportionMatch)))
```

**tamRun5.238 / 91 vs. 54 - keepOriginal**

not enough commonGenos to say for sure, but based on animalID 54 results, probably ok to keep as-is

```{r}
View(polyGenResults_0x_dupTest_animalIDs %>%
       filter(animalID1 %in% c(54, 91) & animalID2  %in% c(54, 91)) %>%
       arrange(desc(proportionMatch)))
```

**tamRun5.239 / 283 vs. 34 - keepOriginal**

not enough commonGenos for this sample to say anything; keep as-is for now

```{r}
View(polyGenResults_0x_dupTest_animalIDs %>%
       filter(animalID1 %in% c(283, 34) & animalID2  %in% c(283, 34)) %>%
       arrange(desc(proportionMatch)))
```

**tamRun5.264 / 169 vs. 200 - update_toAlt**

topMatch = tamRun5.211 / 200 (0.98 match)

```{r}
View(polyGenResults_0x_dupTest_animalIDs %>%
       filter(animalID1 %in% c(169, 200) & animalID2  %in% c(169, 200)) %>%
       arrange(desc(proportionMatch)))
```

**tamRun5.305 / 69 vs. 26 - update_toAlt**

not enough commonGenos to say for sure, but going to go with alt based on trapSheet records

```{r}
View(polyGenResults_0x_dupTest_animalIDs %>%
       filter(animalID1 %in% c(69, 26) & animalID2  %in% c(69, 26)) %>%
       arrange(desc(proportionMatch)))
```

**tamRun5.325 / 70 vs. 69 - update_toAlt**

topMatch = tamRun5.160 (0.85 match), but other samples for animalID 69 don't have enough commonGenos to say for sure; going with trapSheet here and going ahead w/update_toAlt

```{r}
View(polyGenResults_0x_dupTest_animalIDs %>%
       filter(animalID1 %in% c(70, 69) & animalID2  %in% c(70, 69)) %>%
       arrange(desc(proportionMatch)))
```

**tamRun5.374 / 98 vs. 27 - update_toAlt**

results are too similar to say for sure, but going to go ahead and update_toAlt based on trapSheet records

```{r}
View(polyGenResults_0x_dupTest_animalIDs %>%
       filter(animalID1 %in% c(98, 27) & animalID2  %in% c(98, 27)) %>%
       arrange(desc(proportionMatch)))
```

### errorChecks5_actionList

```{r}
errorChecks5_actionList <- data.frame(
  sampleID = c("tamRun5.125",
               "tamRun5.142",
               "tamRun5.202",
               "tamRun5.238",
               "tamRun5.239",
               "tamRun5.264",
               "tamRun5.305",
               "tamRun5.325",
               "tamRun5.374"),
  notes_mdReconciliation = c(rep("[dupTest notes: mdAction_final originally 'tbd'; GTscore duptest suggests md_original is correct]", 5),
                             rep("[dupTest notes: mdAction_final originally 'tbd_sexMismatch'; GTscore duptest suggests md_alt is correct]", 4)),
  action_dupChecks = c("keepOriginal",
                       "keepOriginal",
                       "keepOriginal",
                       "keepOriginal",
                       "keepOriginal",
                       "update_toAlt",
                       "update_toAlt",
                       "update_toAlt",
                       "update_toAlt"),
  flagged_in = "errorChecks5"
)
```

### Update errorChecks_fullList_v4

```{r}
errorChecks_fullList_v4 <- errorChecks_fullList_v3 %>%
  merge(., errorChecks5_actionList, by = "sampleID", all = T) %>%
  relocate(action_dupChecks, .after = action_spSexChecks) %>%
  
  mutate(
    action_final = case_when(
      !is.na(action_dupChecks) ~ action_dupChecks,
      .default = action_final
    )
  ) %>%
  
  mutate(
    flagged_in = case_when(
      is.na(flagged_in.x) ~ flagged_in.y,
      is.na(flagged_in.y) ~ flagged_in.x,
      .default = str_c(flagged_in.x, "; ", flagged_in.y)
    )
  ) %>%
  relocate(flagged_in, .after = action_final) %>%
  
  mutate(
    notes_mdReconciliation = case_when(
      is.na(notes_mdReconciliation.x) ~ notes_mdReconciliation.y,
      is.na(notes_mdReconciliation.y) ~ notes_mdReconciliation.x,
      .default = str_c(notes_mdReconciliation.x, "; ", notes_mdReconciliation.y)
    )
  ) %>%
  relocate(notes_mdReconciliation, .after = rowID_alt) %>%
  select(!contains(".x")) %>%
  select(!contains(".y")) %>%
  
  # add species_alt and sex_alt in
  mutate(
    species_alt = case_when(
      str_detect(md_alt, "LWED") ~ "LWED",
      str_detect(md_alt, "SIMP") ~ "SIMP",
      .default = NA
    ),
    sex_alt = case_when(
      str_detect(md_alt, "_F") ~ "F",
      str_detect(md_alt, "_M") ~ "M",
      .default = NA
    )
  ) %>%
  relocate(c(species_alt, sex_alt), .after = animalName_alt) %>%
  relocate(md_alt, .before = animalID_alt)

write.csv(errorChecks_fullList_v4, "./metadataReconciliation/master_metadataReconciliation_actionList_v4.csv", row.names = F)
```

### Update md_tamRun5_v4

```{r}
md_tamRun5_v4 <- md_tamRun5_v3 %>%
  merge(., errorChecks5_actionList, by = "sampleID", all.x = T) %>%
  merge(., errorChecks_fullList_v4[, c("sampleID", "action_dupChecks", "animalID_alt", "animalName_alt", "species_alt", "sex_alt", "group_alt", "captureDate_alt", "rowID_alt")], by = c("sampleID", "action_dupChecks"), all.x = T) %>%
  
  # adjust mdAction_final & notes
  mutate(
    mdAction_final = case_when(
      !is.na(action_dupChecks) ~ action_dupChecks,
      .default = mdAction_final
    )
  ) %>%
  
  mutate(
    notes_mdReconciliation = case_when(
      !is.na(notes_mdReconciliation.y) ~ str_c(notes_mdReconciliation.x, "; ", notes_mdReconciliation.y),
      .default = notes_mdReconciliation.x
    )
  ) %>%
  relocate(notes_mdReconciliation, .after = md_alt) %>%
  select(-contains(".x"), -contains(".y"), -flagged_in) %>%
  
  # update md
  mutate(
    animalID = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ animalID_alt,
      .default = animalID
    ),
    animalName = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ animalName_alt,
      .default = animalName
    ),
    species = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ species_alt,
      .default = species
    ),
    sex = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ sex_alt,
      .default = sex
    ),
    group = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ group_alt,
      .default = group
    ),
    captureDate = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ as.character(captureDate_alt),
      .default = as.character(captureDate)
    ),
    fieldNotes = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ NA,
      .default = fieldNotes
    )
  ) %>%
  relocate(animalName, .before = group) %>%
  mutate(
    md_alt = str_c(rowID_alt, animalID_alt, species_alt, sex_alt, animalName_alt, group_alt, captureDate_alt, sep = "_"),
    md_alt = str_c("rowID", md_alt)
         ) %>%
  select(-c(rowID_alt, animalID_alt, species_alt, sex_alt, animalName_alt, group_alt, captureDate_alt, action_dupChecks))
```

## 6.6 errorChecks6 - Recheck dups

### Recheck likely dups

0x - animalID mismatch = 90; match = 94 (pre-recheck mismatch = 94; match = 90)
10x - animalID mismatch = 116; match = 83 (pre-recheck mismatch = 20; match = 79)

```{r}
# n = 184 dup pairs for 0x
likelyDups_0x_recheck <- polyGenResults_0x_dupTest %>%
  filter(proportionMatch >= 0.8,
         commonGenotypes >= 50) %>%
  merge(., md_tamRun5_v4[, c("sampleID", "sampleType", "animalID", "md_alt", "mdAction_final", "md_original", "notes_mdReconciliation")], by.x = "Sample1", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType1" = "sampleType",
                "animalID1" = "animalID",
                "md_alt1" = "md_alt",
                "mdAction_final1" = "mdAction_final",
                "md_original1" = "md_original",
                "notes_mdReconciliation1" = "notes_mdReconciliation") %>%
  merge(., md_tamRun5_v4[, c("sampleID", "sampleType", "animalID", "md_alt", "mdAction_final", "md_original", "notes_mdReconciliation")], by.x = "Sample2", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType2" = "sampleType",
                "animalID2" = "animalID",
                "md_alt2" = "md_alt",
                "mdAction_final2" = "mdAction_final",
                "md_original2" = "md_original",
                "notes_mdReconciliation2" = "notes_mdReconciliation") %>%
  relocate(sampleType2, .after = sampleType1) %>%
  relocate(animalID2, .after = animalID1) %>%
  relocate(md_alt2, .after = md_alt1) %>%
  relocate(mdAction_final2, .after = mdAction_final1) %>%
  relocate(md_original2, .after = md_original1) %>%
  relocate(notes_mdReconciliation2, .after = notes_mdReconciliation1) %>%
  mutate(
    animalID_match = case_when(
      animalID1 == animalID2 ~ "yes",
      .default = "no"
    )
  ) %>%
  relocate(animalID_match, .after = animalID2) %>%
  relocate(Sample1)

# n = 199 dup pairs for 10x
likelyDups_10x_recheck <- polyGenResults_10x_dupTest %>%
  filter(proportionMatch >= 0.8,
         commonGenotypes >= 50) %>%
  merge(., md_tamRun5_v4[, c("sampleID", "sampleType", "animalID", "md_alt", "mdAction_final", "md_original", "notes_mdReconciliation")], by.x = "Sample1", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType1" = "sampleType",
                "animalID1" = "animalID",
                "md_alt1" = "md_alt",
                "mdAction_final1" = "mdAction_final",
                "md_original1" = "md_original",
                "notes_mdReconciliation1" = "notes_mdReconciliation") %>%
  merge(., md_tamRun5_v4[, c("sampleID", "sampleType", "animalID", "md_alt", "mdAction_final", "md_original", "notes_mdReconciliation")], by.x = "Sample2", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType2" = "sampleType",
                "animalID2" = "animalID",
                "md_alt2" = "md_alt",
                "mdAction_final2" = "mdAction_final",
                "md_original2" = "md_original",
                "notes_mdReconciliation2" = "notes_mdReconciliation") %>%
  relocate(sampleType2, .after = sampleType1) %>%
  relocate(animalID2, .after = animalID1) %>%
  relocate(md_alt2, .after = md_alt1) %>%
  relocate(mdAction_final2, .after = mdAction_final1) %>%
  relocate(md_original2, .after = md_original1) %>%
  relocate(notes_mdReconciliation2, .after = notes_mdReconciliation1) %>%
  mutate(
    animalID_match = case_when(
      animalID1 == animalID2 ~ "yes",
      .default = "no"
    )
  ) %>%
  relocate(animalID_match, .after = animalID2) %>%
  relocate(Sample1)

# tables
## after recheck
table(likelyDups_0x_recheck$animalID_match)
table(likelyDups_10x_recheck$animalID_match)

## pre-recheck
table(likelyDups_0x$animalID_match)
table(likelyDups_10x$animalID_match)
```

### Recheck matchCompare

Look at matchCompare dups again w/updated metadata

**0x cutoff**

```{r}
# create df of dups w/highest propMatch PER SAMPLEID
## ensure df arranged properly
temp1 <- likelyDups_0x_recheck %>%
  dplyr::rename("Sample1" = "Sample2",
                "Sample2" = "Sample1") %>%
  relocate(Sample1)

temp2 <- rbind(likelyDups_0x_recheck, temp1) %>%
  arrange(Sample1, desc(proportionMatch))

## extract pairs w/highest match
likelyDups_0x_highest <- temp2[match(unique(temp2$Sample1), temp2$Sample1),]

# temp dfs for hair and blood samples
temp1 <- md_tamRun5_v4 %>%
  select(sampleID, animalID, sampleType) %>%
  mutate(
    pairTo = case_when(
      sampleType == "blood" ~ "hair",
      sampleType == "hair" ~ "blood"
    )
  )

# create comparison dataframe
matchCompare_0x_recheck <- md_tamRun5_v4 %>%
  select(sampleID, animalID, sampleType) %>%
  filter(sampleType %in% c("blood", "hair")) %>%
  merge(., temp1, by.x = c("animalID", "sampleType"), by.y = c("animalID", "pairTo"), all.x = T) %>%
  dplyr::rename("sampleID_base" = "sampleID.x",
                "animalID_base" = "animalID",
                "sampleID_typeMatch" = "sampleID.y",
                "sampleType_base" = "sampleType",
                "sampleType_typeMatch" = "sampleType.y"
                ) %>%
  
  # first add type match
  merge(., polyGenResults_0x_dupTest[, c("Sample1", "Sample2", "commonGenotypes", "proportionMatch")], by.x = c("sampleID_base", "sampleID_typeMatch"), by.y = c("Sample1", "Sample2"), all.x = T) %>%
  merge(., polyGenResults_0x_dupTest[, c("Sample1", "Sample2", "commonGenotypes", "proportionMatch")], by.x = c("sampleID_base", "sampleID_typeMatch"), by.y = c("Sample2", "Sample1"), all.x = T) %>%
  mutate(
    commonGenotypes = coalesce(commonGenotypes.x, commonGenotypes.y),
    .keep = "unused"
  ) %>%
  mutate(
    proportionMatch = coalesce(proportionMatch.x, proportionMatch.y),
    .keep = "unused"
  ) %>%
  dplyr::rename("common_typeMatch" = "commonGenotypes",
                "propMatch_typeMatch" = "proportionMatch") %>%
  
  # now add top match (when available)
  merge(., likelyDups_0x_highest[, c("Sample1", "Sample2", "commonGenotypes", "proportionMatch", "animalID2")], by.x = "sampleID_base", by.y = "Sample1", all.x = T) %>%
  dplyr::rename("sampleID_topMatch" = "Sample2",
                "animalID_topMatch" = "animalID2",
                "common_topMatch" = "commonGenotypes",
                "propMatch_topMatch" = "proportionMatch") %>%
  merge(., temp1[, c("sampleID", "sampleType")], by.x = "sampleID_topMatch", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType_topMatch" = "sampleType") %>%
  
  mutate(
    baseTop_match = case_when(
      is.na(animalID_topMatch) ~ NA,
      animalID_base == animalID_topMatch ~ "yes",
      .default = "no"
    )
  ) %>%
  
  # add errorChecks
  merge(., errorChecks_fullList_v4[, c("sampleID", "action_final", "md_original", "md_alt", "notes_mdReconciliation")], by.x = "sampleID_base", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("actionFinal_base" = "action_final",
                "mdOrig_base" = "md_original",
                "mdAlt_base" = "md_alt",
                "notes_base" = "notes_mdReconciliation") %>%
  merge(., errorChecks_fullList_v4[, c("sampleID", "action_final", "md_original", "md_alt", "notes_mdReconciliation")], by.x = "sampleID_typeMatch", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("actionFinal_typeMatch" = "action_final",
                "mdOrig_typeMatch" = "md_original",
                "mdAlt_typeMatch" = "md_alt",
                "notes_typeMatch" = "notes_mdReconciliation") %>%
  merge(., errorChecks_fullList_v4[, c("sampleID", "action_final", "md_original", "md_alt", "notes_mdReconciliation")], by.x = "sampleID_topMatch", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("actionFinal_topMatch" = "action_final",
                "mdOrig_topMatch" = "md_original",
                "mdAlt_topMatch" = "md_alt",
                "notes_topMatch" = "notes_mdReconciliation") %>%
  
  relocate(c("sampleID_base",
             "sampleID_typeMatch",
             "sampleID_topMatch",
             
             "sampleType_base",
             "sampleType_typeMatch",
             "sampleType_topMatch",
             
             "animalID_base",
             "animalID_topMatch",
             "baseTop_match",
             
             "propMatch_typeMatch",
             "propMatch_topMatch",
             "common_typeMatch",
             "common_topMatch",
             
             "actionFinal_base",
             "mdOrig_base",
             "mdAlt_base",
             "notes_base",
             
             "actionFinal_typeMatch",
             "mdOrig_typeMatch",
             "mdAlt_typeMatch",
             "notes_typeMatch",
             
             "actionFinal_topMatch",
             "mdOrig_topMatch",
             "mdAlt_topMatch",
             "notes_topMatch"))
```

**10x cutoff**

```{r}
# create df of dups w/highest propMatch PER SAMPLEID
## ensure df arranged properly
temp1 <- likelyDups_10x_recheck %>%
  dplyr::rename("Sample1" = "Sample2",
                "Sample2" = "Sample1") %>%
  relocate(Sample1)

temp2 <- rbind(likelyDups_10x_recheck, temp1) %>%
  arrange(Sample1, desc(proportionMatch))

## extract pairs w/highest match
likelyDups_10x_highest <- temp2[match(unique(temp2$Sample1), temp2$Sample1),]

# temp dfs for hair and blood samples
temp1 <- md_tamRun5_v4 %>%
  select(sampleID, animalID, sampleType) %>%
  mutate(
    pairTo = case_when(
      sampleType == "blood" ~ "hair",
      sampleType == "hair" ~ "blood"
    )
  )

# create comparison dataframe
matchCompare_10x_recheck <- md_tamRun5_v4 %>%
  select(sampleID, animalID, sampleType) %>%
  filter(sampleType %in% c("blood", "hair")) %>%
  merge(., temp1, by.x = c("animalID", "sampleType"), by.y = c("animalID", "pairTo"), all.x = T) %>%
  dplyr::rename("sampleID_base" = "sampleID.x",
                "animalID_base" = "animalID",
                "sampleID_typeMatch" = "sampleID.y",
                "sampleType_base" = "sampleType",
                "sampleType_typeMatch" = "sampleType.y"
                ) %>%
  
  # first add type match
  merge(., polyGenResults_10x_dupTest[, c("Sample1", "Sample2", "commonGenotypes", "proportionMatch")], by.x = c("sampleID_base", "sampleID_typeMatch"), by.y = c("Sample1", "Sample2"), all.x = T) %>%
  merge(., polyGenResults_10x_dupTest[, c("Sample1", "Sample2", "commonGenotypes", "proportionMatch")], by.x = c("sampleID_base", "sampleID_typeMatch"), by.y = c("Sample2", "Sample1"), all.x = T) %>%
  mutate(
    commonGenotypes = coalesce(commonGenotypes.x, commonGenotypes.y),
    .keep = "unused"
  ) %>%
  mutate(
    proportionMatch = coalesce(proportionMatch.x, proportionMatch.y),
    .keep = "unused"
  ) %>%
  dplyr::rename("common_typeMatch" = "commonGenotypes",
                "propMatch_typeMatch" = "proportionMatch") %>%
  
  # now add top match (when available)
  merge(., likelyDups_10x_highest[, c("Sample1", "Sample2", "commonGenotypes", "proportionMatch", "animalID2")], by.x = "sampleID_base", by.y = "Sample1", all.x = T) %>%
  dplyr::rename("sampleID_topMatch" = "Sample2",
                "animalID_topMatch" = "animalID2",
                "common_topMatch" = "commonGenotypes",
                "propMatch_topMatch" = "proportionMatch") %>%
  merge(., temp1[, c("sampleID", "sampleType")], by.x = "sampleID_topMatch", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType_topMatch" = "sampleType") %>%
  
  mutate(
    baseTop_match = case_when(
      is.na(animalID_topMatch) ~ NA,
      animalID_base == animalID_topMatch ~ "yes",
      .default = "no"
    )
  ) %>%
  
  # add errorChecks
  merge(., errorChecks_fullList_v4[, c("sampleID", "action_final", "md_original", "md_alt", "notes_mdReconciliation")], by.x = "sampleID_base", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("actionFinal_base" = "action_final",
                "mdOrig_base" = "md_original",
                "mdAlt_base" = "md_alt",
                "notes_base" = "notes_mdReconciliation") %>%
  merge(., errorChecks_fullList_v4[, c("sampleID", "action_final", "md_original", "md_alt", "notes_mdReconciliation")], by.x = "sampleID_typeMatch", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("actionFinal_typeMatch" = "action_final",
                "mdOrig_typeMatch" = "md_original",
                "mdAlt_typeMatch" = "md_alt",
                "notes_typeMatch" = "notes_mdReconciliation") %>%
  merge(., errorChecks_fullList_v4[, c("sampleID", "action_final", "md_original", "md_alt", "notes_mdReconciliation")], by.x = "sampleID_topMatch", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("actionFinal_topMatch" = "action_final",
                "mdOrig_topMatch" = "md_original",
                "mdAlt_topMatch" = "md_alt",
                "notes_topMatch" = "notes_mdReconciliation") %>%
  
  relocate(c("sampleID_base",
             "sampleID_typeMatch",
             "sampleID_topMatch",
             
             "sampleType_base",
             "sampleType_typeMatch",
             "sampleType_topMatch",
             
             "animalID_base",
             "animalID_topMatch",
             "baseTop_match",
             
             "propMatch_typeMatch",
             "propMatch_topMatch",
             "common_typeMatch",
             "common_topMatch",
             
             "actionFinal_base",
             "mdOrig_base",
             "mdAlt_base",
             "notes_base",
             
             "actionFinal_typeMatch",
             "mdOrig_typeMatch",
             "mdAlt_typeMatch",
             "notes_typeMatch",
             
             "actionFinal_topMatch",
             "mdOrig_topMatch",
             "mdAlt_topMatch",
             "notes_topMatch"))
```

### Mismatch animalIDs

#### 0x cutoff

With the 0x cutoff, there are 31 dupTest results in which typeMatch and topMatch animalIDs are not the same; 21 of these mismatches are likely twin pairs, leaving 10 pairs to investigate.

```{r}
matchCompare_0x_idMismatch <- matchCompare_0x_recheck %>%
  filter(baseTop_match == "no") %>%
  arrange(sampleID_base) %>%
  mutate(
    temp = str_c(sampleID_base, sampleID_topMatch, sep = "_")
  )

matchCompare_0x_idMismatch_likelyTwins <- matchCompare_0x_idMismatch %>%
  merge(., capData_byIndiv_v5_firstEntry[, c("animalID", "captureDate", "ageClass", "groupName", "species")], by.x = "animalID_base", by.y = "animalID", all.x = T) %>%
  merge(., capData_byIndiv_v5_firstEntry[, c("animalID", "captureDate", "ageClass", "groupName", "species")], by.x = "animalID_topMatch", by.y = "animalID", all.x = T, suffixes = c("_base", "_topMatch")) %>%
  filter(captureDate_base == captureDate_topMatch) %>%
  filter(ageClass_base == "juvenile" & ageClass_topMatch == "juvenile") %>%
  filter(groupName_base == groupName_topMatch) %>%
  filter(species_base == species_topMatch) %>%
  mutate(
    temp = str_c(sampleID_base, sampleID_topMatch, sep = "_")
  )

matchCompare_0x_idMismatch_v2 <- matchCompare_0x_idMismatch %>%
  filter(!temp %in% matchCompare_0x_idMismatch_likelyTwins$temp)

# quick counts
nrow(matchCompare_0x_idMismatch)
nrow(matchCompare_0x_idMismatch_likelyTwins)
nrow(matchCompare_0x_idMismatch_v2)
```

#### 10x cutoff

With the 10x cutoff, there are 34 dupTest results in which typeMatch and topMatch animalIDs are not the same; 23 of these mismatches are likely twin pairs, leaving 11 pairs to investigate.

```{r}
matchCompare_10x_idMismatch <- matchCompare_10x_recheck %>%
  filter(baseTop_match == "no") %>%
  arrange(sampleID_base) %>%
  mutate(
    temp = str_c(sampleID_base, sampleID_topMatch, sep = "_")
  )

matchCompare_10x_idMismatch_likelyTwins <- matchCompare_10x_idMismatch %>%
  merge(., capData_byIndiv_v5_firstEntry[, c("animalID", "captureDate", "ageClass", "groupName", "species")], by.x = "animalID_base", by.y = "animalID", all.x = T) %>%
  merge(., capData_byIndiv_v5_firstEntry[, c("animalID", "captureDate", "ageClass", "groupName", "species")], by.x = "animalID_topMatch", by.y = "animalID", all.x = T, suffixes = c("_base", "_topMatch")) %>%
  filter(captureDate_base == captureDate_topMatch) %>%
  filter(ageClass_base == "juvenile" & ageClass_topMatch == "juvenile") %>%
  filter(groupName_base == groupName_topMatch) %>%
  filter(species_base == species_topMatch) %>%
  mutate(
    temp = str_c(sampleID_base, sampleID_topMatch, sep = "_")
  )

matchCompare_10x_idMismatch_v2 <- matchCompare_10x_idMismatch %>%
  filter(!temp %in% matchCompare_10x_idMismatch_likelyTwins$temp)

# quick counts
nrow(matchCompare_10x_idMismatch)
nrow(matchCompare_10x_idMismatch_likelyTwins)
nrow(matchCompare_10x_idMismatch_v2)
```

#### Assess

I've assessed each potential dup one by one below and have decided to update the metadata for one sample:

-   5) tamRun5.042 / 191 vs. tamRun5.280 / 189 - update tamRun5.280 to 191_SIMP_F

I was also on the fence about tamRun5.067 (see details below), but ultimately decided to leave it as-is.

Detailed explanations for this choice are below.

**1) tamRun5.014 / 182 vs. tamRun5.110 / 225 - no action**

-   no actions listed
-   typeMatch = tamRun5.201 / 182 vs. topMatch = tamRun5.110 / 225
-   common_typeMatch = 57 vs. common_topMatch = 159
-   propMatch_typeMatch = 0.60 vs. propMatch_topMatch = 0.92
-   animalID 182 juv in 2016; animalID 225 juv in 2018... full sibs?


**2) tamRun5.017 / 145 vs. tamRun5.117 / 146 - no action**

-   no actions listed
-   both blood samples
-   both captured as adults in same group; but perhaps twins?
-   wet lab md checks don't suggest that a swap would've been likely


**3) tamRun5.019 / 219 vs. tamRun5.071 / 283 - no action**

-   actionFinal_topMatch = keepOriginal; md_alt = 34_SIMP_F; trapSheet for animalID 34 has 283's sampleNames but crossed out + updated sampleNames in red; sexCheck confirmed keepOriginal
-   common_typeMatch = 0 (unhelpful)
-   animalID 219_SIMP_M juv on first capture 2018-06-13
-   animalID 283_SIMP_M subadult on first capture 2019-06-22
-   perhaps twins? given that 283 was subadult in 2019 and 219 was juv in 2018 (no capture for 283 in 2018)


**4) tamRun5.033 / 185 vs. tamRun5.036 / 157 - no action**

-   no actions listed
-   looks like another case of siblings based on capData (each captured as juvs one year apart)


**5) tamRun5.042 / 191 vs. tamRun5.280 / 189 - update tamRun5.280 to 191_SIMP_F**

-   already caught this one below:

From "ignore all below" scripts: "tamRun5.280/189_LWED_M is mismatched at both species and sex - all 3 genotyped species loci = SIMP and both sex loci (general sex loci) = F. Furthermore, looking back at the original genotype file, this individual was also genotyped as F for two SIMP-specific sex loci. These results suggest that that this individual is SIMP_F vs. LWED_M."

I double-checked the hair and blood sampleNames against their trapping sheets for both animalIDs; all confirmed correct. Unfortunately, the corresponding hair/blood samples for each animalID have barely a handful of genotypes, so I can't use them as an additional check.

-   tamRun5.180/189 - lm_1231 - 2019-06-18 - confirmed
-   tamRun5.280/189 - env_563 - 2019-06-18 - confirmed
-   tamRun5.042/191 - lm_1039 - 2018-06-27 - confirmed
-   tamRun5.288/191 - env_228 - 2016-06-18 - confirmed

Next check - wet lab metadata - found the issue I think -- hair samples tamRun5.280/189 xtnLoc is p3.H11 and tamRun5.288/191 xtnLoc is p3.H12; both were added from lysis tubes, which means I added them manually. My guess is that I added both samples to p3.H11, but only tamRun5.191 actually amplified; as such, these are the genotypes that are popping up (vs. those of tamRun5.189). - checked quip, didn't see any notes about it, though it looks like Raquel helped me with this extraction plate? I think I was the one to transfer the lysis to the extraction plate though, so it would've been me - in any case though, I think updating the md for tamRun5.280 to 191_SIMP_F is a reasonable plan for now


**6) tamRun5.067 / 196 vs. tamRun5.385 / 197 - no action**

-   actionFinal_base = update_toAlt_sexMismatch; md_original = 212_SIMP_F; md_alt = 196_LWED_F 
-   this is an odd case in which both typeMatch and topMatch are hair samples and both have about the same number of common genos, but prop_typeMatch = 0.70 vs. prop_topMatch = 0.95
-   both captured as adults in same group
-   looking at the blood sample for 197 (tamRun5.020), topMatch is tamRun5.385, but second top is tamRun5.067
-   the other blood sample for 196 (tamRun5.161) had too low geno success to help
-   tamRun5.067 does have sexAssigned M (vs. F which we'd expect for animalID 196); but it's also a blood sample so it's hard to say if that actually tells us anything... it's just tricky b/c tamRun5.067 follows almost exactly the same propMatch patterns as tamRun5.020, but that also makes sense b/c tamRun5.067/tamRun5.020 have propMatch 0.95 for both 0x and 10x cutoffs... I guess just leave it for now, but keep it in mind for future analyses

```{r}
View(polyGenResults_0x_dupTest_animalIDs %>%
       filter(animalID1 %in% c(196, 197) | animalID2 %in% c(196, 197)))

View(polyGenResults_10x_dupTest %>%
       filter(Sample1 == "tamRun5.020" & Sample2 == "tamRun5.254"))
```


**7) tamRun5.105 / 148 vs. tamRun5.186 / 168 - no action**

-   captured as juvs one year apart, likely sibs?
	
	
**8) tamRun5.131 / 276 vs. tamRun5.157 / 223 - no action**

-   captured as juvs one yeaer apart, likely sibs
-   propMatch_topMatch only 0.8 anyway (typeMatch failed)


**9) tamRun5.147 / 173 vs. tamRun5.154 / 172 - no action**

-   both first captured as adults, same captureDate same group
-   propMatch and commonGenos about the same


**10) tamRun5.151 / 159 vs. tamRun5.153 / 158 - no action**

-   no actions listed
-   both first captured as subadults same group same captureDate; likely twins
-   plus topMatch is a blood sample vs. typeMatch is a hair sample


#### 0x vs. 10x cutoff

**There are 2 dup entries that were in 0x cutoff but not 10x cutoff:**

Not concerned about these bc determined no action needed anyway

-   tamRun5.105 / 148_blood vs. tamRun5.186 / 168_blood
-   tamRun5.147 / 173_blood vs. tamRun5.154 / 172_blood - no action (determined above)

```{r}
matchCompare_0x_idMismatch_v2 %>%
  select(temp) %>%
  filter(!temp %in% matchCompare_10x_idMismatch_v2$temp)

View(matchCompare_0x_idMismatch_v2 %>%
       filter(!temp %in% matchCompare_10x_idMismatch_v2$temp))
```

**And 3 dup entries in the 10x cutoff that weren't in the 0x cutoff:**

I'm not concerned about any of them; propMatch_typeMatch was higher for two of them (common_typeMatch were < 50 so were filtered out) and the other sample doesn't have a typeMatch; plus propMatch_topMatch aren't over 0.86

-   tamRun5.076 / 170_blood vs. tamRun5.158 / 149_blood
-   tamRun5.106 / 98_blood vs. tamRun5.160 / 69_blood
-   tamRun5.137 / 54_blood vs. tamRun5.181 / 15_blood

```{r}
matchCompare_10x_idMismatch_v2 %>%
  select(temp) %>%
  filter(!temp %in% matchCompare_0x_idMismatch_v2$temp)

View(matchCompare_10x_idMismatch_v2 %>%
       filter(!temp %in% matchCompare_0x_idMismatch_v2$temp))
```

### errorChecks6_actionList

just adding action for tamRun5.280

```{r}
# grab md_alt info for tamRun5.280 (update_toAlt animalID 191)
md_tamRun5.288 <- md_tamRun5_v4 %>%
  filter(sampleID %in% "tamRun5.288") %>%
  select(c(animalID, animalName, species, sex, group, captureDate)) %>%
  merge(., capData_byIndiv_v5[, c("animalID", "captureDate", "rowID")], by = c("animalID", "captureDate"), all.x = T) %>%
  mutate(
    md = str_c(animalID, species, sex, sep = "_")
  ) %>%
  setNames(paste0(names(.), "_alt")) %>%
  select(c(md_alt, animalID_alt, animalName_alt, species_alt, sex_alt, group_alt, captureDate_alt, rowID_alt))

# create errorChecks6_actionList
errorChecks6_actionList <- md_tamRun5_v4 %>%
  filter(sampleID == "tamRun5.280") %>%
  select(c(sampleID, animalID, animalName, species, sex, sampleName, captureDate)) %>%
  mutate(
    md_original = str_c(animalID, species, sex, sep = "_"),
    animalID_sampleName = str_c(animalID, sampleName, sep = "_"),
    action = NA,
    action_spSexChecks = NA,
    action_dupChecks = "update_toAlt",
    action_final = "update_toAlt",
    flagged_in = "errorChecks6"
  ) %>%
  relocate(md_original, .after = animalName) %>%
  relocate(animalID_sampleName, .before = captureDate) %>%
  select(-species, -sex) %>%
  mutate(
    notes_mdReconciliation = "[dupTest notes: GTscore duptest flagged as dup for tamRun5.042/191_SIMP_F (blood) w/95% match; neither 189_blood nor 191_hair had high enough genoSuccess for additional checks, but species/sex checks confirm SIMP_F; further investigation shows that hair samples for animalIDs 189/191 were in xtnLoc p3.H11 & p3.H12, respectively, suggesting pipetting error (i.e., transferred animalID 191 hair lysate into the well for animalID 189); given high match%, recommend updating md to that for 191_SIMP_F]"
  ) %>%
  cbind(., md_tamRun5.288) %>%
  relocate(notes_mdReconciliation, .after = rowID_alt)
```

## 6.7 Update errorChecks_fullList_v5

add tamRun5.280 action + add a note for tamRun5.067

```{r}
errorChecks_fullList_v5 <- rbind(errorChecks_fullList_v4,
                                 errorChecks6_actionList) %>%
  arrange(sampleID) %>%
  # add notes for tamRun5.067
  mutate(
    action_dupChecks = case_when(
      sampleID == "tamRun5.067" ~ "update_toAlt_sexMismatch",
      .default = action_dupChecks
    ),
    flagged_in = case_when(
      sampleID == "tamRun5.067" ~ str_c(flagged_in, "; errorChecks6"),
      .default = flagged_in
    ),
    notes_mdReconciliation = case_when(
      sampleID == "tamRun5.067" ~ str_c(notes_mdReconciliation, "; [dupTest notes: GTscore dupTest showed propMatch 0.95 for 197_LWED_M_hair vs. 0.70 for 196_LWED_F_hair - since this is a hair sample and 196/196 may be twins, I'm keeping md as 196_LWED_F, but keep in mind for future analyses]"),
      .default = notes_mdReconciliation
    )
  )

# export
write.csv(errorChecks_fullList_v5, "./metadataReconciliation/master_metadataReconciliation_actionList_v5.csv", row.names = F)
```

## 6.8 Update md_tamRun5_v5

```{r}
errorChecks_fullList_v5 <- read.csv("./metadataReconciliation/master_metadataReconciliation_actionList_v5.csv")
```


```{r}
md_tamRun5_v5 <- errorChecks6_actionList %>%
  select(sampleID, action_dupChecks, contains("alt"), notes_mdReconciliation) %>%
  mutate(
    md_alt = str_c(rowID_alt, md_alt, animalName_alt, group_alt, captureDate_alt, sep = "_"),
    md_alt = str_c("rowID", md_alt)
  ) %>%
  merge(md_tamRun5_v4, ., by = "sampleID", all.x = T) %>%
  
  # adjust mdAction_final & notes
  mutate(
    mdAction_final = case_when(
      !is.na(action_dupChecks) ~ action_dupChecks,
      .default = mdAction_final
    )
  ) %>%
  
  mutate(
    notes_mdReconciliation = case_when(
      !is.na(notes_mdReconciliation.y) ~ notes_mdReconciliation.y,
      .default = notes_mdReconciliation.x
    )
  ) %>%
  relocate(notes_mdReconciliation, .before = sampleFile) %>%
  
  # adjust md_alt
  mutate(
    md_alt = case_when(
      !is.na(md_alt.y) ~ md_alt.y,
      .default = md_alt.x
    )
  ) %>%
  select(-contains(".x"), -contains(".y")) %>%
  
  # update md_original
  mutate(
    md_original = case_when(
      !is.na(action_dupChecks) ~ str_c(animalID, species, sex, sep = "_"),
      .default = md_original
    )
  ) %>%
  
  # update md
  mutate(
    animalID = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ animalID_alt,
      .default = animalID
    ),
    animalName = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ animalName_alt,
      .default = animalName
    ),
    species = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ species_alt,
      .default = species
    ),
    sex = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ sex_alt,
      .default = sex
    ),
    group = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ group_alt,
      .default = group
    ),
    captureDate = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ as.character(captureDate_alt),
      .default = as.character(captureDate)
    ),
    fieldNotes = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ NA,
      .default = fieldNotes
    )
  ) %>%
    # update sampleNotes
    mutate(
      xtnNotes = case_when(
        sampleID == "tamRun5.280" ~ "env_563 lysate was supposed to be added here, but I think I mistakenly added tamRun5.288/env_228 lysate - see notes_mdReconciliation for details",
        .default = xtnNotes
      )
    ) %>%
    
  relocate(animalName, .before = group) %>%
  relocate(md_alt, .after = md_original) %>%
  select(-c(rowID_alt, animalID_alt, species_alt, sex_alt, animalName_alt, group_alt, captureDate_alt, action_dupChecks))
```

Export md_tamRun5_v5

```{r}
write.csv(md_tamRun5_v5, "./metadataReconciliation/tamRun5_metadata_v5.csv", row.names = F)
```

# 7 Is tamRun4 ok?

## 7.1 Data

### md_tamRun4

tamRun4 has 96 total samples

```{r}
md_tamRun4 <- read.csv("./04_tamRun4/tamRun4_metadata_illONT.csv")

quipNotes_tamRun4 <- read.csv("./04_tamRun4/tamRun4_quipPCRNotes.csv") %>%
  merge(., md_tamRun4[, c("sampleID_ill", "sampleID_ont", "well")], by.x = "pcr1Well", by.y = "well") %>%
  relocate(contains("sampleID")) %>%
  arrange(sampleID_ill)
```

### genos

```{r}
genos_tamRun4_ill_gtscore0x <- read.table("./04_tamRun4/00_illumina/03_run4GTscore/ill_fullSet_polyGenResults_singleSNP_0x.txt", header = T) %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub('[_][^_]+$', '', locus)) %>%
  column_to_rownames("locus")

genos_tamRun4_ill_gtscore10x <- read.table("./04_tamRun4/00_illumina/03_run4GTscore/ill_fullSet_polyGenResults_singleSNP_10x.txt", header = T) %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub('[_][^_]+$', '', locus)) %>%
  column_to_rownames("locus")

genos_tamRun4_ont_gtscore0x <- read.table("./04_tamRun4/01_nanopore/03_run4GTscore/ont_fullSet_polyGenResults_singleSNP_0x.txt", header = T) %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub('[_][^_]+$', '', locus)) %>%
  column_to_rownames("locus")

genos_tamRun4_ont_gtscore10x <- read.table("./04_tamRun4/01_nanopore/03_run4GTscore/ont_fullSet_polyGenResults_singleSNP_10x.txt", header = T) %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub('[_][^_]+$', '', locus)) %>%
  column_to_rownames("locus")
```

## 7.2 Any in errorList?

Seems fine -- the only samples w/actions in mdAction_final were "keepOriginal".

```{r}
md_tamRun5_v5 <- read.csv("./metadataReconciliation/tamRun5_metadata_v5.csv") %>%
  mutate(sampleID_unique = str_c(animalID, "_", sampleType))

test <- md_tamRun4_original %>%
  select(sampleID_ill, animalID, sampleType, sampleName) %>%
  merge(., md_tamRun5_v5[, c("animalID", "sampleName", "mdAction_final")], by = c("animalID", "sampleName"), all.x = T)
```

## 7.3 Check sp/sex assignments

### speciesCheck

```{r}
source("./my_sourceScripts/assignSpecies.R")

spCheck_tamRun4_gtscore0x <- assignSpecies(genos_tamRun4_ill_gtscore0x, md_tamRun4, "sampleID_ill")

spCheck_tamRun4_gtscore10x <- assignSpecies(genos_tamRun4_ill_gtscore10x, md_tamRun4, "sampleID_ill")
```

**Mismatches**

```{r}
spMismatch_tamRun4_gtscore0x <- spCheck_tamRun4_gtscore0x %>%
  filter(mdMatch == FALSE)

spMismatch_tamRun4_gtscore10x <- spCheck_tamRun4_gtscore10x %>%
  filter(mdMatch == FALSE)
```

### sexCheck

```{r}
source("./my_sourceScripts/assignSex.R")

sexCheck_tamRun4_gtscore0x <- assignSex(genos_tamRun4_ill_gtscore0x, md_tamRun4, "sampleID_ill", exclude_nonTargetSex = "yes") %>%
  merge(., md_tamRun4[, c("sampleID_ill", "species", "sampleType")], by.x = "sampleID", by.y = "sampleID_ill") %>%
  
  mutate(
    sexMaj = case_when(
      propF > propM ~ "F",
      propM > propF ~ "M",
      .default = NA
    )
  ) %>%
  
  relocate(c(species, sampleType), .after = sampleID) %>%
  relocate(sexMaj, .after = mdSex)

sexCheck_tamRun4_gtscore10x <- assignSex(genos_tamRun4_ill_gtscore10x, md_tamRun4, "sampleID_ill", exclude_nonTargetSex = "yes") %>%
  merge(., md_tamRun4[, c("sampleID_ill", "species", "sampleType")], by.x = "sampleID", by.y = "sampleID_ill") %>%
  relocate(c(species, sampleType), .after = sampleID)
```

**Mismatches**

```{r}
sexMismatch_tamRun4_gtscore0x <- sexCheck_tamRun4_gtscore0x %>%
  filter(mdMatch == FALSE)

sexMismatch_tamRun4_gtscore10x <- sexCheck_tamRun4_gtscore10x %>%
  filter(mdMatch == FALSE)
```

### spSex mismatches

Any w/mismatches at both sp and sex?

gtscore0x

-   tamRun4.049 136_fecal
-   tamRun4.053 210_fecal
-   tamRun4.088 2_hair

gtscore10x

-   tamRun4.053 210_fecal

```{r}
spSexMismatch_tamRun4_gtscore0x <- spMismatch_tamRun4_gtscore0x %>%
  select(sampleID, mdMatch, spAssigned, totalGenos_sp) %>%
  merge(., sexMismatch_tamRun4_gtscore0x[, c("sampleID", "sampleType", "mdMatch", "sexAssigned", "totalGenos_sex")], by = "sampleID", suffixes = c("_sp", "_sex")) %>%
  merge(., md_tamRun4[, c("sampleID_ill", "animalID")], by.x = "sampleID", by.y = "sampleID_ill") %>%
  relocate(c(sampleID, animalID, sampleType, spAssigned, sexAssigned, totalGenos_sp, totalGenos_sex, mdMatch_sp, mdMatch_sex))

spSexMismatch_tamRun4_gtscore10x <- spMismatch_tamRun4_gtscore10x %>%
  select(sampleID, mdMatch, spAssigned, totalGenos_sp) %>%
  merge(., sexMismatch_tamRun4_gtscore0x[, c("sampleID", "sampleType", "mdMatch", "sexAssigned", "totalGenos_sex")], by = "sampleID", suffixes = c("_sp", "_sex")) %>%
  merge(., md_tamRun4[, c("sampleID_ill", "animalID")], by.x = "sampleID", by.y = "sampleID_ill") %>%
  relocate(c(sampleID, animalID, sampleType, spAssigned, sexAssigned, totalGenos_sp, totalGenos_sex, mdMatch_sp, mdMatch_sex))
```

## 7.4 Duptest w/tamRun5

### polygen for tamRun4+5

Combine allele reads for tamRun3 and tamRun5; ensure that tamRun3 allele reads only contain loci from primerSet_v3. 

```{r}
source("./GTscore_sourceScripts/GTscore_modified.R")

# locus table
locusTable <- read.delim("./05_tamRun5/03_run5GTscore/fullSet_LocusTable_singleSNPs.txt", header = TRUE, stringsAsFactors = FALSE)

# allele reads
## tamRun4
alleleReads_tamRun4_fullSet <- read.delim("./04_tamRun4/00_illumina/03_run4GTscore/ill_fullSet_AlleleReads_singleSNPs.txt", header = TRUE, row.names = 1, stringsAsFactors = FALSE)

## tamRun5
alleleReads_tamRun5_fullSet <- read.delim("./05_tamRun5/03_run5GTscore/fullSet_AlleleReads_singleSNPs.txt", header = TRUE, row.names = 1, stringsAsFactors = FALSE)

## tamRun3.5
alleleReads_tamRun4.5_fullSet <- alleleReads_tamRun4_fullSet %>%
  merge(., alleleReads_tamRun5_fullSet, by = 0) %>%
  column_to_rownames("Row.names")

#generate singleSNP genotypes using the polyGen algorithm, adjust "0" formatting
tamRun4.5_polyGenResults <- polyGen(locusTable, alleleReads_tamRun4.5_fullSet)
```

### duptest

```{r identify duplicate samples,eval=FALSE}
#convert missing genotypes "0" to NA
tamRun4.5_polyGenResults_NA <- tamRun4.5_polyGenResults
tamRun4.5_polyGenResults_NA[tamRun4.5_polyGenResults == "0"] <- NA

#compare all samples, for each comparison get proportion of loci that have genotypes
#in both samples (proportionCommon) and proportion of shared loci that have identical
#genotypes (proportionMatch).
#Samples with a high proportionCommon and high proportionMatch are likely duplicates
tamRun4.5_dupTest <- IDduplicateSamples(tamRun4.5_polyGenResults_NA)

# export
write.table(tamRun4.5_dupTest,"./metadataReconciliation/dupTest_tamRun4.5_0x.txt", quote = FALSE, sep = "\t", row.names = FALSE)

# add animalIDs
tamRun4.5_dupTest_animalIDs <- tamRun4.5_dupTest %>%
  
  merge(., md_tamRun4[, c("sampleID_ill", "sampleID_unique")], by.x = "Sample1", by.y = "sampleID_ill", all.x = T) %>%
  merge(., md_tamRun5_v5[, c("sampleID", "sampleID_unique")], by.x = "Sample1", by.y = "sampleID", all.x = T) %>%
  mutate(
    id1 = coalesce(sampleID_unique.x, sampleID_unique.y),
    .keep = "unused"
  ) %>%
  
  merge(., md_tamRun4[, c("sampleID_ill", "sampleID_unique")], by.x = "Sample2", by.y = "sampleID_ill", all.x = T) %>%
  merge(., md_tamRun5_v5[, c("sampleID", "sampleID_unique")], by.x = "Sample2", by.y = "sampleID", all.x = T) %>%
  mutate(
    id2 = coalesce(sampleID_unique.x, sampleID_unique.y),
    .keep = "unused"
  ) %>%
  
  relocate(Sample1)
```

### likelyDups

Subset the duptest results so that we have 1) tamRun3 vs. tamRun5 combinations only, and 2) commonGenos >= 50 and proportionMatch >= 0.8

Also add md_original for tamRun5 sample (where applicable) plus sample types for both tamRun3 and tamRun5 samples

```{r}
tamRun4.5_likelyDups <- tamRun4.5_dupTest_animalIDs %>%
  # (dupTest is in alpha order so run4/5 combos will always be sample1/2 order)
  filter(str_detect(Sample1, "tamRun4") & str_detect(Sample2, "tamRun5")) %>%
  filter(commonGenotypes >= 50) %>%
  filter(proportionMatch >= 0.8) %>%
  # add animalIDs
  merge(., md_tamRun4[, c("sampleID_ill", "animalID", "sampleType")], by.x = "Sample1", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("animalID_tamRun3" = "animalID",
                "sampleType_tamRun3" = "sampleType") %>%
  merge(., md_tamRun5_v5[, c("sampleID", "animalID", "sampleType", "md_original")], by.x = "Sample2", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("animalID_tamRun5" = "animalID",
                "sampleType_tamRun5" = "sampleType") %>%
  mutate(
    animalID_match = case_when(
      animalID_tamRun3 == animalID_tamRun5 ~ "yes",
      .default = "no"
    )
  ) %>%
  relocate(Sample1) %>%
  relocate(c(animalID_tamRun3, animalID_tamRun5, animalID_match, md_original), .after = Sample2) %>%
  arrange(Sample1)
```

### matchCompare

```{r}
matchCompare_tamRun4.5 <- tamRun4.5_likelyDups %>%
  separate(id1, into = c("animalID1", "sampleType1")) %>%
  separate(id2, into = c("animalID2", "sampleType2")) %>%
  mutate(
    idMatch = case_when(
      animalID1 == animalID2 ~ "yes",
      .default = "no"
    )
  )
```





# XXXXXXXXXXXXXXXX

# IGNORE ALL BELOW

# 3 Data

## 3.1 Metadata

```{r}
md_tamRun5_v1 <- read.csv("./metadataReconciliation/tamRun5_metadata.csv") %>%
  arrange(sampleID)

md_tamRun4 <- read.csv("./04_tamRun4/metadata_tamRun4_illONT.csv") %>%
  mutate(
    sampleID = sampleID_ill
  )
```

## 3.2 Sample logs

```{r}
sampleLog_blood <- read.csv("./sampleOrganization/originalData/longmireLog_CICRA_2013-2019.csv") %>%
  filter(species %in% c("SFUS", "SIMP"))%>%
  mutate(
    species = case_when(
      species == "SFUS" ~ "LWED",
      .default = species
    )
  ) %>%
  rename("sampleName" = "tubeNo.") %>%
  mutate(
    sampleName = str_c("lm_", sampleName)
  ) %>%
  select(-X)
```

# 3 Blood samples

## 3.1 Find duplicated sampleIDs

From the original longmire log, there are 27 tube numbers that are duplicated, with numbers arising no more than twice.

With regard to species, this includes: - 15 tube numbers duplicated across species (one copy for LWED, one for SIMP) - 9 tube numbers duplicated within LWED individuals (one number for two different LWED individuals) - 3 tube numbers duplicated within SIMP individuals (one number for two different LWED individuals)

And with regard to sex, this includes: - 15 tube numbers duplicated across sex (one copy for F, one for M) - 2 tube numbers duplicated within F individuals (one number for two different F individuals) - 10 tube numbers duplicated within M individuals (one number for two different M individuals)

```{r}
# reformat sampleID info for easier manipulation; first md record (sample_md.log1) belongs to the first indiv captured according to captureDate
sampleLog_blood_shortNames <- sampleLog_blood %>%
  mutate(
    captureDate = mdy(captureDate)
  ) %>%
  # sort by capture date
  arrange(as.numeric(gsub("lm_", "", sampleName)), captureDate) %>%
mutate(
    sample_md = str_c(animalID, species, sex, sep = "_")
  ) %>%
  select(c("sampleName", "sample_md")) %>%
  group_by(sampleName) %>%
  mutate(row_n = row_number()) %>%
  pivot_wider(id_cols = sampleName,
              names_from = row_n,
              values_from = sample_md,
              names_glue = "sample_md.log{row_n}")

# find duplicated tube numbers & determine dup type (same sp or diff sp)
dupSampleNames_blood <- sampleLog_blood_shortNames %>%
  na.omit() %>%
  mutate(
    dupType_sp = case_when(
      str_detect(sample_md.log1, "LWED") & str_detect(sample_md.log2, "LWED") ~ "sameSp_lwed",
      str_detect(sample_md.log1, "SIMP") & str_detect(sample_md.log2, "SIMP") ~ "sameSp_simp",
      str_detect(sample_md.log1, "LWED") & str_detect(sample_md.log2, "SIMP") | str_detect(sample_md.log1, "SIMP") & str_detect(sample_md.log2, "LWED") ~ "diffSp"
    ),
    dupType_sex = case_when(
      str_detect(sample_md.log1, "_F") & str_detect(sample_md.log2, "_F") ~ "sameSex_F",
      str_detect(sample_md.log1, "_M") & str_detect(sample_md.log2, "_M") ~ "sameSex_M",
      str_detect(sample_md.log1, "_F") & str_detect(sample_md.log2, "_M") | str_detect(sample_md.log1, "_M") & str_detect(sample_md.log2, "_F") ~ "diffSex"
    )
  )

# table of dup types (same sp, diff sp)
table(dupSampleNames_blood$dupType_sp)
table(dupSampleNames_blood$dupType_sex)
```

Looking back at the metadata associated with these tube numbers from the original longmire log, there is no indication that any of these numbers were updated. The only sample notes included are for longmire tube number 600 (SIMP version), which reads: "Notes section on SampleCode Sheet says tube is labeled".

```{r}
# dup tube metadata
md_dupSampleNames_blood <- sampleLog_blood %>%
  filter(sampleName %in% dupSampleNames_blood$sampleName)
```

Export samples with duplicated tube numbers

```{r}
write.csv(md_dupSampleNames_blood, "./metadataReconciliation/dupSampleNames_bloodSamples.csv", row.names = F)
```

## 3.2 Check extractions

Of the longmire blood samples that I extracted, 8 samples have duplicate sample names (tube numbers) according to what I found in the original sample log above.

These include the sample names below, which I've listed with the metadata that was originally listed in the extraction master file:

-   lm_582 - 169_LWED_M
-   lm_583 - 22_SIMP_M
-   lm_585 - 12_LWED_F
-   lm_586 - 212_SIMP_F
-   lm_588 - 211_SIMP_F
-   lm_592 - 215_SIMP_F
-   lm_596 - 213_SIMP_F
-   lm_600 - 214_SIMP_M

```{r}
xtnMaster_blood <- read.csv("/home/rachelvoyt/Documents/UT-Grad/Development/repos/tamGenetics_primatesPeru/extractions/tamGenetics_xtnsBlood_master_updated22Aug2023.csv")

xtnMaster_blood_sampleNames <- xtnMaster_blood %>%
  select(c(sampleID, animalID, species, sex)) %>%
  dplyr::rename("sampleName" = "sampleID") %>%
  mutate(sample_md.xtn = str_c(animalID, species, sex, sep = "_")) %>%
  separate(., sampleName, into = c("sampleName", "sampleVersion_xtn"), "(?<=[0-9])(?=[a-z])") %>%
  select(c(sampleName, sampleVersion_xtn, sample_md.xtn)) %>%
  # ditch duplicates from second elution
  distinct()

dupSampleNames_blood_in_xtnMaster_blood <- xtnMaster_blood_sampleNames %>%
  filter(sampleName %in% dupSampleNames_blood$sampleName) %>%
  arrange(sampleName)
```

## 3.4 Check seq runs

### 3.4.1 tamRun5

#### dupSampleNames in run?

Looking at the longmire samples used in tamRun5, there are 8 samples where the longmire tube that was used has a duplicate number according to the original longmire log (so all of the samples that were extracted).

In my metadata records, I took note of whether the tube number included an "a" or "b" - while I originally thought this notation was to specify two different tubes from one individual, I'm now thinking that they correspond to the capture date, where the sample belonging to the individual with the earlier capture date has the "a" tube and the later-captured indvidual the "b" tube.

If this is the case, of the 8 tubes, I expect that 2 of the tubes have the correct metadata assigned while the other 6 do not. If these other 6 do indeed have the incorrect metadata assigned, I should be able to check this with species and sex assignments - 4 duplicates are across different species, 4 are across different sexes (2 duplicates are different across both species and sex).

```{r}
# reformat lm info for easier manipulation
tamRun5_blood_shortNames <- md_tamRun5_v1 %>%
  filter(str_detect(sampleName, "lm")) %>%
  mutate(
    sample_md.tamRun5 = str_c(animalID, species, sex, sep = "_")
  ) %>%
  select(c(sampleID, sampleName, sample_md.tamRun5)) %>%
  separate(., sampleName, into = c("sampleName", "sampleVersion_tamRun5"), "(?<=[0-9])(?=[a-z])")

# determine whether tubes used in tamRun5 are part of the set with duplicate numbers
dupSampleNames_blood_in_tamRun5 <- sampleLog_blood_shortNames %>%
  merge(., tamRun5_blood_shortNames, by = "sampleName", all.x = T) %>%
  na.omit() %>%
  relocate(sampleVersion_tamRun5, .after = sample_md.tamRun5) %>%
  mutate(
    dupType_sp = case_when(
      str_detect(sample_md.log1, "LWED") & str_detect(sample_md.log2, "LWED") ~ "sameSp_lwed",
      str_detect(sample_md.log1, "SIMP") & str_detect(sample_md.log2, "SIMP") ~ "sameSp_simp",
      str_detect(sample_md.log1, "LWED") & str_detect(sample_md.log2, "SIMP") | str_detect(sample_md.log1, "SIMP") & str_detect(sample_md.log2, "LWED") ~ "diffSp"
    ),
    dupType_sex = case_when(
      str_detect(sample_md.log1, "_F") & str_detect(sample_md.log2, "_F") ~ "sameSex_F",
      str_detect(sample_md.log1, "_M") & str_detect(sample_md.log2, "_M") ~ "sameSex_M",
      str_detect(sample_md.log1, "_F") & str_detect(sample_md.log2, "_M") | str_detect(sample_md.log1, "_M") & str_detect(sample_md.log2, "_F") ~ "diffSex"
    )
  ) %>%
  mutate(
    mismatchExpected_sp = case_when(
      sampleVersion_tamRun5 == "a" & sample_md.tamRun5 == sample_md.log1 ~ "no",
      sampleVersion_tamRun5 == "b" & sample_md.tamRun5 == sample_md.log2 ~ "no",
      str_detect(dupType_sp, "sameSp") ~ "no",
      .default = "yes"
    ),
    mismatchExpected_sex = case_when(
      sampleVersion_tamRun5 == "a" & sample_md.tamRun5 == sample_md.log1 ~ "no",
      sampleVersion_tamRun5 == "b" & sample_md.tamRun5 == sample_md.log2 ~ "no",
      str_detect(dupType_sex, "sameSex") ~ "no",
      .default = "yes"
    )
  ) %>%
  relocate(c(dupType_sp, dupType_sex), .after = sample_md.log2)

table(dupSampleNames_blood_in_tamRun5$mismatchExpected_sp)
table(dupSampleNames_blood_in_tamRun5$mismatchExpected_sex)
```

#### Species/sex (mis)matches

##### Genotypes

```{r}
# tamRun5 genotypes for dupSampleNames
genos_tamRun5_for_dupSampleNames_blood <- read.table("./05_tamRun5/03_run5GTscore/fullSet_polyGenResults_singleSNP_10x.txt", header = T) %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub('[_][^_]+$', '', locus)) %>%
  column_to_rownames("locus") %>%
  select(dupSampleNames_blood_in_tamRun5$sampleID)
```

##### Species assignments

From above: 8 dupTubes, expect incorrect species metadata for 4 of them

Results support this expectation - all 8 lm_dupTubes received species assignments with 100% of genotypes as either LWED or SIMP. Of these 8, 4 received assignments that mismatched the metadata and 4 received assignments that matched. For those that matched data, 2 belonged to dupTubes within species (one LWED, one SIMP) and 2 were not expected to have issues.

```{r}
source("./scripts/assignSpecies.R")

speciesKey <- read.csv("./03_tamRun3/04_genoAnalyses/speciesSNP_key_14Dec2022.csv")

tamRun5_spAssignments_for_dupSampleNames_blood <- assignSpecies(
  genos_tamRun5_for_dupSampleNames_blood,
  md_tamRun5_v1,
  speciesKey)

tamRun5_spAssignments.sampleLog_for_dupSampleNames_blood <- dupSampleNames_blood_in_tamRun5 %>%
  merge(., tamRun5_spAssignments_for_dupSampleNames_blood, by = "sampleID")
```

I'd also like to check if there were any blood samples w/species mismatches that were NOT part of the lm_dupTubes set -- turns out there are NO mismatches outside of those associated with the longmire duplicated tube numbers.

```{r}
bloodSamples_tamRun5 <- md_tamRun5_v1 %>%
  filter(sampleType == "blood") %>%
  select(sampleID) %>%
  arrange(sampleID)

genos_tamRun5_bloodSamples <- read.table("./05_tamRun5/03_run5GTscore/fullSet_polyGenResults_singleSNP_10x.txt", header = T) %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub('[_][^_]+$', '', locus)) %>%
  column_to_rownames("locus") %>%
  select(bloodSamples_tamRun5$sampleID)

spMismatches_bloodSamples <- assignSpecies(
  genos_tamRun5_bloodSamples,
  md_tamRun5_v1,
  speciesKey) %>%
  filter(mdMatch == "FALSE")
```

##### Sex assignments

From above: 8 dupTubes, expect incorrect sex metadata for 4 of them

Results support this expectation for all but one sample - all 8 dupSampleNames received sex assignments with 100% of genotypes as F or M (no mixes). Of these, 5 received assignments that mismatched the metadata - this was expected for 4 samples, but the 5th (tamRun5.067/196_LWED_F/212_SIMP_F) should have been assigned F but was instead assigned M.

```{r}
source("./scripts/assignSex.R")

primerList.v3 <- read.csv("./primers/03_lociChoices/tamGenetics_primerList_v3.csv")

sexKey <- read.csv("./03_tamRun3/04_genoAnalyses/sexSNP_key_8Dec2022.csv") %>%
  na.omit() %>%
  unique() %>%
  filter(Locus %in% primerList.v3$locus) %>%
  dplyr::rename("locus" = "Locus")

tamRun5_sexAssignments_for_dupSampleNames_blood <- assignSex(
  genos_tamRun5_for_dupSampleNames_blood,
  md_tamRun5_v1,
  sexKey)

tamRun5_sexAssignments.sampleLog_for_dupSampleNames_blood <- dupSampleNames_blood_in_tamRun5 %>%
  merge(., tamRun5_sexAssignments_for_dupSampleNames_blood, by = "sampleID")
```

###### tamRun5.067

It is possible that the sex mismatch for tamRun5.067/196_LWED_F/212_SIMP_F is related to the species-specific sex loci since this individual was listed in the original metadata as SIMP but I suspect is LWED (supported by spAssignments). After checking, though, the additional LWED-specific sex genotype also received an M assignment. Given that blood samples are expected to be chimeric, this isn't necessarily a cause for concern, but it's still something to keep in mind.

Looking back at the trapping sheet for 196_LWED_F (YPBL captureDate 6/13/17), I found the following: - confirmed that longmire sample tube number was listed as 586 - no notes present indicating potential contamination - noted as "young female", not previously microchipped

Assuming this was the LWED individual, she was trapped with 3 males - perhaps worth looking into potential contamination from one of these guys?

```{r}
# Check sampleID tamRun5.067
md_tamRun5.067 <- md_tamRun5_v1 %>%
  mutate(
    species = case_when(
      sampleID == "tamRun5.067" ~ "LWED",
      .default = species
    )
  )

tamRun5.067_sexAssignments_postSpUpdate <- assignSex(
  genos_tamRun5_bloodSamples,
  md_tamRun5.067,
  sexKey) %>%
  filter(sampleID == "tamRun5.067")
```

##### Update metadata

I'm updating the metadata for the 6 samples that appear to be from the other individual listed under their duplicate sample name/tube number. This includes tamRun5.067, whose species assignment aligns with the other metadata option though its sex assignment doesn't align with either metadata option.

Fields that will need updating: - captureDate - captureYear - group - animalName - species - sex

```{r}
# confirm that sp/sex assignments support updating
bloodSamples_confirmUpdate_tamRun5 <- dupSampleNames_blood_in_tamRun5 %>%
  select(-starts_with("dupType"), -starts_with("mismatch")) %>%
  mutate(
    update_md = case_when(
      sampleVersion_tamRun5 == "a" & sample_md.tamRun5 == sample_md.log1 ~ "no",
      sampleVersion_tamRun5 == "b" & sample_md.tamRun5 == sample_md.log2 ~ "no",
      .default = "yes"
    )
  ) %>%
  merge(., tamRun5_spAssignments_for_dupSampleNames_blood[, c("sampleID", "mdMatch")], by = "sampleID") %>%
  dplyr::rename("mdMatch_sp" = "mdMatch") %>%
  merge(., tamRun5_sexAssignments_for_dupSampleNames_blood[, c("sampleID", "mdMatch")]) %>%
  dplyr::rename("mdMatch_sex" = "mdMatch") %>%
  mutate(
    dupType_sp = case_when(
      str_detect(sample_md.log1, "LWED") & str_detect(sample_md.log2, "LWED") ~ "sameSp_lwed",
      str_detect(sample_md.log1, "SIMP") & str_detect(sample_md.log2, "SIMP") ~ "sameSp_simp",
      str_detect(sample_md.log1, "LWED") & str_detect(sample_md.log2, "SIMP") | str_detect(sample_md.log1, "SIMP") & str_detect(sample_md.log2, "LWED") ~ "diffSp"
    ),
    dupType_sex = case_when(
      str_detect(sample_md.log1, "_F") & str_detect(sample_md.log2, "_F") ~ "sameSex_F",
      str_detect(sample_md.log1, "_M") & str_detect(sample_md.log2, "_M") ~ "sameSex_M",
      str_detect(sample_md.log1, "_F") & str_detect(sample_md.log2, "_M") | str_detect(sample_md.log1, "_M") & str_detect(sample_md.log2, "_F") ~ "diffSex"
    )
  ) %>%
  mutate(
    mismatchExpected_sp = case_when(
      sampleVersion_tamRun5 == "a" & sample_md.tamRun5 == sample_md.log1 ~ "no",
      sampleVersion_tamRun5 == "b" & sample_md.tamRun5 == sample_md.log2 ~ "no",
      str_detect(dupType_sp, "sameSp") ~ "no",
      .default = "yes"
    ),
    mismatchExpected_sex = case_when(
      sampleVersion_tamRun5 == "a" & sample_md.tamRun5 == sample_md.log1 ~ "no",
      sampleVersion_tamRun5 == "b" & sample_md.tamRun5 == sample_md.log2 ~ "no",
      str_detect(dupType_sex, "sameSex") ~ "no",
      .default = "yes"
    )
  ) %>%
  select(c(sampleID, update_md, sampleName, sampleVersion_tamRun5, mismatchExpected_sp, mdMatch_sp, mismatchExpected_sex, mdMatch_sex, sample_md.tamRun5, sample_md.log1, sample_md.log2)) %>%
  arrange(desc(update_md))

# create df w/sampleIDs + updated md info
bloodSamples_toUpdate_tamRun5 <- bloodSamples_confirmUpdate_tamRun5 %>%
  filter(update_md == "yes") %>%
  mutate(
    sample_md.correct = case_when(
      sampleVersion_tamRun5 == "a" ~ sample_md.log1,
      sampleVersion_tamRun5 == "b" ~ sample_md.log2
    )
  ) %>%
  select(c(sampleID, sampleName, sample_md.correct)) %>%
  separate(sample_md.correct, into = c("animalID", "species", "sex")) %>%
  merge(., sampleLog_blood[, c("animalID", "sampleName", "captureDate", "groupName", "animalName")], by = c("sampleName", "animalID")) %>%
  dplyr::rename("group" = "groupName") %>%
  select(c(sampleID, animalID, captureDate, group, animalName, species, sex))

md_tamRun5_v2 <- md_tamRun5_v1 %>%
  rows_update(., bloodSamples_toUpdate_tamRun5, by = "sampleID") %>%
  mutate(
    sampleNotes = case_when(
      sampleID %in% bloodSamples_toUpdate_tamRun5$sampleID ~ str_c(sampleNotes, "duplicate sampleName exists for this sample, md has been updated to reflect correct indidual", sep = "; "),
      .default = sampleNotes
      )
  )

# Export
write.csv(md_tamRun5_v2, "./05_tamRun5/03_run5GTscore/metadata_tamRun5_updated15Feb2024.csv", row.names = F)
```

Note that for all six samples with updated metadata, other samples already exist in the run for their respective animalIDs.

```{r}
dupBloodSamples_tamRun5_postUpdate <- md_tamRun5_v2 %>%
  select(c(animalID, sampleType)) %>%
  filter(sampleType == "blood") %>%
  group_by(animalID) %>%
  filter(n()>1) %>%
  distinct() %>%
  arrange(as.numeric(animalID))
```

### 3.4.2 tamRun4

#### dupSampleNames in run?

In tamRun4, there is only 1 sample where the longmire tube that was used has a duplicate number according to the original longmire log.

Because the sample tube was the "a" version, however, it may not be an issue -- assuming of course that version "a" corresponds to the earlier capture date, which corresponds to the SIMP individual. Since the other option is an LWED individual though, we can do a species assignment check to be sure.

```{r}
# reformat lm info for easier manipulation
tamRun4_blood_shortNames <- md_tamRun4 %>%
  filter(str_detect(sampleName, "lm")) %>%
  mutate(
    sampleName = gsub("lm_", "", sampleName),
    sample_md.tamRun4 = str_c(animalID, species, sex, sep = "_")
  ) %>%
  select(c(sampleID_ill, sampleName, sample_md.tamRun4)) %>%
  separate(., sampleName, into = c("sampleName", "sampleName.tamRun4_version"), "(?<=[0-9])(?=[a-z])")

# determine whether tubes used in tamRun5 are part of the set with duplicate numbers
dupSampleNames_blood_in_tamRun4 <- sampleLog_blood_shortNames %>%
  merge(., tamRun4_blood_shortNames, by = "sampleName", all.x = T) %>%
  na.omit() %>%
  relocate(sampleName.tamRun4_version, .after = sample_md.tamRun4) %>%
  mutate(
    dupType_sp = case_when(
      str_detect(sample_md.log1, "LWED") & str_detect(sample_md.log2, "LWED") ~ "sameSp_lwed",
      str_detect(sample_md.log1, "SIMP") & str_detect(sample_md.log2, "SIMP") ~ "sameSp_simp",
      str_detect(sample_md.log1, "LWED") & str_detect(sample_md.log2, "SIMP") | str_detect(sample_md.log1, "SIMP") & str_detect(sample_md.log2, "LWED") ~ "diffSp"
    ),
    dupType_sex = case_when(
      str_detect(sample_md.log1, "_F") & str_detect(sample_md.log2, "_F") ~ "sameSex_F",
      str_detect(sample_md.log1, "_M") & str_detect(sample_md.log2, "_M") ~ "sameSex_M",
      str_detect(sample_md.log1, "_F") & str_detect(sample_md.log2, "_M") | str_detect(sample_md.log1, "_M") & str_detect(sample_md.log2, "_F") ~ "diffSex"
    )
  ) %>%
  mutate(
    mismatchExpected_sp = case_when(
      sampleName.tamRun4_version == "a" & sample_md.tamRun4 == sample_md.log1 ~ "no",
      sampleName.tamRun4_version == "b" & sample_md.tamRun4 == sample_md.log2 ~ "no",
      str_detect(dupType_sp, "sameSp") ~ "no",
      .default = "yes"
    ),
    mismatchExpected_sex = case_when(
      sampleName.tamRun4_version == "a" & sample_md.tamRun4 == sample_md.log1 ~ "no",
      sampleName.tamRun4_version == "b" & sample_md.tamRun4 == sample_md.log2 ~ "no",
      str_detect(dupType_sex, "sameSex") ~ "no",
      .default = "yes"
    )
  ) %>%
  relocate(c(dupType_sp, dupType_sex), .after = sample_md.log2) %>%
  mutate(
    sampleID = sampleID_ill
  )

table(dupSampleNames_blood_in_tamRun4$mismatchExpected_sp)
table(dupSampleNames_blood_in_tamRun4$mismatchExpected_sex)
```

#### Species/sex (mis)matches

##### Genotypes

```{r}
# tamRun5 genotypes for dupSampleNames
genos_tamRun4_for_dupSampleNames_blood <- read.table("./04_tamRun4/00_illumina/03_run4GTscore/ill_fullSet_polyGenResults_singleSNP_10x.txt", header = T) %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub('[_][^_]+$', '', locus)) %>%
  column_to_rownames("locus") %>%
  select(dupSampleNames_blood_in_tamRun4$sampleID_ill)
```

##### Species assignments

From above: 1 dupSampleName, do NOT expect mismatch

As expected, there was no mismatch between the species specified in the metadata and the species assigned. As such, the original metadata for this sample appears to be correct.

```{r}
source("./scripts/assignSpecies.R")

speciesKey <- read.csv("./03_tamRun3/04_genoAnalyses/speciesSNP_key_14Dec2022.csv")

tamRun4_spAssignments_for_dupSampleNames_blood <- assignSpecies(
  genos_tamRun4_for_dupSampleNames_blood,
  seqType = "ill",
  md_tamRun4,
  speciesKey)
```

I'd also like to check if there were any blood samples w/species mismatches that were NOT part of the blood_dupSampleNames set -- turns out there are NO species mismatches, which is good!

```{r}
bloodSamples_tamRun4 <- md_tamRun4 %>%
  filter(sampleType == "blood") %>%
  select(sampleID_ill) %>%
  arrange(sampleID_ill)

genos_tamRun4_bloodSamples <- read.table("./04_tamRun4/00_illumina/03_run4GTscore/ill_fullSet_polyGenResults_singleSNP_10x.txt", header = T) %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub('[_][^_]+$', '', locus)) %>%
  column_to_rownames("locus") %>%
  select(bloodSamples_tamRun4$sampleID_ill)

tamRun4_spMismatches_bloodSamples <- assignSpecies(
  genos_tamRun4_bloodSamples,
  seqType = "ill",
  md_tamRun4,
  speciesKey) %>%
  filter(mdMatch == "FALSE")
```

##### Sex assignments

From above: 1 dupSampleName, do NOT expect incorrect sex metadata

Sex assignment checks support this, with all genotypes assigned M (which matches metadata for this sample).

```{r}
source("./scripts/assignSex.R")

primerList.v3 <- read.csv("./primers/03_lociChoices/tamGenetics_primerList_v3.csv")

sexKey <- read.csv("./03_tamRun3/04_genoAnalyses/sexSNP_key_8Dec2022.csv") %>%
  na.omit() %>%
  unique() %>%
  filter(Locus %in% primerList.v3$locus) %>%
  dplyr::rename("locus" = "Locus")

tamRun4_sexAssignments_for_dupSampleNames_blood <- assignSex(
  genos_tamRun4_for_dupSampleNames_blood,
  md_tamRun4,
  sexKeyFile)

tamRun4_sexAssignments.sampleLog_for_dupSampleNames_blood <- dupSampleNames_blood_in_tamRun4 %>%
  merge(., tamRun4_sexAssignments_for_dupSampleNames_blood, by = "sampleID")
```

#### Update metadata

No need - the one sample that could have been an issue appears to be associated with the correct metadata.

# 5 Hair samples

## 5.1 Original sample log

```{r}
sampleLog_hair <- read.csv("./sampleOrganization/originalData/hairSamples_CICRA_2013-2019.csv") %>%
  filter(species %in% c("SFUS", "SIMP"))%>%
  mutate(
    species = case_when(
      species == "SFUS" ~ "LWED",
      .default = species
    )
  )
```

## 5.2 Find duplicated sampleIDs

From the original hair envelope log, there are 11 envelope numbers that are duplicated, with no numbers arising more than twice. This includes:

-   9 envelope numbers duplicated across species (one copy for LWED, one for SIMP)
-   1 envelope number duplicated within LWED individuals (one number for two different LWED individuals)
-   1 envelope number duplicated within SIMP individuals (one number for two different LWED individuals)

I have notes on all of these except for env_301 in sampleNotes_RV.docx, but my md_tamRun5 sampleNotes suggests that I found the env_301 duplicate as well - I included both 301 envelopes in my study. There are additional details on that document, but the summary I gave is as follows:

"A handful of samples from 2017 share an envelope number, and in some cases the dates/names may be switched between them (based on dates listed in the AllCaptures_2019 file and the hair sample files). For the samples that we need, I took the envelope that matched all other info but the date. The other samples I put in a separate bag within the original 2017 bag."

```{r}
# reformat lm info for easier manipulation; first md record (sample_md.log1) belongs to the first indiv captured according to captureDate

sampleLog_hair_shortNames <- sampleLog_hair %>%
  # sort by capture date
  arrange(envelopeNo., captureDate) %>%
mutate(
    sample_md = str_c(animalID, species, sex, sep = "_")
  ) %>%
  select(c("envelopeNo.", "sample_md")) %>%
  dplyr::rename("sampleName" = "envelopeNo.") %>%
  group_by(sampleName) %>%
  mutate(row_n = row_number()) %>%
  pivot_wider(id_cols = sampleName,
              names_from = row_n,
              values_from = sample_md,
              names_glue = "sample_md.log{row_n}")

# find duplicated tube numbers & determine dup type (same sp or diff sp)
dupSampleNames_hair <- sampleLog_hair_shortNames %>%
  na.omit() %>%
  mutate(
    dupType = case_when(
      str_detect(sample_md.log1, "LWED") & str_detect(sample_md.log2, "LWED") ~ "sameSp_lwed",
      str_detect(sample_md.log1, "SIMP") & str_detect(sample_md.log2, "SIMP") ~ "sameSp_simp",
      str_detect(sample_md.log1, "LWED") & str_detect(sample_md.log2, "SIMP") | str_detect(sample_md.log1, "SIMP") & str_detect(sample_md.log2, "LWED") ~ "diffSp"
    )
  )

# table of dup types (same sp, diff sp)
table(dupSampleNames_hair$dupType)
```

## 5.3 Check seqRuns

### 5.3.1 tamRun5

Looking at the envelope samples used in tamRun5, there are 5 samples where the envelope that was used has a duplicate number according to the original envelope log.

In this case, there is no a/b versions, and the envelopes did have metadata written on them - however, given the discrepancies I found between what was written on the envelopes and what was recorded in the sample log file, I think they're worth looking into.

```{r}
# reformat lm info for easier manipulation
tamRun5_hair_shortNames <- md_tamRun5 %>%
  filter(str_detect(sampleName, "env")) %>%
  mutate(
    sampleName = gsub("env_", "", sampleName),
    sample_md.tamRun5 = str_c(animalID, species, sex, sep = "_")
  ) %>%
  select(c(sampleID, sampleName, sample_md.tamRun5))

# determine whether tubes used in tamRun5 are part of the set with duplicate numbers
dupSampleNames_hair_in_tamRun5 <- sampleLog_hair_shortNames %>%
  merge(., tamRun5_hair_shortNames, by = "sampleName", all.x = T) %>%
  na.omit() %>%
  mutate(
    dupType = case_when(
      str_detect(sample_md.log1, "LWED") & str_detect(sample_md.log2, "LWED") ~ "sameSp_lwed",
      str_detect(sample_md.log1, "SIMP") & str_detect(sample_md.log2, "SIMP") ~ "sameSp_simp",
      str_detect(sample_md.log1, "LWED") & str_detect(sample_md.log2, "SIMP") | str_detect(sample_md.log1, "SIMP") & str_detect(sample_md.log2, "LWED") ~ "diffSp"
    )
  ) %>%
  relocate(dupType, .after = sample_md.log2)
```

### Species/sex (mis)matches

#### Genotypes

```{r}
# tamRun5 genotypes for lm_dupTubes
genos_tamRun5_for_dupSampleNames_hair <- read.table("./05_tamRun5/03_run5GTscore/fullSet_polyGenResults_singleSNP_10x.txt", header = T) %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub('[_][^_]+$', '', locus)) %>%
  column_to_rownames("locus") %>%
  select(dupSampleNames_hair_in_tamRun5$sampleID)
```

#### Species assignments

Of the 5 hair samples with duplicate envelope numbers, 4 received species assignments. All of these assignments aligned with metadata.

```{r}
source("./scripts/assignSpecies.R")

md_tamRun5_sampleID_ill <- md_tamRun5 %>%
  dplyr::rename("sampleID_ill" = "sampleID")

speciesKey <- read.csv("./03_tamRun3/04_genoAnalyses/speciesSNP_key_14Dec2022.csv")

spAssignments_for_dupSampleNames_hair <- assignSpecies(
  genos_tamRun5_for_dupSampleNames_hair,
  md_tamRun5_v1,
  speciesKey)
```

There are, however, 5 hair samples with species assignment mismatches that are NOT related to duplicate numbers. All 5 samples are LWED according to metadata, but all genotypes read as SIMP. Only one of these samples was a fresh extraction, and it had 3 genotypes total. The other four were extracted in 2014/2015 and had one species genotype apiece.

Of note, the 4 previously extracted samples look like they represent two twin pairs.

```{r}
hairSamples_tamRun5 <- md_tamRun5_v1 %>%
  filter(sampleType == "hair") %>%
  select(sampleID) %>%
  arrange(sampleID)

genos_tamRun5_hairSamples <- read.table("./05_tamRun5/03_run5GTscore/fullSet_polyGenResults_singleSNP_10x.txt", header = T) %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub('[_][^_]+$', '', locus)) %>%
  column_to_rownames("locus") %>%
  select(hairSamples_tamRun5$sampleID)

spMismatches_hairSamples <- assignSpecies(
  genos_tamRun5_hairSamples,
  md_tamRun5_v1,
  speciesKey) %>%
  filter(mdMatch == "FALSE")

md_spMismatches_hair <- md_tamRun5 %>%
  filter(sampleID %in% spMismatches_hairSamples$sampleID) %>%
  arrange(sampleID)
```

#### Sex assignments

All sex assignments for the 5 hair samples with duplicate envelope numbers also align with metadata.

```{r}
tamRun5_sexAssignments_for_dupSampleNames_hair <- assignSex(
  genos_tamRun5_for_dupSampleNames_hair,
  md_tamRun5,
  sexKeyFile)
```

tamRun5.228 (md = F; 2 loci called as M) - the two loci w/M calls were SEXID_200 and SEXID_SIMP_218 -- the first had allele1 ratio of 0.875 and the latter had allele1 ratio of 0.842... which in a geno-calling system using ratios would lead to an F call

tamRun5.245 - loci w/F call was SEXID_SIMP_218; allele1 ratio of 0.915, which feels more legit for an F call

```{r}
sexMismatches_hairSamples <- assignSex(
  genos_tamRun5_hairSamples,
  md_tamRun5_v1,
  sexKey) %>%
  filter(mdMatch == "FALSE") %>%
  merge(., md_tamRun5[, c("sampleID", "sex")], by = "sampleID") %>%
  dplyr::rename("sex_md" = "sex") %>%
  relocate("sex_md", .after = "sexAssigned") %>%
  mutate(
    majoritySex = case_when(
      propF > 0.5 ~ "F",
      propM > 0.5 ~ "M",
      propF == 0.5 ~ "split"
    )
  ) %>%
  relocate("majoritySex", .after = "sex_md")

md_sexMismatches_hair <- md_tamRun5_v1 %>%
  filter(sampleID %in% sexMismatches_hairSamples$sampleID) %>%
  arrange(sampleID)

readCounts_tamRun5 <- 
```

#### tamRun5.280/189_LWED_M

tamRun5.280/189_LWED_M is mismatched at both species and sex - all 3 genotyped species loci = SIMP and both sex loci (general sex loci) = F. Furthermore, looking back at the original genotype file, this individual was also genotyped as F for two SIMP-specific sex loci. These results suggest that that this individual is SIMP_F vs. LWED_M.

xtnPlate = p3.H11 - p3.H12/tamRun5.288 = SIMP_F - p3.G12/tamRun5.287 = SIMP_F - p3.H10 = SIMP_M - p3.G11 = SIMP_M - p3.G10 = LWED_F

env_563, lysis t28, capture date 6/18/2019

trapping report confirms env_563 for 189_LWED_M

# 6 capData_byIndiv checks

## 6.1 Data

I also want to ensure that my metadata is consistent with the full set of cleaned individual capture data (see tamGenetics_paper3_dataOrganization.Rmd for details). I'm using the latest cleaned versions of each file, those being md_tamRun5_v2 (updated 15 Feb 2024 in the current document) and capData_byIndiv_v5.

```{r}
capData_byIndiv <- read.csv("./paper3_demographics/01_dataOrganization/02_dataCleaning/captureData_byIndividual_v5.csv")

animalID_mdShort_masterList <- capData_byIndiv %>%
  filter(!str_detect(animalID, "UNK")) %>%
  mutate(
    mdShort = str_c(animalID, species, sex, sep = "_")
  ) %>%
  select(animalID, mdShort) %>%
  distinct() %>%
  arrange(as.numeric(animalID))

md_tamRun5_v2 <- read.csv("./metadataReconciliation/metadata_tamRun5_updated15Feb2024.csv")
```

## 6.2 Species/sex checks

### Assess

First I'm checking that the species and sex for each animalID is consistent with what's in capData - we see that **535_LWED_M** is the only metadata entry that is NOT in the cleaned capData_byIndiv. This makes sense though, because it was only during my cleaning of capData microchips that I discovered that animalID 535 was the same individual as animalID 234 - I should be able to confirm this with the genetics results.

```{r}
capData_byIndiv_spSex <- capData_byIndiv %>%
  select(animalID, species, sex) %>%
  # create combo variable
  mutate(
    combo = str_c(animalID, species, sex, sep = "_")
  )

md_tamRun5_spSex <- md_tamRun5_v2 %>%
  select(animalID, species, sex) %>%
  # create combo variable
  mutate(
    combo = str_c(animalID, species, sex, sep = "_")
  ) %>%
  # check if exists in capData
  mutate(
    in_capData = case_when(
      combo %in% capData_byIndiv_subset$combo ~ "yes",
      .default = "no"
    )
  ) %>%
  distinct() %>%
  # filter to those that are NOT in capData
  filter(in_capData == "no")
```

### Update: md_tamRun5_v3

```{r}
md_tamRun5_v3 <- md_tamRun5_v2 %>%
  # select columns of interest to make things more manageable; will add the rest back at the end
  select(sampleID, animalID, sampleType, sampleName, sampleNotes, fieldNotes, captureDate, captureYear, group, animalName, species, sex) %>%
  mutate(
    # add notes to address updates
    notes_mdReconciliation = case_when(
      as.character(animalID) == "535" ~ "animalID 234 & 535 are the SAME indiv - this entry was originally listed as 535 (changed to 234)",
      .default = NA
    ),
    # change animalID 535 to 234
    animalID = case_when(
      as.character(animalID) == "535" ~ "234",
      .default = as.character(animalID)
    )
  )
```

### Export md_tamRun5_v3

```{r}
# full set metadata
write.csv(md_tamRun5_v3, "./metadataReconciliation/metadata_tamRun5_v3.csv", row.names = F)
```

# 7 captureData_samples checks

## 7.1

```{r}
capData_samples <- read.csv("./metadataReconciliation/captureData_samples_15May2024.csv", na.strings = c("", "NA"))

# blood samples
capData_samplesBlood <- capData_samples %>%
  select(rowID, animalID, samplesLongmire) %>%
  na.omit() %>%
  separate("samplesLongmire", into = c("lm1", "lm2", "lm3", "lm4", "lm5"), sep = ", ") %>%
  pivot_longer(!c(rowID, animalID),
               names_to = "lm_version",
               values_to = "sampleName") %>%
  na.omit() %>%
  select(-lm_version) %>%
  mutate(sampleName = str_c("lm_", sampleName))

# hair samples
capData_samplesHair <- capData_samples %>%
  select(rowID, animalID, samplesHairDNA) %>%
  dplyr::rename("sampleName" = "samplesHairDNA") %>%
  na.omit() %>%
  arrange(as.numeric(animalID)) %>%
  mutate(sampleName = str_c("env_", sampleName))

# full list
samples_capData <- rbind(capData_samplesBlood, capData_samplesHair)

# dup sample names
capData_sampleNames_dupes <- samples_capData %>%
  get_dupes(sampleName) %>%
  select(rowID, animalID, sampleName, dupe_count)

capData_sampleNames_dupes_blood <- capData_sampleNames_dupes %>%
  filter(str_detect(sampleName, "lm"))

capData_sampleNames_dupes_hair <- capData_sampleNames_dupes %>%
  filter(str_detect(sampleName, "env"))


# TOTAL DUPES
## 41 blood sampleName dupes
capData_sampleNames_dupes_blood %>%
  select(sampleName) %>%
  distinct() %>%
  nrow()

## hair = 17 sample names
capData_sampleNames_dupes_hair %>%
  select(sampleName) %>%
  distinct() %>%
  nrow()
```

```{r}
test <- md_tamRun5_v3 %>%
  select(animalID, sampleName) %>%
  na.omit() %>%
  mutate(
    sampleName = case_when(
      str_detect(sampleName, "a") ~ gsub("a", "", sampleName),
      str_detect(sampleName, "b") ~ gsub("b", "", sampleName),
      .default = sampleName
    )
  ) %>%
  mutate(
    in_dupList = case_when(
      sampleName %in% capData_sampleNames_dupes$sampleName ~ "yes",
      .default = "no"
    )
  ) %>%
  filter(in_dupList == "yes")

md_tamRun5_v3_cleanSampleNames <- md_tamRun5_v3 %>%
  select(animalID, sampleName) %>%
  na.omit() %>%
  mutate(
    sampleName = case_when(
      str_detect(sampleName, "a") ~ gsub("a", "", sampleName),
      str_detect(sampleName, "b") ~ gsub("b", "", sampleName),
      .default = sampleName
    )
  )

dupSampleNames_in_tamRun5 <- capData_sampleNames_dupes %>%
  filter(sampleName %in% md_tamRun5_v3_cleanSampleNames$sampleName) %>%
  select(sampleName, animalID) %>%
  merge(., md_tamRun5_v3_cleanSampleNames[, c("sampleName", "animalID")], by = "sampleName", all.x = T) %>%
  dplyr::rename("animalID_alt" = "animalID.x",
                "animalID_md" = "animalID.y") %>%
  mutate(
    animalID_md = case_when(
      animalID_alt == animalID_md ~ NA,
      .default = animalID_md
    )
  ) %>%
  na.omit() %>%
  relocate(animalID_md, .before = animalID_alt)
```

## 7.1 Assess

```{r}
md_tamRun5_v3_sampleNameChecks <- md_tamRun5_v3 %>%
  arrange(captureYear, group, animalName) %>%
  mutate(sampleName_correct = NA) %>%
  select(sampleID, sampleType, captureDate, captureYear, group, animalID, animalName, sampleName, sampleName_correct, sampleNotes, fieldNotes, species, sex) %>%
  mutate(
    sampleName_correct = case_when(
      # 2013
      animalName == "OBG" & sampleName == "lm_75" ~ "yes",
      animalName == "OBG" & sampleName == "env_27" ~ "no; animalID 98/OBG captureDate 7/06/2013 has env_33 - animalID 27/OBL has env_27",
      
      animalName == "OBO" & sampleName == "lm_91" ~ "yes",
      animalName == "OBO" & sampleName == "env_32" ~ "no; animalID 69/OBO captureDate 7/06/2013 has env_28 - animalID 26/OBY has env_32",
      
      animalName == "OBW" & sampleName == "lm_78" ~ "yes",
      animalName == "OBW" & sampleName == "env_28" ~ "no; animalID 70/OBW captureDate 7/06/2013 has env_29 - animalID 69/OBO has env_28",
      
      animalName == "YBO" & sampleName == "lm_42" ~ "yes",
      animalName == "YBO" & sampleName == "env_21" ~ "yes",
      
      animalName == "YBS" & sampleName == "lm_49" ~ "yes",
      animalName == "YBS" & sampleName == "env_17" ~ "yes",
      
      animalName == "BLBY3" & sampleName == "env_66" ~ "yes",
      animalName == "BLBY3" & sampleName == "lm_196" ~ "yes",
      
      animalName == "YBG2" & sampleName == "lm_211" ~ "yes",
      animalName == "YBG2" & sampleName == "env_71" ~ "yes",
      
      animalName == "YBR2" & sampleName == "lm_208" ~ "yes",
      animalName == "YBR2" & sampleName == "env_73" ~ "yes",
        
      animalName == "YPO" & sampleName == "lm_217" ~ "yes",
      animalName == "YPO" & sampleName == "env_74" ~ "yes",
      
      animalName == "YPS" & sampleName == "lm_214" ~ "yes",
      animalName == "YPS" & sampleName == "env_72" ~ "yes",
         
      animalName == "GBR2" & sampleName == "lm_19" ~ "yes",
      animalName == "GBR2" & sampleName == "env_6" ~ "yes",
     
      animalName == "GPBL/GRC" & sampleName == "lm_13" ~ "yes",
      animalName == "GPBL/GRC" & sampleName == "env_7" ~ "yes",
      
      animalName == "RBS" & sampleName == "lm_106" ~ "yes",
      
      animalName == "RBW" & sampleName == "lm_97" ~ "yes",
     
      animalName == "RPG/RRC" & sampleName == "lm_100" ~ "yes",
      
      animalName == "RPL" & sampleName == "lm_103" ~ "yes",
        
      animalName == "RBBL" & sampleName == "lm_112" ~ "yes",
      animalName == "RBBL" & sampleName == "env_42" ~ "yes",
         
      animalName == "RBY" & sampleName == "lm_109" ~ "yes",
      animalName == "RBY" & sampleName == "env_43" ~ "yes",
           
      animalName == "GBW" & sampleName == "lm_1" ~ "yes",
      animalName == "GBW" & sampleName == "env_4" ~ "yes",
           
      animalName == "LRC" & sampleName == "lm_4" ~ "yes",
      animalName == "LRC" & sampleName == "env_1" ~ "yes",
         
      animalName == "LBO" & sampleName == "lm_154" ~ "yes",
      animalName == "LBO" & sampleName == "env_60" ~ "yes",
        
      animalName == "LBR" & sampleName == "lm_166" ~ "yes",
      animalName == "LBR" & sampleName == "env_58" ~ "yes",
         
      animalName == "LBS" & sampleName == "lm_172" ~ "yes",
      animalName == "LBS" & sampleName == "env_53" ~ "yes",
         
      animalName == "LBY" & sampleName == "lm_157" ~ "yes",
         
      animalName == "LPL" & sampleName == "lm_169" ~ "yes",
      animalName == "LPL" & sampleName == "env_56" ~ "UNK; animalID 52/LPL captureDate 7/15/2013 has env_54, but animalID 50/LPBL on same date also has env_54 - no indiv captured that day has env_56",
        
      animalName == "SBR" & sampleName == "lm_151" ~ "yes",
      animalName == "SBR" & sampleName == "env_51" ~ "yes",
         
      animalName == "SBY" & sampleName == "lm_148" ~ "yes",
      animalName == "SBY" & sampleName == "env_50" ~ "yes",
         
      animalName == "YBW" & sampleName == "lm_27" ~ "yes",
      animalName == "YBW" & sampleName == "env_10" ~ "yes",
       
      animalName == "YPO2" & sampleName == "lm_24" ~ "yes",
      animalName == "YPO2" & sampleName == "env_13" ~ "UNK; trapping sheet has question mark, but no other indivs in grp have that env name",
      
      animalName == "WBL" & sampleName == "lm_127" ~ "yes",
      animalName == "WBL" & sampleName == "env_49" ~ "yes",
        
      animalName == "WBS" & sampleName == "lm_130" ~ "yes",
      animalName == "WBS" & sampleName == "env_45" ~ "yes",
       
      # 2014
      animalName == "GBW2" & sampleName == "lm_246" ~ "yes",
      animalName == "GBW2" & sampleName == "env_87" ~ "yes",
        
      animalName == "OBS" & sampleName == "lm_248" ~ "yes",
      animalName == "OBS" & sampleName == "env_88" ~ "yes",
   
      animalName == "OPG/ORC2" & sampleName == "lm_244" ~ "yes",
      animalName == "OPG/ORC2" & sampleName == "env_89" ~ "yes",
        
      animalName == "YBG" & sampleName == "lm_337" ~ "yes",
      animalName == "YBG" & sampleName == "env_131" ~ "yes",
     
      animalName == "BLPBL2" & sampleName == "lm_302" ~ "yes",
      animalName == "BLPBL2" & sampleName == "env_113" ~ "yes",
       
      animalName == "BLPG" & sampleName == "lm_296" ~ "yes",
      animalName == "BLPG" & sampleName == "env_109" ~ "yes",
       
      animalName == "BLPW" & sampleName == "lm_290" ~ "yes",
      animalName == "BLPW" & sampleName == "env_110" ~ "yes",
       
      animalName == "RPBL" & sampleName == "lm_304" ~ "yes",
      animalName == "RPBL" & sampleName == "env_121" ~ "yes",
       
      animalName == "LPBL" & sampleName == "lm_326" ~ "yes",
      animalName == "LPBL" & sampleName == "env_126" ~ "yes",
        
      animalName == "LBO" & sampleName == "env_77" ~ "yes",
      animalName == "LBO" & sampleName == "lm_222" ~ "yes",
      
      animalName == "BLBY2" & sampleName == "lm_260" ~ "yes",
      animalName == "BLBY2" & sampleName == "env_92" ~ "yes",
        
      animalName == "WBW" & sampleName == "lm_256" ~ "yes",
      animalName == "WBW" & sampleName == "env_94" ~ "yes",
      
      animalName == "WPO/WRC" & sampleName == "lm_262" ~ "yes",
      animalName == "WPO/WRC" & sampleName == "env_91" ~ "yes",
      
      # 2015
      animalName == "YPBL" & sampleName == "lm_421" ~ "yes",
      animalName == "YPBL" & sampleName == "env_185" ~ "yes",
       
      animalName == "BLPR" & sampleName == "lm_367" ~ "yes",
      animalName == "BLPR" & sampleName == "env_148" ~ "yes",
        
      animalName == "LPR" & sampleName == "lm_354" ~ "yes",
      animalName == "LPR" & sampleName == "env_141" ~ "yes",
        
      animalName == "LRC" & sampleName == "lm_350" ~ "UNK; trapping sheet lists 515, 551 then right below in yellow highlight has 550??, 551 - fieldNotes say to check on VR number was wrong on trapping sheet - perhaps referring to this? All other indivs here have longmire sampleNames around 350ish though, so 350 makes more sense than 550. Also - found lm_515 with animalID 167/RBG captureDate 6/28/2016 & lm_550 with animalID 179/LRC_LPY captureDate 6/09/2017",
      animalName == "LRC" & sampleName == "env_139" ~ "yes",
      
      animalName == "BLBR" & sampleName == "env_170" ~ "yes",
      animalName == "BLBR" & sampleName == "lm_397" ~ "yes",
       
      animalName == "RBR2" & sampleName == "lm_429" ~ "yes",
      animalName == "RBR2" & sampleName == "env_180" ~ "yes",
        
      animalName == "LBS" & sampleName == "lm_438" ~ "yes",
      animalName == "LBS" & sampleName == "env_196" ~ "yes",
        
      animalName == "SPO" & sampleName == "lm_414" ~ "UNK; animalID 45/SPO has lm_415 and trapping report says only got 1 weak longmire sample; found lm_415 also assigned to animalID 15/YRC/SPS",
      animalName == "SPO" & sampleName == "env_177" ~ "yes",
        
      animalName == "OPW" & sampleName == "lm_373" ~ "yes",
      animalName == "OPW" & sampleName == "env_151" ~ "yes",
        
      animalName == "OPY" & sampleName == "lm_369" ~ "yes",
      animalName == "OPY" & sampleName == "env_156" ~ "yes",
      
      animalName == "BLBL" & sampleName == "env_162" ~ "yes",
      
      animalName == "BLBW2" & sampleName == "lm_395" ~ "yes",
      animalName == "BLBW2" & sampleName == "env_164" ~ "yes",
      
      animalName == "LBR2" & sampleName == "lm_388" ~ "yes",
      animalName == "LBR2" & sampleName == "env_166" ~ "yes",
      
      animalName == "LBS2" & sampleName == "lm_387" ~ "yes",
      animalName == "LBS2" & sampleName == "env_165" ~ "yes",
       
      animalName == "LBY2" & sampleName == "lm_386" ~ "yes",
      animalName == "LBY2" & sampleName == "env_167" ~ "yes",
    
      animalName == "LPG/RC" & sampleName == "env_163" ~ "yes",
   
      animalName == "LPW/LRC2" & sampleName == "lm_390" ~ "yes",
      animalName == "LPW/LRC2" & sampleName == "env_161" ~ "yes",
       
      animalName == "SPL2" & sampleName == "lm_383" ~ "UNK; animalID 164/SPL has lm_382, but so does animalID 144/SBS - no other indiv has lm_383",
      animalName == "SPL2" & sampleName == "env_157" ~ "yes",
       
      animalName == "YBG" & sampleName == "lm_434" ~ "yes",
      animalName == "YBG" & sampleName == "env_191" ~ "yes",
        
      animalName == "YRC" & sampleName == "lm_430" ~ "yes",
      animalName == "YRC" & sampleName == "env_190" ~ "yes",
      
      # 2016
      animalName == "YBW" & sampleName == "lm_527" ~ "yes",
      animalName == "YBW" & sampleName == "env_255" ~ "yes",
        
      animalName == "LBL" & sampleName == "lm_460" ~ "yes",
      animalName == "LBL" & sampleName == "env_205" ~ "yes",
        
      animalName == "GBS" & sampleName == "lm_464" ~ "yes",
      animalName == "GBS" & sampleName == "env_213" ~ "yes",
        
      animalName == "GPG" & sampleName == "lm_505" ~ "yes",
      animalName == "GPG" & sampleName == "env_251" ~ "yes",
    
      animalName == "GRC/GPO" & sampleName == "lm_466" ~ "yes",
      animalName == "GRC/GPO" & sampleName == "env_208" ~ "yes",
        
      animalName == "RBG" & sampleName == "lm_515" ~ "yes",
      animalName == "RBG" & sampleName == "env_242" ~ "yes",
        
      animalName == "RPW" & sampleName == "lm_517" ~ "yes",
      animalName == "RPW" & sampleName == "env_243" ~ "yes",
        
      animalName == "RPY" & sampleName == "lm_516" ~ "yes",
      animalName == "RPY" & sampleName == "env_241" ~ "yes",
       
      animalName == "LBY" & sampleName == "env_226" ~ "yes",
       
      animalName == "LPR" & sampleName == "env_228" ~ "yes",
        
      animalName == "OBO" & sampleName == "lm_524" ~ "yes",
      animalName == "OBO" & sampleName == "env_247" ~ "yes",
        
      animalName == "SBW" & sampleName == "lm_493" ~ "yes",
      animalName == "SBW" & sampleName == "env_233" ~ "yes",
        
      animalName == "SBG" & sampleName == "lm_540" ~ "yes",
      animalName == "SBG" & sampleName == "env_260" ~ "yes",
       
      animalName == "WBR" & sampleName == "env_258" ~ "yes",
        
      animalName == "WBY" & sampleName == "lm_481" ~ "yes",
      animalName == "WBY" & sampleName == "env_224" ~ "yes",
    
      animalName == "WPR/WRC" & sampleName == "lm_483" ~ "yes",
      animalName == "WPR/WRC" & sampleName == "env_220" ~ "yes",

      animalName == "WPS2" & sampleName == "lm_482" ~ "yes",
      animalName == "WPS2" & sampleName == "env_221" ~ "yes",
      
      # 2017
      animalName == "OBL" & sampleName == "lm_600a" ~ "yes",
      
      animalName == "OBR3" & sampleName == "lm_592a" ~ "yes",
       
      animalName == "YBL" & sampleName == "env_313" ~ "yes",
      
      animalName == "YBR" & sampleName == "env_312" ~ "yes",
       
      animalName == "WBL" & sampleName == "env_269" ~ "yes",
        
      animalName == "WPR" & sampleName == "lm_630" ~ "yes",
      animalName == "WPR" & sampleName == "env_314" ~ "yes",
       
      animalName == "WPY" & sampleName == "env_270" ~ "yes",
       
      animalName == "WRC" & sampleName == "env_266" ~ "yes",
      
      animalName == "GBL" & sampleName == "lm_583a" ~ "yes",
      animalName == "GBL" & sampleName == "env_278" ~ "yes",
      
      animalName == "LBR" & sampleName == "lm_552" ~ "yes",
      animalName == "LBR" & sampleName == "env_279" ~ "yes",
      
      animalName == "YBO" & sampleName == "env_294" ~ "UNK; both animalID 142/YBO captureDate 6/27/2017 and animalID 107/OBG captureDate 6/15/2017 have env_294; The env I chose had YBO info but OBG date",
       
      animalName == "YBR" & sampleName == "env_295" ~ "UNK; both animalID 9/YBR captureDate 6/27/2017 and animalID 199/OPBL captureDate 6/15/2017 have env_295; The env I chose had YBR info but OPBL date",
      
      animalName == "OBR2" & sampleName == "lm_582b" ~ "yes",
      animalName == "OBR2" & sampleName == "env_298" ~ "no; animalID 169/OBR2 captureDate 6/19/2017 has env_261; animalID 200/OBR_RC captureDate 6/16/2017 has env_298 - supported by sampleNotes which says that env label had 'OBR SFUS AR6 on label', which is animalID 200's group",
       
      animalName == "OBY" & sampleName == "lm_585b" ~ "yes",
      
      animalName == "OBG" & sampleName == "lm_596a" ~ "yes",
    
      animalName == "OPL/ORC" & sampleName == "lm_574" ~ "yes",
      animalName == "OPL/ORC" & sampleName == "env_301" ~ "UNK; both animalID 91/OPL_ORC captureDate 6/15/2017 and animalID 54/WPO captureDate 6/20/2017 have env_301",
      
      animalName == "SBR2" & sampleName == "env_306" ~ "UNK; both animalID 205/SBR2 captureDate 6/22/2017 and animalID 63/BLPO_RC captureDate 6/18/2017 have env_306; My sample notes also say 'alternate for 451; date switched? envelope has 6/22/2017 for date'... my records have 6/18 for SBR2 while capData has 6/22 for SBR2",
    
      animalName == "SPW/SRC" & sampleName == "lm_620" ~ "yes",
      animalName == "SPW/SRC" & sampleName == "env_305" ~ "yes",
      
      animalName == "YBY2" & sampleName == "lm_588a" ~ "yes",
   
      animalName == "YPBL/RC" & sampleName == "lm_586a" ~ "yes",
      animalName == "YPBL/RC" & sampleName == "env_285" ~ "yes",
  
      animalName == "YPL/YRC2" & sampleName == "env_284" ~ "yes",
       
      animalName == "WPL" & sampleName == "env_264" ~ "yes",
        
      animalName == "WPO" & sampleName == "lm_610" ~ "yes",
      animalName == "WPO" & sampleName == "env_301" ~ "UNK; both animalID 91/OPL_ORC captureDate 6/15/2017 and animalID 54/WPO captureDate 6/20/2017 have env_301",
       
      animalName == "WPS" & sampleName == "env_267" ~ "yes",
    
      animalName == "BLPY/RC" & sampleName == "lm_560" ~ "yes",
      animalName == "BLPY/RC" & sampleName == "env_282" ~ "yes",
      
      # 2018
      animalName == "YBG2" & sampleName == "lm_898" ~ "yes",
        
      animalName == "YBL" & sampleName == "lm_904" ~ "yes",
        
      animalName == "YBR" & sampleName == "lm_911" ~ "yes",
      
      animalName == "BLBBL" & sampleName == "lm_879" ~ "yes",
      animalName == "BLBBL" & sampleName == "env_343" ~ "yes",
      
      animalName == "BLBW3" & sampleName == "lm_700" ~ "yes",
      animalName == "BLBW3" & sampleName == "env_345" ~ "yes",
      
      animalName == "BLPO" & sampleName == "lm_882" ~ "yes",
      animalName == "BLPO" & sampleName == "env_338" ~ "yes",
        
      animalName == "WBG" & sampleName == "lm_642" ~ "yes",
      animalName == "WBG" & sampleName == "env_326" ~ "yes",
       
      animalName == "WBO2" & sampleName == "lm_639" ~ "yes",
      animalName == "WBO2" & sampleName == "env_328" ~ "yes",
      
      animalName == "WBW" & sampleName == "lm_641" ~ "yes",
      animalName == "WBW" & sampleName == "env_325" ~ "yes",

      animalName == "WRC2" & sampleName == "lm_644" ~ "yes",
      animalName == "WRC2" & sampleName == "env_327" ~ "yes",
        
      animalName == "LBW" & sampleName == "lm_664" ~ "yes",
      animalName == "LBW" & sampleName == "env_330" ~ "yes",
       
      animalName == "GBR2" & sampleName == "lm_686" ~ "yes",
      animalName == "GBR2" & sampleName == "env_341" ~ "yes",
       
      animalName == "GBW2" & sampleName == "lm_665" ~ "yes",
      animalName == "GBW2" & sampleName == "env_340" ~ "yes",
      
      animalName == "YBG3" & sampleName == "lm_1150" ~ "UNK; Trapping sheet missing",
       
      animalName == "YBO" & sampleName == "lm_1148" ~ "UNK; Trapping sheet missing",
       
      animalName == "YBR" & sampleName == "lm_1140" ~ "UNK; Trapping sheet missing",
      
      animalName == "RPBL2" & sampleName == "lm_680" ~ "yes",
      animalName == "RPBL2" & sampleName == "env_354" ~ "yes",
    
      animalName == "RPG/RRC" & sampleName == "lm_688" ~ "yes",
      animalName == "RPG/RRC" & sampleName == "env_347" ~ "yes",
       
      animalName == "RPY2" & sampleName == "lm_663" ~ "yes",
        
      animalName == "OPR" & sampleName == "lm_628" ~ "yes",
      animalName == "OPR" & sampleName == "env_320" ~ "yes",
      
      animalName == "SBR2" & sampleName == "lm_1136" ~ "UNK; Trapping sheet missing",
        
      animalName == "LBY" & sampleName == "lm_908" ~ "yes",
       
      animalName == "LPR" & sampleName == "lm_1039" ~ "yes",
      
      animalName == "OPBL2" & sampleName == "lm_675" ~ "yes",
      animalName == "OPBL2" & sampleName == "env_350" ~ "yes",
      
      animalName == "BLBL" & sampleName == "lm_1170" ~ "UNK; Trapping sheet missing",
    
      animalName == "LPG/RC" & sampleName == "lm_1135" ~ "UNK; Trapping sheet missing",
      
      animalName == "LPW2" & sampleName == "lm_1171" ~ "UNK; Trapping sheet missing",
        
      animalName == "SPY" & sampleName == "lm_900" ~ "yes",
    
      animalName == "YPBL/RC" & sampleName == "lm_903" ~ "yes",
        
      animalName == "WBR" & sampleName == "lm_910" ~ "UNK; Trapping sheet missing",
       
      animalName == "YPG2" & sampleName == "lm_685" ~ "yes",
      animalName == "YPG2" & sampleName == "env_358" ~ "yes",
      
      animalName == "BLBR" & sampleName == "lm_1033" ~ "yes",
        
      # 2019
      animalName == "OBG2" & sampleName == "lm_1198" ~ "yes",
      animalName == "OBG2" & sampleName == "env_525" ~ "yes",
       
      animalName == "OBL" & sampleName == "lm_1191" ~ "yes",
      animalName == "OBL" & sampleName == "env_538" ~ "yes",
     
      animalName == "OBR3" & sampleName == "lm_1194" ~ "yes",
      animalName == "OBR3" & sampleName == "env_539" ~ "yes",
       
      animalName == "OPO" & sampleName == "lm_1197" ~ "yes",
      animalName == "OPO" & sampleName == "env_562" ~ "yes",
       
      animalName == "OPS" & sampleName == "lm_1190" ~ "yes",
      animalName == "OPS" & sampleName == "env_591" ~ "UNK; animalID 275/OPS has env_591, but so does trapping sheet for animalID 289/OPW2 captureDate 6/27/2019 (though my records show this indiv w/env_611)",
      
      animalName == "ORC3" & sampleName == "lm_1193" ~ "yes",
      animalName == "ORC3" & sampleName == "env_537" ~ "yes",
   
      animalName == "SRC/SPS" & sampleName == "lm_1269" ~ "yes",
      animalName == "SRC/SPS" & sampleName == "env_598" ~ "yes",
      
      animalName == "YBG2" & sampleName == "env_602" ~ "yes",
      
      animalName == "YBO2" & sampleName == "lm_1266" ~ "yes",
      animalName == "YBO2" & sampleName == "env_599" ~ "yes",
      
      animalName == "YBS2" & sampleName == "lm_1316" ~ "yes",
      animalName == "YBS2" & sampleName == "env_596" ~ "yes",
       
      animalName == "YBY" & sampleName == "lm_1286" ~ "yes",
      animalName == "YBY" & sampleName == "env_592" ~ "yes",
     
      animalName == "YPBL2" & sampleName == "lm_1288" ~ "yes",
      animalName == "YPBL2" & sampleName == "env_600" ~ "yes",
       
      animalName == "YPL" & sampleName == "lm_1310" ~ "yes",
      animalName == "YPL" & sampleName == "env_536" ~ "yes",
     
      animalName == "YPO" & sampleName == "lm_1268" ~ "yes",
      animalName == "YPO" & sampleName == "env_597" ~ "yes",
      
      animalName == "BLBO" & sampleName == "lm_1245" ~ "yes",
      animalName == "BLBO" & sampleName == "env_582" ~ "yes",
    
      animalName == "BLBR2" & sampleName == "lm_1234" ~ "yes",
      animalName == "BLBR2" & sampleName == "env_583" ~ "yes",

      animalName == "BLBS" & sampleName == "lm_1246" ~ "yes",
      animalName == "BLBS" & sampleName == "env_578" ~ "yes",
     
      animalName == "BLBY4" & sampleName == "lm_1248" ~ "yes",
      animalName == "BLBY4" & sampleName == "env_580" ~ "yes",
       
      animalName == "LPO" & sampleName == "lm_1250" ~ "yes",
      animalName == "LPO" & sampleName == "env_579" ~ "yes",
      
      animalName == "LBBL" & sampleName == "lm_1201" ~ "yes",
      animalName == "LBBL" & sampleName == "env_527" ~ "yes",
      
      animalName == "LBG" & sampleName == "env_530" ~ "yes",
      animalName == "LBG" & sampleName == "lm_1199" ~ "yes",

      animalName == "LBO2" & sampleName == "lm_1206" ~ "yes",
      animalName == "LBO2" & sampleName == "env_528" ~ "yes",
      
      animalName == "LPG2" & sampleName == "lm_1200" ~ "yes",
      animalName == "LPG2" & sampleName == "env_526" ~ "yes",
      
      animalName == "LPS" & sampleName == "lm_1208" ~ "yes",
      animalName == "LPS" & sampleName == "env_529" ~ "yes",
  
      animalName == "LRC3/LPY" & sampleName == "lm_1205" ~ "yes",
      animalName == "LRC3/LPY" & sampleName == "env_581" ~ "yes",
      
      animalName == "GBBL" & sampleName == "lm_1220" ~ "yes",
      animalName == "GBBL" & sampleName == "env_576" ~ "yes",
      
      animalName == "GBG" & sampleName == "lm_1229" ~ "yes",
      animalName == "GBG" & sampleName == "env_574" ~ "no; animalID 195/GBG captureDate 6/22/2019 has env_542",
       
      animalName == "GBO" & sampleName == "lm_1223" ~ "yes",
      animalName == "GBO" & sampleName == "env_571" ~ "yes",
      
      animalName == "GBS2" & sampleName == "lm_1225" ~ "yes",
      animalName == "GBS2" & sampleName == "env_572" ~ "UNK; both animalID 283/GBS2 and animalID 34/RPS_RC captureDate 6/22/2019 have env_572",
       
      animalName == "GBY" & sampleName == "lm_1221" ~ "yes, but also has lm_1229 which is also listed with animalID 195/GBG captureDate 6/22/2019",
      animalName == "GBY" & sampleName == "env_575" ~ "yes",

      animalName == "GPO2" & sampleName == "lm_1218" ~ "yes",
      animalName == "GPO2" & sampleName == "env_577" ~ "yes",

      animalName == "RPS/RC" & sampleName == "lm_1227" ~ "yes",
      animalName == "RPS/RC" & sampleName == "env_573" ~ "no; animalID 34 has env_572 listed, though animalID 283/GBS2 captureDate 6/22/2019 also has env_572",
     
      animalName == "BLBL2" & sampleName == "lm_1215" ~ "yes",
      animalName == "BLBL2" & sampleName == "env_566" ~ "yes",
  
      animalName == "BLPS2/RC" & sampleName == "lm_1216" ~ "yes",
      animalName == "BLPS2/RC" & sampleName == "env_568" ~ "yes",
      
      animalName == "YBG4" & sampleName == "lm_1217" ~ "yes",
      animalName == "YBG4" & sampleName == "env_567" ~ "UNK; none listed on trapping sheet but number lines up with env numbers for other trapped group members",
      
      animalName == "YPO3" & sampleName == "lm_1214" ~ "yes",
      animalName == "YPO3" & sampleName == "env_570" ~ "yes",
       
      animalName == "YPY" & sampleName == "lm_1222" ~ "yes",
      animalName == "YPY" & sampleName == "env_569" ~ "yes",
       
      animalName == "RBL" & sampleName == "lm_1261" ~ "yes",
      animalName == "RBL" & sampleName == "env_595" ~ "UNK; none listed on trapping sheet",
       
      animalName == "RBW" & sampleName == "lm_1273" ~ "yes",
      animalName == "RBW" & sampleName == "env_603" ~ "yes",
      
      animalName == "RPG2" & sampleName == "env_601" ~ "yes",
      animalName == "RPG2" & sampleName == "lm_1270" ~ "yes",
       
      animalName == "RPO" & sampleName == "lm_1275" ~ "yes",
      animalName == "RPO" & sampleName == "env_594" ~ "yes",
      
      animalName == "RPY2" & sampleName == "env_593" ~ "yes",
      
      animalName == "LBO2" & sampleName == "lm_1253" ~ "yes",
      animalName == "LBO2" & sampleName == "env_585" ~ "yes",
       
      animalName == "LBW" & sampleName == "lm_1326" ~ "yes",
      animalName == "LBW" & sampleName == "env_622" ~ "yes",
       
      animalName == "LPG" & sampleName == "lm_1252" ~ "yes",
      animalName == "LPG" & sampleName == "env_586" ~ "yes",
   
      animalName == "LPL-LRC" & sampleName == "lm_1249" ~ "yes",
      animalName == "LPL-LRC" & sampleName == "env_584" ~ "yes",
       
      animalName == "LPS" & sampleName == "lm_1331" ~ "yes",
      animalName == "LPS" & sampleName == "env_621" ~ "yes",
   
      animalName == "LPY/LRC" & sampleName == "lm_1328" ~ "yes",
      animalName == "LPY/LRC" & sampleName == "env_607" ~ "yes",
       
      animalName == "OBY" & sampleName == "lm_1189" ~ "yes",
      animalName == "OBY" & sampleName == "env_535" ~ "yes",
 
      animalName == "OPBL2/ORC" & sampleName == "lm_1188" ~ "yes",
      animalName == "OPBL2/ORC" & sampleName == "env_487" ~ "yes",
     
      animalName == "OPBL3" & sampleName == "lm_1185" ~ "yes",
      animalName == "OPBL3" & sampleName == "env_561" ~ "yes",
       
      animalName == "OPR" & sampleName == "lm_1187" ~ "yes",
      animalName == "OPR" & sampleName == "env_524" ~ "yes",
       
      animalName == "OBG" & sampleName == "lm_1259" ~ "yes",
      animalName == "OBG" & sampleName == "env_589" ~ "UNK; none listed on trapping sheet but fits with env numbers for other group members trapped",
      
      animalName == "OBO2" & sampleName == "lm_1256" ~ "yes",
      animalName == "OBO2" & sampleName == "env_590" ~ "yes",
       
      animalName == "OBS" & sampleName == "lm_1255" ~ "yes",
      animalName == "OBS" & sampleName == "env_587" ~ "yes",
      
      animalName == "OPW2" & sampleName == "env_611" ~ "no; animalID 289/OPW2 has env_591",
      
      animalName == "OPY2" & sampleName == "env_588" ~ "yes",
      animalName == "OPY2" & sampleName == "lm_1258" ~ "yes",
       
      animalName == "SBG" & sampleName == "lm_1241" ~ "yes",
      animalName == "SBG" & sampleName == "env_531" ~ "yes",
         
      animalName == "SBO" & sampleName == "lm_1231" ~ "yes",
      animalName == "SBO" & sampleName == "env_563" ~ "yes",
         
      animalName == "SBR3" & sampleName == "lm_1236" ~ "yes",
      animalName == "SBR3" & sampleName == "env_532" ~ "yes",
       
      animalName == "SBS" & sampleName == "lm_1230" ~ "yes",
      animalName == "SBS" & sampleName == "env_534" ~ "UNK; no hair sample listed on trapping sheet, but lines up with env numbers from other trapped group members",
      
      animalName == "SBY2" & sampleName == "lm_1239" ~ "yes",
      animalName == "SBY2" & sampleName == "env_564" ~ "yes",
      
      animalName == "SRC2" & sampleName == "lm_1237" ~ "yes",
      animalName == "SRC2" & sampleName == "env_533" ~ "yes",
       
      animalName == "YBS" & sampleName == "lm_1183" ~ "yes",
      animalName == "YBS" & sampleName == "env_501" ~ "yes",
      
      animalName == "YBW2" & sampleName == "lm_1244" ~ "yes",
      animalName == "YBW2" & sampleName == "env_502" ~ "yes",
      
      animalName == "YBY2" & sampleName == "lm_1181" ~ "yes",
      animalName == "YBY2" & sampleName == "env_500" ~ "yes",
     
      animalName == "YPBL2" & sampleName == "lm_1180" ~ "yes",
      animalName == "YPBL2" & sampleName == "env_499" ~ "yes",
      
      animalName == "YRC3" & sampleName == "lm_1184" ~ "yes",
      animalName == "YRC3" & sampleName == "env_503" ~ "yes",
      
      animalName == "BLBG" & sampleName == "lm_1211" ~ "yes",
      animalName == "BLBG" & sampleName == "env_565" ~ "yes",
     
      animalName == "BLPG2" & sampleName == "lm_1242" ~ "yes",
      animalName == "BLPG2" & sampleName == "env_485" ~ "yes",
        
      animalName == "WBO" & sampleName == "lm_962" ~ "yes",
      animalName == "WBO" & sampleName == "env_484" ~ "yes",
       
      animalName == "WPW" & sampleName == "lm_1169" ~ "yes",
      animalName == "WPW" & sampleName == "env_486" ~ "yes",
      
      animalName == "BLPG" & sampleName == "lm_1330" ~ "yes",
      animalName == "BLPG" & sampleName == "env_606" ~ "yes",
      
      animalName == "BLPY" & sampleName == "lm_1292" ~ "yes",
      animalName == "BLPY" & sampleName == "env_605" ~ "yes",
      
      animalName == "YBS3" & sampleName == "lm_1278" ~ "yes",
      animalName == "YBS3" & sampleName == "env_604" ~ "yes",
      
      .default = sampleName_correct
    )
  )
```

Select just those with issues:

```{r}
md_tamRun5_v3_sampleNameChecks_errors <- md_tamRun5_v3_sampleNameChecks %>%
  filter(sampleName_correct != "yes") %>%
  mutate(
    md_original = str_c(animalID, species, sex, sep = "_")
  ) %>%
  select(sampleID, sampleName, sampleType, md_original, sampleName_correct) %>%
  arrange(sampleID)
```

## 7.2 Update md_tamRun5_v4

```{r}
md_tamRun5_v4 <- 
```

# X Running error list

Create dataframe to track updates to original md_tamRun5

```{r}
md_tamRun5_runningUpdates <- md_tamRun5_v1 %>%
  mutate(
    mdShort_original = str_c(animalID, species, sex, sep = "_")
  ) %>%
  select(sampleID, sampleName, sampleType, animalID, mdShort_original) %>%
  dplyr::rename("animalID_original" = "animalID") %>%
  mutate(
    animalID_alt = case_when(
      
      # dupTubes_blood
      sampleName == "lm_585b" & as.character(animalID_original) == "12" ~ "26",
      sampleName == "lm_586a" & as.character(animalID_original) == "212" ~ "196",
      sampleName == "lm_588a" & as.character(animalID_original) == "211" ~ "171",
      sampleName == "lm_592a" & as.character(animalID_original) == "215" ~ "200",
      sampleName == "lm_596a" & as.character(animalID_original) == "213" ~ "107",
      sampleName == "lm_600a" & as.character(animalID_original) == "214" ~ "27",
      
      # dupTubes_hair
      sampleName == "env_294" & as.character(animalID_original) == "142" ~ "107",
      sampleName == "env_295" & as.character(animalID_original) == "9" ~ "199",
      sampleName == "env_301" & as.character(animalID_original) == "91" ~ "54",
      sampleName == "env_301" & as.character(animalID_original) == "54" ~ "91",
      sampleName == "env_306" & as.character(animalID_original) == "205" ~ "63",
      
      # capData checks
      as.character(animalID_original) == "535" ~ "234",
      
      sampleName == "env_27" & as.character(animalID_original) == "98" ~ "27",
      sampleName == "env_28" & as.character(animalID_original) == "70" ~ "69",
      sampleName == "env_32" & as.character(animalID_original) == "69" ~ "26",
      sampleName == "env_298" & as.character(animalID_original) == "169" ~ "200",
      
      
      .default = NA
    )
  ) %>%
  
  # append mdShort_alt
  merge(., animalID_mdShort_masterList, by.x = "animalID_alt", by.y = "animalID", all.x = T) %>%
  dplyr::rename("mdShort_alt" = "mdShort") %>%
  relocate(animalID_alt, .after = animalID_original) %>%
  
  # determine whether to change to alt md (yes, no, tbd)
  mutate(
    change_toAlt = case_when(
      
      # dupTubes_blood
      sampleName == "lm_585b" & as.character(animalID_original) == "12" ~ "yes",
      sampleName == "lm_586a" & as.character(animalID_original) == "212" ~ "yes",
      sampleName == "lm_588a" & as.character(animalID_original) == "211" ~ "yes",
      sampleName == "lm_592a" & as.character(animalID_original) == "215" ~ "yes",
      sampleName == "lm_596a" & as.character(animalID_original) == "213" ~ "yes",
      sampleName == "lm_600a" & as.character(animalID_original) == "214" ~ "yes",
      
      # dupTubes_hair
      sampleName == "env_294" & as.character(animalID_original) == "142" ~ "tbd",
      sampleName == "env_295" & as.character(animalID_original) == "9" ~ "tbd",
      sampleName == "env_301" & as.character(animalID_original) == "91" ~ "tbd",
      sampleName == "env_301" & as.character(animalID_original) == "54" ~ "tbd",
      sampleName == "env_306" & as.character(animalID_original) == "205" ~ "tbd",
      
      # capData checks
      as.character(animalID_original) == "535" ~ "yes",
      
      sampleName == "env_27" & as.character(animalID_original) == "98" ~ "yes",
      sampleName == "env_28" & as.character(animalID_original) == "70" ~ "yes",
      sampleName == "env_32" & as.character(animalID_original) == "69" ~ "yes",
      sampleName == "env_298" & as.character(animalID_original) == "169" ~ "yes",
      
      .default = NA
    )
  ) %>%
  mutate(
    
    # notes - dupTubes
    notes_mdReconciliation = case_when(
      # dupTubes - blood
      sampleID == "tamRun5.022" ~ "dup_sampleName; update animalID 213_SIMP_F to 107_SIMP_M",
      sampleID == "tamRun5.031" ~ "dup_sampleName; update from animalID 12_LWED_F to 26_LWED_M",
      sampleID == "tamRun5.053" ~ "dup_sampleName; update from animalID 215_SIMP_F to 200_LWED_M",
      sampleID == "tamRun5.065" ~ "dup_sampleName; update from animalID 211_SIMP_F to 171_LWED_M",
      sampleID == "tamRun5.067" ~ "dup_sampleName; update from animalID 212_SIMP_F to 196_LWED_F",
      sampleID == "tamRun5.168" ~ "dup_sampleName; update from animalID 214_SIMP_M to 27_LWED_M",
      
      # notes - capData_byIndiv
      as.character(animalID_original) == "535" ~ "dup_indiv; animalID 234 & 535 are the SAME indiv; Update animalID from 535 to 234",
      
      # notes - trapping sheet checks
      sampleName == "env_27" & as.character(animalID_original) == "98" ~ "mismatch_capData; Trapping sheets show that env_27 belongs to animalID 27/OBL, while animalID 98/OBG captureDate 7/06/2013 has env_33; Update animalID 98 to 27",
      sampleName == "env_28" & as.character(animalID_original) == "70" ~ "mismatch_capData; Trapping sheets show that env_28 belongs to animalID 69/OBO, while animalID 70/OBW captureDate 7/06/2013 has env_29; Update animalID 70 to 69",
      sampleName == "env_32" & as.character(animalID_original) == "69" ~ "mismatch_capData; Trapping sheets show that env_32 belongs to animalID 26/OBY, while animalID 69/OBO captureDate 7/06/2013 has env_28; Update animalID 69 to 26",
      sampleName == "env_298" & as.character(animalID_original) == "169" ~ "mismatch_capData; Trapping sheets show that env_298 belongs to animalID 200/OBR_RC, while animalID 169 has env_261; Update animalID 169 to 200",
      
      .default = NA
    )
  )
```

Export

```{r}
write.csv(md_tamRun5_runningUpdates, "./metadataReconciliation/md_tamRun5_updates_runningList.csv", row.names = F)
```

# From first round of matchCompare_idMismatch_0x

**tamRun5.160 / 69 vs. tamRun5.325 / 70 - update tamRun5.325 to animalID 69**

-   actionFinal_typeMatch and topMatch both "tbd", but typeMatch only has 2 common genos (unhelpful)
-   mdAlt_topMatch = 69_LWED_M; notes_topMatch say that sampleName was on trap sheet for 69_LWED_M vs. 70_LWED_M
-   after drawing everything out, including comparing dupTest results b/t tamRun5.160/tamRun5.305 (supposedly 69_LWED_M) + tamRun5.176/tamRun5.325 (supposedly 70_LWED_M, with tamRun5.325 mdAlt = 69_LWED_M) + tamRun5.001/tamRun5.168/tamRun5.218 (supposedly 27_LWED_M; likely twin of 70_LWED_M), I think the results support updating tamRun5.325 animalID t0 69
-   the original 69 hair sample failed, but relative to animalID 70, 27, and 69 blood samples (all with similar commonGenos), it had the highest propMatch with animalID 69 blood sample

[from earlier version of this check]: tamRun5.325 (md_original 70_LWED_M) only shows up in likelyDups_0x, but even so I think that it's enough evidence to switch it to its mdAlt (rowID179_69_LWED_M_OBO_AR6_2013-07-06).

-   0x cutoff
    -   dup for animalID 70 blood sample


**tamRun5.211 / 200 vs. tamRun5.264 / 169 - update tamRun5.264 to animalID 200**

-   actionFinal_topMatch is tbd w/md_alt 200_LWED M; duptest supports md_alt

For both 0x and 10x cutoffs, tamRun5.264 (md_original 169_LWED_M, hair sample) turns up:

-   0x cutoff
    -   dup for animalID 200; 2 blood samples & 1 hair sample
    -   dup for animalID 201; 1 blood sample
-   10x cutoff
    -   dup for animalID 200; 1 blood & 1 hair sample

Given these results, it seems reasonable to update tamRun5.264 metadata to its mdAlt (rowID426_200_LWED_M_OBR_AR6_2017-06-16)


### Match animalIDs

**NEED TO GO THROUGH THESE AGAIN W/MATCHCOMPARE DF**

Look at dup pairs where animalIDs match; subset to those with assigned actions from errorChecks

```{r}
matchCompare_0x_idMatch <- matchCompare_0x %>%
  filter(baseTop_match == "yes") %>%
  arrange(sampleID_base) %>%
  mutate(
    temp = str_c(sampleID_base, sampleID_topMatch, sep = "_")
  ) %>%
  filter(!is.na(actionFinal_base) | !is.na(actionFinal_typeMatch) | !is.na(actionFinal_topMatch))

matchCompare_0x_idMatch$sampleID_base
```

```{r}
View(matchCompare_0x_idMismatch[5,])

View(capData_byIndiv_v5 %>%
       filter(animalID %in% c("63", "205")))

       #filter(groupName == "AR6")
)

matchCompare_0x

md_tamRun5_v5

View(polyGenResults_0x_dupTest %>%
       filter(Sample1 == "tamRun5.110") %>%
       filter(Sample2 == "tamRun5.214"))
```


"tbd" only exists in mdAction_final1 cols; just filter with these

**tamRun5.125** tamRun5.125 (blood sample) turns up in both 0x and 10x dupTests as a dup for hair sample tamRun5.321. Its mdAction_final is set to "tbd_sexMismatch" - despite the sex mismatch, my assumption here was that the original metadata was correct (see notes_mdReconciliation for details). This duptest suggests that the mdAction_final should be to "keepOriginal".

```{r}
likelyDups_0x_idMatch_mdAction_tbd <- likelyDups_0x %>%
  filter(animalID_match == "yes") %>%
  filter(str_detect(mdAction_final1, "(?i)tbd"))

likelyDups_10x_idMatch_mdAction_tbd <- likelyDups_0x %>%
  filter(animalID_match == "yes") %>%
  filter(str_detect(mdAction_final1, "(?i)tbd"))
```

## 6.6 errorChecks5_actionList

**NEED TO UPDATE THIS**

```{r}
errorChecks5_actionList <- data.frame(
  sampleID = c("tamRun5.264", "tamRun5.325", "tamRun5.125"),
  notes_mdReconciliation = c("[dupTest notes: mdAction_final originally 'tbd'; GTscore duptest confirmed mdAlt to be correct]",
                             "[dupTest notes: mdAction_final originally 'tbd'; GTscore duptest confirmed mdAlt to be correct]",
                             "[dupTest notes: mdAction_final originally 'tbd_sexMismatch'; GTscore duptest confirmed md_original to be correct]"),
  action_dupChecks = c("update_toAlt",
                       "update_toAlt",
                       "keepOriginal"),
  flagged_in = "errorChecks5"
)
```

## 6.7 Update errorChecks_fullList_v4

```{r}
errorChecks_fullList_v4 <- errorChecks_fullList_v3 %>%
  merge(., errorChecks5_actionList, by = "sampleID", all = T) %>%
  relocate(action_dupChecks, .after = action_spSexChecks) %>%
  
  mutate(
    action_final = case_when(
      !is.na(action_dupChecks) ~ action_dupChecks,
      .default = action_final
    )
  ) %>%
  
  mutate(
    flagged_in = case_when(
      is.na(flagged_in.x) ~ flagged_in.y,
      is.na(flagged_in.y) ~ flagged_in.x,
      .default = str_c(flagged_in.x, "; ", flagged_in.y)
    )
  ) %>%
  relocate(flagged_in, .after = action_final) %>%
  
  mutate(
    notes_mdReconciliation = case_when(
      is.na(notes_mdReconciliation.x) ~ notes_mdReconciliation.y,
      is.na(notes_mdReconciliation.y) ~ notes_mdReconciliation.x,
      .default = str_c(notes_mdReconciliation.x, "; ", notes_mdReconciliation.y)
    )
  ) %>%
  relocate(notes_mdReconciliation, .after = rowID_alt) %>%
  select(!contains(".x")) %>%
  select(!contains(".y")) %>%
  
  # add species_alt and sex_alt in
  mutate(
    species_alt = case_when(
      str_detect(md_alt, "LWED") ~ "LWED",
      str_detect(md_alt, "SIMP") ~ "SIMP",
      .default = NA
    ),
    sex_alt = case_when(
      str_detect(md_alt, "_F") ~ "F",
      str_detect(md_alt, "_M") ~ "M",
      .default = NA
    )
  ) %>%
  relocate(c(species_alt, sex_alt), .after = animalName_alt) %>%
  relocate(md_alt, .before = animalID_alt)

write.csv(errorChecks_fullList_v4, "./metadataReconciliation/master_metadataReconciliation_actionList_v4.csv", row.names = F)
```

## 6.8 Update md_tamRun5_v4

```{r}
md_tamRun5_v4 <- md_tamRun5_v3 %>%
  merge(., errorChecks5_actionList, by = "sampleID", all.x = T) %>%
  merge(., errorChecks_fullList_v4[, c("sampleID", "action_dupChecks", "animalID_alt", "animalName_alt", "species_alt", "sex_alt", "group_alt", "captureDate_alt", "rowID_alt")], by = c("sampleID", "action_dupChecks"), all.x = T) %>%
  
  # adjust mdAction_final & notes
  mutate(
    mdAction_final = case_when(
      !is.na(action_dupChecks) ~ action_dupChecks,
      .default = mdAction_final
    )
  ) %>%
  
  mutate(
    notes_mdReconciliation = case_when(
      !is.na(notes_mdReconciliation.y) ~ str_c(notes_mdReconciliation.x, "; ", notes_mdReconciliation.y),
      .default = notes_mdReconciliation.x
    )
  ) %>%
  relocate(notes_mdReconciliation, .after = md_alt) %>%
  select(-contains(".x"), -contains(".y"), -flagged_in) %>%
  
  # update md
  mutate(
    animalID = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ animalID_alt,
      .default = animalID
    ),
    animalName = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ animalName_alt,
      .default = animalName
    ),
    species = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ species_alt,
      .default = species
    ),
    sex = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ sex_alt,
      .default = sex
    ),
    group = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ group_alt,
      .default = group
    ),
    captureDate = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ as.character(captureDate_alt),
      .default = as.character(captureDate)
    ),
    fieldNotes = case_when(
      str_detect(action_dupChecks, "update_toAlt") ~ NA,
      .default = fieldNotes
    )
  ) %>%
  relocate(animalName, .before = group) %>%
  mutate(
    md_alt = str_c(rowID_alt, animalID_alt, species_alt, sex_alt, animalName_alt, group_alt, captureDate_alt, sep = "_"),
    md_alt = str_c("rowID", md_alt)
         ) %>%
  select(-c(rowID_alt, animalID_alt, species_alt, sex_alt, animalName_alt, group_alt, captureDate_alt, action_dupChecks))
```

## 6.9 Recheck dups

### Recheck

I'm rechecking the dupTest results to see how things changed. I'm also checking to see if the species metadata matches b/t duplicates.

**Full set**

0x cutoff genos: - n = 156 duplicate pairs total - n = 76 w/same animalID (vs. 72 before) - n = 80 w/different animalID (vs. 84 before)

10x cutoff genos: - n = 101 duplicate pairs total - n = 43 w/same animalID (vs. 41 before) - n = 58 w/different animalID (vs. 60 before)

```{r}
# n = 156 dup pairs for 0x
likelyDups_0x_v2 <- polyGenResults_0x_dupTest %>%
  filter(proportionMatch >= matchThresh,
         proportionCommon >= commonThresh) %>%
  
  merge(., md_tamRun5_v4[, c("sampleID", "sampleType", "species", "animalID", "md_alt", "mdAction_final", "md_original", "notes_mdReconciliation")], by.x = "Sample1", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType1" = "sampleType",
                "species1" = "species",
                "animalID1" = "animalID",
                "md_alt1" = "md_alt",
                "mdAction_final1" = "mdAction_final",
                "md_original1" = "md_original",
                "notes_mdReconciliation1" = "notes_mdReconciliation") %>%
  merge(., md_tamRun5_v4[, c("sampleID", "sampleType", "species", "animalID", "md_alt", "mdAction_final", "md_original", "notes_mdReconciliation")], by.x = "Sample2", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType2" = "sampleType",
                "species2" = "species",
                "animalID2" = "animalID",
                "md_alt2" = "md_alt",
                "mdAction_final2" = "mdAction_final",
                "md_original2" = "md_original",
                "notes_mdReconciliation2" = "notes_mdReconciliation") %>%
  relocate(sampleType2, .after = sampleType1) %>%
  relocate(species2, .after = species1) %>%
  relocate(animalID2, .after = animalID1) %>%
  relocate(md_alt2, .after = md_alt1) %>%
  relocate(mdAction_final2, .after = mdAction_final1) %>%
  relocate(md_original2, .after = md_original1) %>%
  relocate(notes_mdReconciliation2, .after = notes_mdReconciliation1) %>%
  mutate(
    species_match = case_when(
      species1 == species2 ~ "yes",
      .default = "no"
    ),
    animalID_match = case_when(
      animalID1 == animalID2 ~ "yes",
      .default = "no"
    )
  ) %>%
  relocate(species_match, .after = species2) %>%
  relocate(animalID_match, .after = animalID2) %>%
  relocate(Sample1)

# n = 101 dup pairs for 10x
likelyDups_10x_v2 <- polyGenResults_10x_dupTest %>%
  filter(proportionMatch >= matchThresh,
         proportionCommon >= commonThresh) %>%
  
  merge(., md_tamRun5_v4[, c("sampleID", "sampleType", "species", "animalID", "md_alt", "mdAction_final", "md_original", "notes_mdReconciliation")], by.x = "Sample1", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType1" = "sampleType",
                "species1" = "species",
                "animalID1" = "animalID",
                "md_alt1" = "md_alt",
                "mdAction_final1" = "mdAction_final",
                "md_original1" = "md_original",
                "notes_mdReconciliation1" = "notes_mdReconciliation") %>%
  merge(., md_tamRun5_v4[, c("sampleID", "sampleType", "species", "animalID", "md_alt", "mdAction_final", "md_original", "notes_mdReconciliation")], by.x = "Sample2", by.y = "sampleID", all.x = T) %>%
  dplyr::rename("sampleType2" = "sampleType",
                "species2" = "species",
                "animalID2" = "animalID",
                "md_alt2" = "md_alt",
                "mdAction_final2" = "mdAction_final",
                "md_original2" = "md_original",
                "notes_mdReconciliation2" = "notes_mdReconciliation") %>%
  relocate(sampleType2, .after = sampleType1) %>%
  relocate(species2, .after = species1) %>%
  relocate(animalID2, .after = animalID1) %>%
  relocate(md_alt2, .after = md_alt1) %>%
  relocate(mdAction_final2, .after = mdAction_final1) %>%
  relocate(md_original2, .after = md_original1) %>%
  relocate(notes_mdReconciliation2, .after = notes_mdReconciliation1) %>%
  mutate(
    species_match = case_when(
      species1 == species2 ~ "yes",
      .default = "no"
    ),
    animalID_match = case_when(
      animalID1 == animalID2 ~ "yes",
      .default = "no"
    )
  ) %>%
  relocate(species_match, .after = species2) %>%
  relocate(animalID_match, .after = animalID2) %>%
  relocate(Sample1)

# tables
table(likelyDups_0x_v2$animalID_match)
table(likelyDups_10x_v2$animalID_match)
```

**0x cutoff**

```{r}
# 0x
likelyDups_0x_idMismatch_v2 <- likelyDups_0x_v2 %>%
  filter(animalID_match == "no")
```

**10x cutoff**

```{r}
# 0x
likelyDups_10x_idMismatch_v2 <- likelyDups_10x_v2 %>%
  filter(animalID_match == "no")
```

### tamRun5.280 vs. tamRun5.042

Of note, there is one dupPair that has a species mismatch in likelyDups_0x_v2, tamRun5.042 (SIMP blood sample, animalID 191) and tamRun5.280 (LWED hair sample, animalID 189). Neither has come up in previous errorChecks. - 042 and 280 both only comes up once in likelyDups_0x_v2 (Sample1 and Sample2, respectively); neither come up in likelyDups_10x_v2 - 042 = 191_SIMP_F - 280 = 189_LWED_M

In my "ignore all below" section, I found the following, which suggests that tamRun5.280/189_LWED_M should be updated to 191_SIMP_F:

**From "ignore all below" scripts:** "tamRun5.280/189_LWED_M is mismatched at both species and sex - all 3 genotyped species loci = SIMP and both sex loci (general sex loci) = F. Furthermore, looking back at the original genotype file, this individual was also genotyped as F for two SIMP-specific sex loci. These results suggest that that this individual is SIMP_F vs. LWED_M."

I double-checked the hair and blood sampleNames against their trapping sheets for both animalIDs; all confirmed correct. Unfortunately, the corresponding hair/blood samples for each animalID have barely a handful of genotypes, so I can't use them as an additional check.

-   tamRun5.180/189 - lm_1231 - 2019-06-18 - confirmed
-   tamRun5.280/189 - env_563 - 2019-06-18 - confirmed
-   tamRun5.042/191 - lm_1039 - 2018-06-27 - confirmed
-   tamRun5.288/191 - env_228 - 2016-06-18 - confirmed

Next check - wet lab metadata - found the issue I think -- hair samples tamRun5.280/189 xtnLoc is p3.H11 and tamRun5.288/191 xtnLoc is p3.H12; both were added from lysis tubes, which means I added them manually. My guess is that I added both samples to p3.H11, but only tamRun5.191 actually amplified; as such, these are the genotypes that are popping up (vs. those of tamRun5.189). - checked quip, didn't see any notes about it, though it looks like Raquel helped me with this extraction plate? I think I was the one to transfer the lysis to the extraction plate though, so it would've been me - in any case though, I think updating the md for tamRun5.280 to 191_SIMP_F is a reasonable plan for now

### tamRun5.035/34 vs. tamRun5.150/80

-   animalID 34 vs. 80
-   99% match
-   lm_1227 vs. lm_304
-   p1.C5 vs. p2_F7
-   2019-06-22 vs. 2014-07-06
-   tamRun5.035 also has 83% match with tamRun5.110/blood & tamRun5.214/hair (both animalID 225)
-   tamRun5.150 also has 83% match with tamRun5.110/blood
-   xtnLocs don't seem close
    -   34_blood xtnLoc = p1.C5
    -   80_blood xtnLoc = p2.F7
    -   225_blood xtnLoc = p2.F2
-   based on capData, 34 was born in Ji in 2012, transferred to IC in 2017; 80 was born in 2012 oh wait they're twins.

```{r}
View(md_tamRun5_v4 %>%
       filter(sampleID %in% c("tamRun5.035", "tamRun5.150")))

View(capData_byIndiv_v5 %>%
       filter(animalID %in% c(34, 80)))
```

### tamRun5.016/26 vs. tamRun5.163/71

also likely twins; both juvs in AR6 w/same captureDate

```{r}
View(capData_byIndiv_v5 %>%
       filter(animalID %in% c(26, 71)))
```

### errorChecks6_actionList

Just going with tamRun5.280 fixes here - the other high match % keep turning out to be likely twins, so going to go with this and see what relatedness analyses show.

```{r}
md_tamRun5.288 <- md_tamRun5_v4 %>%
  filter(sampleID %in% "tamRun5.288") %>%
  select(c(animalID, animalName, species, sex, group, captureDate)) %>%
  merge(., capData_byIndiv_v5[, c("animalID", "captureDate", "rowID")], by = c("animalID", "captureDate"), all.x = T) %>%
  mutate(
    md = str_c(animalID, species, sex, sep = "_")
  ) %>%
  setNames(paste0(names(.), "_alt")) %>%
  select(c(md_alt, animalID_alt, animalName_alt, species_alt, sex_alt, group_alt, captureDate_alt, rowID_alt))

errorChecks6_actionList <- md_tamRun5_v4 %>%
  filter(sampleID == "tamRun5.280") %>%
  select(c(sampleID, animalID, animalName, species, sex, sampleName, captureDate)) %>%
  mutate(
    md_original = str_c(animalID, species, sex, sep = "_"),
    animalID_sampleName = str_c(animalID, sampleName, sep = "_"),
    action = NA,
    action_spSexChecks = NA,
    action_dupChecks = "update_toAlt",
    action_final = "update_toAlt",
    flagged_in = "errorChecks6"
  ) %>%
  relocate(md_original, .after = animalName) %>%
  relocate(animalID_sampleName, .before = captureDate) %>%
  select(-species, -sex) %>%
  mutate(
    notes_mdReconciliation = "[dupTest notes: GTscore duptest flagged as dup for tamRun5.042/191_SIMP_F (blood) w/95% match; neither 189_blood nor 191_hair had high enough genoSuccess for additional checks, but species/sex checks confirm SIMP_F; further investigation shows that hair samples for animalIDs 189/191 were in xtnLoc p3.H11 & p3.H12, respectively, suggesting pipetting error (i.e., transferred animalID 191 hair lysate into the well for animalID 189); given high match%, recommend updating md to that for 191_SIMP_F]"
  ) %>%
  cbind(., md_tamRun5.288) %>%
  relocate(notes_mdReconciliation, .after = rowID_alt)
```
