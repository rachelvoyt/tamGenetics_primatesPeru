---
title: "GTscorePipeline_COMBINED_run2"
output: html_document
date: "2022-09-06"
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,fig.path = "tools/")
knitr::opts_knit$set(root.dir = "./seqanalysis/01_run2_fecalHairBlood/03_run2GTscore")
```

```{r load packages, include=FALSE}
library(here)
library(tidyverse)
library(phylotools)
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("Biostrings")
source(here::here("./seqAnalysis/gtScore_sourceScripts/GTscore.R")) # NOTE- added N=ATGC to script for later analyses (not included in original)
```

GTscore also requires Perl as well as the the packages
"Algorithm::Combinatorics" and "Excel-Writer-XLSX". Perform the
following in terminal to install on Linux. NOTE -- be sure to install
both perl and the modules in root. how to install perl packages:
<http://www.cpan.org/modules/INSTALL.html>

```{bash, eval = FALSE}
# Install perl
conda install -c conda-forge perl

# Install cpanminus (makes installing perl modules easier)
cpan App::cpanminus
sudo cpanm Algorithm::Combinatorics
```

# About the pipeline

This pipeline includes all steps needed to analyze MiSeq data output,
including how to interleave the fasta sequences and create the necessary
files for analysis in GTscore. The GTscore part of the pipeline is based
on that created by Garrett McKinney (see the associated github
[here](https://github.com/gjmckinney/GTscore)), and combines scripts
included in his original "GTscore_pipeline.R" as well as his original
"README.md" - there's a good bit of overlap between these files, but a
few scripts exist in one but not the other.

In this pipeline, I've included separate analyses for each species as
well as for each primer pool, since not all samples were run with all
loci and not all loci are applicable to both species.

Note that Run 2 analyses only include loci that passed the first round
of optimization.

# About the data

The sequence data used in this pipeline is from tamRun2, the second
sequencing run in this project.

# Prep sequencing results

Note that I'm using raw (unfiltered) reads for this pipeline. Quality
checks are included in the run2Analyses_report.Rmd file.

## Extract sequencing results

After downloading the results from Basespace, transfer the zip file to
00_originalSeqResults and extract into 01_run2Seqs (keep the original
zip file as a copy in 00_originalSeqResults):

```{bash Extract sequencing results, eval = FALSE}
# Navigate to 00_originalSeqResults

# Extract zip file into 01_run2Seqs - keep the original zip file where it is as a copy
unzip FASTQ_Generation_2022-09-06_01_44_03Z-604973726-20220906T193600Z-001.zip -d ../01_run2Seqs
```

## Interleave fasta sequences

To prep for the GTscore pipeline, we need to combine reads 1 & 2 for
each sample into a single interleaved file & unzip:

```{bash Interleave fasta seqs, eval = FALSE}
# Navigate to the directory containing the .fastq.gz files from the Illumina sequencing run
cd 01_run2Seqs

# Move all .gz files out of their individual folders and into the current directory (script below says: in current directory 00_optSeqs, move all files from all folders within current directory to current directory)
mv */* ./

# Interleave reads 1 & 2 for each sample and place in a new folder
for i in ./01_run2Seqs/*_R1_001.fastq.gz; do name=$(basename $i _R1_001.fastq.gz); reformat.sh in=01_run2Seqs/${name}_R1_001.fastq.gz in2=01_run2Seqs/${name}_R2_001.fastq.gz out=02_run2Interleaved/${name}_interleaved.fastq.gz; done

# cd to 02_run2Interleaved and extract all .gz files
cd 02_run2Interleaved
gunzip -r .
```

# 1 Create primer-probe & sample files

We also need to make a few files to input into the GTscore pipeline: 1)
Sample files 2) Primer-probe files

## 1.1 Sample files

Step 1: Create general sample file "run2_sampleFiles.txt" containing all
the names of the interleaved fasta files created above (make this by
hand; use terminal to list all file names and create a new txt file)

Step 2: Split the general sample file into i) lwed & simp samples, then
ii) full pool & split pool samples

Primer Pool 1 (115 samples total, includes 2\*(5 pcr1 neg + 1 pcr2 neg))
50 LWED + 5 pcr1 (-) + 1 pcr2 (-) = 56 total 53 SIMP + 5 pcr1 (-) + 1
pcr2 (-) = 59 total

Primer Pool 2 (25 samples total, includes 2\*(1 pc1 neg & 1 pcr2 neg)) 6
LWED + 1 pcr1 neg + 1 pcr2 neg = 8 total 15 SIMP + 1 pcr1 neg + 1 pcr2
neg = 17 total

Primer Pool 3 (13 samples total, includes 2\*(1 pcr2 neg)) 5 LWED + 1
pcr2 (-) = 6 total 6 SIMP + 1 pcr2 (-) = 7 total

```{r}
# Read in metadata
md <- read.csv(here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/metadata_tamRun2.csv")) %>%
  filter(included_inRun == "yes")
md$sampleID <- gsub("_", "-", md$sampleID) # adjust formatting; miseq changes "_" to "-" for some reason
View(md) # double check there's 142 samples; success
table(md$primerPool)
#   1   2   3     also have one "NA" (PCR2 negative)
# 108  22  11     6 pcr1 (-) for p1, 2 pcr1 (-) for split pools

# Create separate lists of lwed & simp samples for primer pool 1 (full pool), and pools 2 & 3 (split pools)
## LWED
md_LWED_p1 <- md %>%
  filter(is.na(species) | species != "SIMP") %>%
  filter(is.na(primerPool) | primerPool == "1") %>%
  select(sampleID) %>%
  pull()
View(md_LWED_p1) # 56 - 6 = 50 LWED samples

md_LWED_p2 <- md %>%
  filter(is.na(species) | species != "SIMP") %>%
  filter(is.na(primerPool) | primerPool == "2") %>%
  select(sampleID) %>%
  pull()
View(md_LWED_p2) # 8; success

md_LWED_p3 <- md %>%
  filter(is.na(species) | species != "SIMP") %>%
  filter(is.na(primerPool) | primerPool == "3") %>%
  select(sampleID) %>%
  pull()
View(md_LWED_p3) # 6; success

## SIMP
md_SIMP_p1 <- md %>%
  filter(is.na(species) | species != "SFUS") %>%
  filter(is.na(primerPool) | primerPool == "1") %>%
  select(sampleID) %>%
  pull()
View(md_SIMP_p1) # 59; success

md_SIMP_p2 <- md %>%
  filter(is.na(species) | species != "SFUS") %>%
  filter(is.na(primerPool) | primerPool == "2") %>%
  select(sampleID) %>%
  pull()
View(md_SIMP_p2) # 17; success

md_SIMP_p3 <- md %>%
  filter(is.na(species) | species != "SFUS") %>%
  filter(is.na(primerPool) | primerPool == "3") %>%
  select(sampleID) %>%
  pull()
View(md_SIMP_p3) # 7; success

# Filter run2_sampleFiles to create separate LWED & SIMP for each pool set (full & split)
## Read in run2SampleFiles
sf_original <- read.table(here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/run2_sampleFiles_original.txt"))
View(sf_original)

## Separate columns to make match/filter easier
sf_original_sep <- sf_original %>%
  separate(V1, into = c("x", "y"), sep = 11)
View(sf_original_sep)

## Separate sf_original into p1 and p2 & 3
sf_p1 <- sf_original_sep %>%
  filter(x %in% c(md_LWED_p1, md_SIMP_p1)) %>%
  unite(V1, x, y, sep = "")
View(sf_p1) # 109 samples; 108 p1 + 1 pcr2 (-)

sf_p2 <- sf_original_sep %>%
  filter(x %in% c(md_LWED_p2, md_SIMP_p2)) %>%
  unite(V1, x, y, sep = "")
View(sf_p2) # 23; success

sf_p3 <- sf_original_sep %>%
  filter(x %in% c(md_LWED_p3, md_SIMP_p3)) %>%
  unite(V1, x, y, sep = "")
View(sf_p3) # 12; success

## Create separate LWED/SIMP files for p1, p2, and p3
### LWED
sf_LWED_p1 <- sf_original_sep %>%
  filter(x %in% md_LWED_p1) %>%
  unite(V1, x, y, sep = "")
View(sf_LWED_p1) # 56 samples; success

sf_LWED_p2 <- sf_original_sep %>%
  filter(x %in% md_LWED_p2) %>%
  unite(V1, x, y, sep = "")
View(sf_LWED_p2) # 8 samples; success

sf_LWED_p3 <- sf_original_sep %>%
  filter(x %in% md_LWED_p3) %>%
  unite(V1, x, y, sep = "")
View(sf_LWED_p3) # 6 samples; success

### SIMP
sf_SIMP_p1 <- sf_original_sep %>%
  filter(x %in% md_SIMP_p1) %>%
  unite(V1, x, y, sep = "")
length(sf_SIMP_p1$V1) # 59 samples; success

sf_SIMP_p2 <- sf_original_sep %>%
  filter(x %in% md_SIMP_p2) %>%
  unite(V1, x, y, sep = "")
length(sf_SIMP_p2$V1) # 17 samples; success

sf_SIMP_p3 <- sf_original_sep %>%
  filter(x %in% md_SIMP_p3) %>%
  unite(V1, x, y, sep = "")
length(sf_SIMP_p3$V1) # 7 samples; success

# Export sample files
write.table(sf_p1, file = here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p1_combined_sampleFiles.txt"), sep = "\t", row.names = F, col.names = F, quote = F)
write.table(sf_p2, file = here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p2_combined_sampleFiles.txt"), sep = "\t", row.names = F, col.names = F, quote = F)
write.table(sf_p3, file = here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p3_combined_sampleFiles.txt"), sep = "\t", row.names = F, col.names = F, quote = F)

write.table(sf_LWED_p1, file = here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p1_LWED_sampleFiles.txt"), sep = "\t", row.names = F, col.names = F, quote = F)
write.table(sf_LWED_p2, file = here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p2_LWED_sampleFiles.txt"), sep = "\t", row.names = F, col.names = F, quote = F)
write.table(sf_LWED_p3, file = here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p3_LWED_sampleFiles.txt"), sep = "\t", row.names = F, col.names = F, quote = F)

write.table(sf_SIMP_p1, file = here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p1_SIMP_sampleFiles.txt"), sep = "\t", row.names = F, col.names = F, quote = F)
write.table(sf_SIMP_p2, file = here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p2_SIMP_sampleFiles.txt"), sep = "\t", row.names = F, col.names = F, quote = F)
write.table(sf_SIMP_p3, file = here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p3_SIMP_sampleFiles.txt"), sep = "\t", row.names = F, col.names = F, quote = F)
```

## 1.2 Primer probe files

Each primer-probe file contains: 1. Locus - locus name 2. Ploidy - in
our case, all are diploid so ploidy = 2 3. SNPpos - position of SNP in
the amplicon, assuming that the first base = 0 4. Allele1 - one of the
options for the SNP 5. Allele2 - the other option for the SNP 6.
Probe1 - an 8 nt sequence overlapping the SNP; contains Allele1 7.
Probe2 - same as Probe1, but contains Allele2 8. Primer - the forward
primer sequence for each locus

We already have our original primerProbeFile from the optimization run;
now we need to filter out the loci that didn't pass optimization and
create separate files for full pool (p1) and split pool (p2 & p3).

Step 1) To do that, we first have to recombine the optimization
primer-probe files, which were separated into those with and without the
bp3 error:

```{r Create primer-probe files}
# Load original primerProbe files, with and without bp3 error and including BOTH species
pp_original_clean <- read.table("/home/rachelvoyt/Documents/UT-Grad/Development/repos/tamarinGenetics_primatesPeru/seqAnalysis/00_optimization/03_gtScore/primerProbeFile.txt", header = T)
View(pp_original_clean)
pp_original_bp3error <- read.table("/home/rachelvoyt/Documents/UT-Grad/Development/repos/tamarinGenetics_primatesPeru/seqAnalysis/00_optimization/03_gtScore/bp3error_primerProbeFile.txt", header = T)

# COMBINE the bp3error and non-error primerProbe files & temporarily separate out the bp3Index
pp_original_all <- rbind(pp_original_clean, pp_original_bp3error) %>%
  separate(Locus, into = c("locusName", "bp3Rank"), sep = "\\.")
length(pp_original_all$locusName) # 302 loci total; success
View(pp_original_all)
```

Step 2: Next, we need to get a list of loci that passed the optimization
step (this will also act as the primer list for Primer Pool 1), plus do
a bit of formatting adjustments:

```{r}
# Load file with final loci choices post-optimization
gtseq_finalChoices <- read.csv("/home/rachelvoyt/Documents/UT-Grad/Development/repos/tamarinGenetics_primatesPeru//primers/03_lociChoices/Master SNP file - GTseq_googleSheet_10Jul2022.csv")
View(gtseq_finalChoices)

# Get the list of loci that passed optimization; just need SET name & bp3 index
gtseq_keepLoci <- gtseq_finalChoices %>%
  filter(To.be.removed.before.second.amplification.round. == "NO") %>%
  select(c("SET", "bp3_index..UNIQUE."))
length(gtseq_keepLoci$SET) # 221 loci passing optimization; success
View(gtseq_keepLoci)

# Remove "_" in SET name
gtseq_keepLoci$SET <- gsub("_", "", gtseq_keepLoci$SET)
head(gtseq_keepLoci)

# Now what SET names do we have?
unique(gtseq_keepLoci$SET) # "INDID" "INDIDadd" "LWEDINDID" "SEXID" "SIMPINDID" "SPECIESID"

# Adjust SET names where needed & concatenate the columns to match with original primerProbe file
lociKeep <- gtseq_keepLoci %>%
  mutate(SET = recode(SET, "INDIDadd" = "INDID", "LWEDINDID" = "LWED", "SIMPINDID" = "SIMP"))
length(lociKeep$SET) # still 221; success
head(lociKeep)
```

Step 3: We now need to create lists of passing loci in Primer Pool 2 &
Primer Pool 3. To do that, we first need to load in the file outlining
how the pools were split (created by manually combining
platePrimers_toRepool.csv & oPools_toReorder_142oligos.csv and adding
primerPool column). Then we can create lists of the primers included in
the three pools, where we should have: Pool 1: 442 primers (221 loci)
Pool 2: 222 primers (111 loci) Pool 3: 220 primers (110 loci)

```{r}
# Load data & create primer pool 2 & 3 lists
poolSplits <- read.csv('/home/rachelvoyt/Documents/UT-Grad/Development/repos/tamarinGenetics_primatesPeru/primers/03_lociChoices/primerPool_splits.csv')
View(primerPools)

p2 <- poolSplits %>%
  filter(primerPool == "2") %>%
  select(bp3Index)
length(p2$bp3Index) # 222; success

p3 <- poolSplits %>%
  filter(primerPool == 3) %>%
  select(bp3Index)
length(p3$bp3Index) # 220; success

# Create lists for loci to keep in primer pools 2 & 3
lociKeep_p1 <- lociKeep %>%
  unite(locus, c("SET", "bp3_index..UNIQUE.")) %>%
  pull() # turn into a vector
head(lociKeep_p1)

lociKeep_p2 <- lociKeep %>%
  filter(bp3_index..UNIQUE. %in% p2$bp3Index) %>%
  unite(locus, c("SET", "bp3_index..UNIQUE.")) %>%
  pull() # turn into a vector
head(lociKeep_p2)
length(lociKeep_p2) # 111; success

lociKeep_p3 <- lociKeep %>%
  filter(bp3_index..UNIQUE. %in% p3$bp3Index) %>%
  unite(locus, c("SET", "bp3_index..UNIQUE.")) %>%
  pull() # turn into a vector
head(lociKeep_p3)
length(lociKeep_p3) # 110; success
```

Step 4: Now we can match locusName in the original primer-probe file to
lociKeep to create primer-probe files with loci that passed in each
primer pool AND create separate files for each species.

NOTE that there are no SIMP primers in Primer Pool 2.

```{r}
# Primer Pool 1
pp_p1 <- pp_original_all %>%
  filter(locusName %in% lociKeep_p1) %>%
  unite(Locus, locusName, bp3Rank, sep = ".") # recombine columns to bring back in bp3 rank
length(pp_p1$Locus) # 221; success
View(pp_p1)

pp_p1_LWED <- pp_p1 %>%
  filter(!str_detect(Locus, "SIMP"))
View(pp_p1_LWED)

pp_p1_SIMP <- pp_p1 %>%
  filter(!str_detect(Locus, "LWED"))
View(pp_p1_SIMP)

# Primer Pool 2
pp_p2 <- pp_original_all %>%
  filter(locusName %in% lociKeep_p2) %>%
  unite(Locus, locusName, bp3Rank, sep = ".") # recombine columns to bring back in bp3 rank
length(pp_p2$Locus) # 111; success
View(pp_p2)

pp_p2_LWED <- pp_p2 %>%
  filter(!str_detect(Locus, "SIMP"))
View(pp_p2_LWED)

pp_p2_SIMP <- pp_p2 %>%
  filter(!str_detect(Locus, "LWED"))
View(pp_p2_SIMP)

# Primer Pool 3
pp_p3 <- pp_original_all %>%
  filter(locusName %in% lociKeep_p3) %>%
  unite(Locus, locusName, bp3Rank, sep = ".") # recombine columns to bring back in bp3 rank
length(pp_p3$Locus) # 110; success
View(pp_p3)

pp_p3_LWED <- pp_p3 %>%
  filter(!str_detect(Locus, "SIMP"))
View(pp_p3_LWED)

pp_p3_SIMP <- pp_p3 %>%
  filter(!str_detect(Locus, "LWED"))
View(pp_p3_SIMP)

# Write files
write.table(pp_p1, here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p1_combined_primerProbeFile.txt"), sep = "\t", row.names = F, quote = F)
write.table(pp_p1_LWED, here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p1_LWED_primerProbeFile.txt"), sep = "\t", row.names = F, quote = F)
write.table(pp_p1_SIMP, here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p1_SIMP_primerProbeFile.txt"), sep = "\t", row.names = F, quote = F)

write.table(pp_p2, here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p2_combined_primerProbeFile.txt"), sep = "\t", row.names = F, quote = F)
write.table(pp_p2_LWED, here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p2_LWED_primerProbeFile.txt"), sep = "\t", row.names = F, quote = F)
write.table(pp_p2_SIMP, here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p2_SIMP_primerProbeFile.txt"), sep = "\t", row.names = F, quote = F)

write.table(pp_p3, here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p3_combined_primerProbeFile.txt"), sep = "\t", row.names = F, quote = F)
write.table(pp_p3_LWED, here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p3_LWED_primerProbeFile.txt"), sep = "\t", row.names = F, quote = F)
write.table(pp_p3_SIMP, here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/p3_SIMP_primerProbeFile.txt"), sep = "\t", row.names = F, quote = F)
```

# 2 Count reads for amplicons

Once the files are created, we can proceed with the second step in the
GTscore pipeline - counting amplicon reads. We'll be doing doing this
for the full set of data (all samples, all loci), whose results will be
used for genotyping, and the various species/primer-pool subsets of the
data, whose results will be used for analyses of loci and sample
performance.

1.  Full set (all samples with all loci)
2.  Primer Pool 1 - all samples
3.  Primer Pool 1 - LWED samples
4.  Primer Pool 1 - SIMP samples
5.  Primer Pool 2 - all samples
6.  Primer Pool 2 - LWED samples
7.  Primer Pool 2 - SIMP samples
8.  Primer Pool 3 - all samples
9.  Primer Pool 3 - LWED samples
10. Primer Pool 3 - SIMP samples

The read counter is written in perl (AmpliconReadCounter.pl), but can be
called from R. Running it does the following:

1.  Identifies each unique sequence, then counts the number of times
    each unique sequence occurs within an individual

2.  Aligns each unique sequence with primer and probe; if the sequence
    doesn't align, then it is excluded as an off-target sequence and
    reports by individual and by locus are given.

-   Note: By default, all primers are trimmed to the length of the
    shortest primer to increase speed. Optionally the full length primer
    can be used for the primer but this may significantly increase run
    timing depending on variation in primer lengths across loci.

Input flags for this script are: \* --p a tab delimited file containing
primer/probe information for each locus \* --files a text file
containing a list of .fastq sequence files to count reads from.

Optional flags: \* --prefix optional prefix for output file names \*
--inDir option to specify directory containing sequence data \*
--inputType fq or fastqgz (defaults to fastqgz) \* --useFullPrimer uses
the full primer for counting reads rather than the trimmed primer \*
--alleleOrder order of alleles output in locusTable file. Options are
original (matches primer-probe file order) or alphabetical (default) \*
--printMatched outputs matched reads for each individual \*
--printDiscarded outputs discarded reads for each individual

#### Setting up directories and running AmpliconReadCounterl.pl

To run from the command line, use: perl AmpliconReadCounter.pl -p
primerProbeFile.txt --files sampleList.txt

To run from R, use:

```{r count reads for amplicons, eval=FALSE}
setwd(here("./seqanalysis/01_run2_fecalHairBlood/03_run2GTscore"))
# All samples, all loci
system2("perl",
        args="AmpliconReadCounter.pl -p run2_primerProbeFile_original.txt --files run2_sampleFiles_original.txt --prefix fullSet_")

## Primer Pool 1
system2("perl",
        args="AmpliconReadCounter.pl -p p1_combined_primerProbeFile.txt --files p1_combined_sampleFiles.txt --prefix p1_")
system2("perl",
        args="AmpliconReadCounter.pl -p p1_LWED_primerProbeFile.txt --files p1_LWED_sampleFiles.txt --prefix p1_LWED_")
system2("perl",
        args="AmpliconReadCounter.pl -p p1_SIMP_primerProbeFile.txt --files p1_SIMP_sampleFiles.txt --prefix p1_SIMP_")

## Primer Pool 2
system2("perl",
        args="AmpliconReadCounter.pl -p p2_combined_primerProbeFile.txt --files p2_combined_sampleFiles.txt --prefix p2_")
system2("perl",
        args="AmpliconReadCounter.pl -p p2_LWED_primerProbeFile.txt --files p2_LWED_sampleFiles.txt --prefix p2_LWED_")
system2("perl",
        args="AmpliconReadCounter.pl -p p2_SIMP_primerProbeFile.txt --files p2_SIMP_sampleFiles.txt --prefix p2_SIMP_")

## Primer Pool 3
system2("perl",
        args="AmpliconReadCounter.pl -p p3_combined_primerProbeFile.txt --files p3_combined_sampleFiles.txt --prefix p3_")
system2("perl",
        args="AmpliconReadCounter.pl -p p3_LWED_primerProbeFile.txt --files p3_LWED_sampleFiles.txt --prefix p3_LWED_")
system2("perl",
        args="AmpliconReadCounter.pl -p p3_SIMP_primerProbeFile.txt --files p3_SIMP_sampleFiles.txt --prefix p3_SIMP_")
```

AmpliconReadCounter.pl outputs a LocusTable file and an AlleleReads file
for single-SNP and haplotype data, plus two summary files.

The default names for these files are as follows, with \_LWED and \_SIMP
appended to files associated with species-specific analyses:

-   LocusTable_singleSNPs.txt - locus name, ploidy, and alleles for each
    SNP
-   AlleleReads_singleSNPs.txt - counts for each SNP allele (rows are
    loci, columns are individuals)
-   LocusTable_haplotypes.txt - same as above (doesn't matter for us
    since we're only using single SNPs)
-   AlleleReads_haplotypes.txt - same as above (doesn't matter for us
    since we're only using single SNPs)
-   GTscore_individualSummary.txt - counts by individual of total reads,
    off-target reads, primer-only reads, and primer probe reads
-   GTscore_locusSummary.txt - counts by locus of primer reads and
    primer probe reads

# 3 Genotyping

Genotyping is accomplished using the polyGen function. The genotyping
algorithm is described in McKinney et al. 2018 and is a maximum
likelihood algorithm capable of genotyping any number of alleles and
ploidy per locus. This allows genoyping of single SNPs as well as
microhaplotypes, and loci with elevated ploidy.

Two arguments are required for polyGen, the locusTable and alleleReads
files output by AmpliconReadCounter.

Optional arguments for polyGen are:

-   p_thresh - threshold p-value for likelihood ratio test (default
    0.05)
-   epsilon - error rate for genotyping model (default 0.01)

**NOTE** that only primer probe reads are used in genotyping!

## 3.1 Genotyping: Full set

```{r}
#load locus table and allele reads file
singleSNP_locusTable<-read.delim("fullSet_LocusTable_singleSNPs.txt",header=TRUE,stringsAsFactors=FALSE)
singleSNP_alleleReads<-read.delim("fullSet_AlleleReads_singleSNPs.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)

head(singleSNP_locusTable)
singleSNP_alleleReads[1:5,1:5]

#generate singleSNP genotypes using the polyGen algorithm
polyGenResults_singleSNP<-polyGen(singleSNP_locusTable,singleSNP_alleleReads)

#look at first five rows and columns
polyGenResults_singleSNP[1:5,1:5]

#write results
write.table(polyGenResults_singleSNP,"fullSet_polyGenResults_singleSNP.txt",quote=FALSE,sep="\t")
```

## 3.2 Genotyping: Pool 1

```{r Genotyping}
#load locus table and allele reads file
p1_singleSNP_locusTable<-read.delim("p1_LocusTable_singleSNPs.txt",header=TRUE,stringsAsFactors=FALSE)
p1_singleSNP_alleleReads<-read.delim("p1_AlleleReads_singleSNPs.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)

head(p1_singleSNP_locusTable)
p1_singleSNP_alleleReads[1:5,1:5]

p1_LWED_singleSNP_locusTable<-read.delim("p1_LWED_LocusTable_singleSNPs.txt",header=TRUE,stringsAsFactors=FALSE)
p1_LWED_singleSNP_alleleReads<-read.delim("p1_LWED_AlleleReads_singleSNPs.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)

head(p1_LWED_singleSNP_locusTable)
p1_LWED_singleSNP_alleleReads[1:5,1:5]

p1_SIMP_singleSNP_locusTable<-read.delim("p1_SIMP_LocusTable_singleSNPs.txt",header=TRUE,stringsAsFactors=FALSE)
p1_SIMP_singleSNP_alleleReads<-read.delim("p1_SIMP_AlleleReads_singleSNPs.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)

head(p1_SIMP_singleSNP_locusTable)
p1_SIMP_singleSNP_alleleReads[1:5,1:5]

#generate singleSNP genotypes using the polyGen algorithm
p1_polyGenResults_singleSNP<-polyGen(p1_singleSNP_locusTable,p1_singleSNP_alleleReads)
p1_LWED_polyGenResults_singleSNP<-polyGen(p1_LWED_singleSNP_locusTable,p1_LWED_singleSNP_alleleReads)
p1_SIMP_polyGenResults_singleSNP<-polyGen(p1_SIMP_singleSNP_locusTable,p1_SIMP_singleSNP_alleleReads)

#look at first five rows and columns
p1_polyGenResults_singleSNP[1:5,1:5]
p1_LWED_polyGenResults_singleSNP[1:5,1:5]
p1_SIMP_polyGenResults_singleSNP[1:5,1:5]

#write results
write.table(p1_polyGenResults_singleSNP,"p1_polyGenResults_singleSNP.txt",quote=FALSE,sep="\t")
write.table(p1_LWED_polyGenResults_singleSNP,"p1_LWED_polyGenResults_singleSNP.txt",quote=FALSE,sep="\t")
write.table(p1_SIMP_polyGenResults_singleSNP,"p1_SIMP_polyGenResults_singleSNP.txt",quote=FALSE,sep="\t")
```

## 3.3 Genotyping: Pool 2

```{r Genotyping}
#load locus table and allele reads file
p2_singleSNP_locusTable<-read.delim("p2_LocusTable_singleSNPs.txt",header=TRUE,stringsAsFactors=FALSE)
p2_singleSNP_alleleReads<-read.delim("p2_AlleleReads_singleSNPs.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)

head(p2_singleSNP_locusTable)
p2_singleSNP_alleleReads[1:5,1:5]

p2_LWED_singleSNP_locusTable<-read.delim("p2_LWED_LocusTable_singleSNPs.txt",header=TRUE,stringsAsFactors=FALSE)
p2_LWED_singleSNP_alleleReads<-read.delim("p2_LWED_AlleleReads_singleSNPs.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)

head(p2_LWED_singleSNP_locusTable)
p2_LWED_singleSNP_alleleReads[1:5,1:5]

p2_SIMP_singleSNP_locusTable<-read.delim("p2_SIMP_LocusTable_singleSNPs.txt",header=TRUE,stringsAsFactors=FALSE)
p2_SIMP_singleSNP_alleleReads<-read.delim("p2_SIMP_AlleleReads_singleSNPs.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)

head(p2_SIMP_singleSNP_locusTable)
p2_SIMP_singleSNP_alleleReads[1:5,1:5]

#generate singleSNP genotypes using the polyGen algorithm
p2_polyGenResults_singleSNP<-polyGen(p2_singleSNP_locusTable,p2_singleSNP_alleleReads)
p2_LWED_polyGenResults_singleSNP<-polyGen(p2_LWED_singleSNP_locusTable,p2_LWED_singleSNP_alleleReads)
p2_SIMP_polyGenResults_singleSNP<-polyGen(p2_SIMP_singleSNP_locusTable,p2_SIMP_singleSNP_alleleReads)

#look at first five rows and columns
p2_polyGenResults_singleSNP[1:5,1:5]
p2_LWED_polyGenResults_singleSNP[1:5,1:5]
p2_SIMP_polyGenResults_singleSNP[1:5,1:5]

#write results
write.table(p2_polyGenResults_singleSNP,"p2_polyGenResults_singleSNP.txt",quote=FALSE,sep="\t")
write.table(p2_LWED_polyGenResults_singleSNP,"p2_LWED_polyGenResults_singleSNP.txt",quote=FALSE,sep="\t")
write.table(p2_SIMP_polyGenResults_singleSNP,"p2_SIMP_polyGenResults_singleSNP.txt",quote=FALSE,sep="\t")
```

## 3.4 Genotyping: Pool 3

```{r Genotyping}
#load locus table and allele reads file
p3_singleSNP_locusTable<-read.delim("p3_LocusTable_singleSNPs.txt",header=TRUE,stringsAsFactors=FALSE)
p3_singleSNP_alleleReads<-read.delim("p3_AlleleReads_singleSNPs.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)

head(p3_singleSNP_locusTable)
p3_singleSNP_alleleReads[1:5,1:5]

p3_LWED_singleSNP_locusTable<-read.delim("p3_LWED_LocusTable_singleSNPs.txt",header=TRUE,stringsAsFactors=FALSE)
p3_LWED_singleSNP_alleleReads<-read.delim("p3_LWED_AlleleReads_singleSNPs.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)

head(p3_LWED_singleSNP_locusTable)
p3_LWED_singleSNP_alleleReads[1:5,1:5]

p3_SIMP_singleSNP_locusTable<-read.delim("p3_SIMP_LocusTable_singleSNPs.txt",header=TRUE,stringsAsFactors=FALSE)
p3_SIMP_singleSNP_alleleReads<-read.delim("p3_SIMP_AlleleReads_singleSNPs.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)

head(p3_SIMP_singleSNP_locusTable)
p3_SIMP_singleSNP_alleleReads[1:5,1:5]

#generate singleSNP genotypes using the polyGen algorithm
p3_polyGenResults_singleSNP<-polyGen(p3_singleSNP_locusTable,p3_singleSNP_alleleReads)
p3_LWED_polyGenResults_singleSNP<-polyGen(p3_LWED_singleSNP_locusTable,p3_LWED_singleSNP_alleleReads)
p3_SIMP_polyGenResults_singleSNP<-polyGen(p3_SIMP_singleSNP_locusTable,p3_SIMP_singleSNP_alleleReads)

#look at first five rows and columns
p3_polyGenResults_singleSNP[1:5,1:5]
p3_LWED_polyGenResults_singleSNP[1:5,1:5]
p3_SIMP_polyGenResults_singleSNP[1:5,1:5]

#write results
write.table(p3_polyGenResults_singleSNP,"p3_polyGenResults_singleSNP.txt",quote=FALSE,sep="\t")
write.table(p3_LWED_polyGenResults_singleSNP,"p3_LWED_polyGenResults_singleSNP.txt",quote=FALSE,sep="\t")
write.table(p3_SIMP_polyGenResults_singleSNP,"p3_SIMP_polyGenResults_singleSNP.txt",quote=FALSE,sep="\t")
```

# 4 Data summaries

## 4.1 Locus summaries

### 4.1.1 Summarize single SNP results for loci

The summarizeGTscore command generates summary data for each locus in
table form. The summary data includes genotype rate, average read depth,
minor (least frequent) allele frequency, major (most frequent) allele
frequency, alleles per locus, and frequency per allele. Minor allele
frequency is a common metric for filtering loci that are likely to be
uninformative for population genetics; however, loci with haplotype
alleles may have an allele with very low frequency but still have
appreciable frequency at multiple other alleles. Because of this, the
major allele frequency is included in output, as well as the observed
frequencies for all alleles at a given locus.

#### 4.1.1.1 Single SNP summaries: Pool 1

```{r}
#summarize single SNP results
p1_singleSNP_summary<-summarizeGTscore(p1_singleSNP_alleleReads, p1_singleSNP_locusTable, p1_polyGenResults_singleSNP) %>%
  mutate(primerPool = "1")
p1_LWED_singleSNP_summary<-summarizeGTscore(p1_LWED_singleSNP_alleleReads, p1_LWED_singleSNP_locusTable, p1_LWED_polyGenResults_singleSNP) %>%
  mutate(primerPool = "1")
p1_SIMP_singleSNP_summary<-summarizeGTscore(p1_SIMP_singleSNP_alleleReads, p1_SIMP_singleSNP_locusTable, p1_SIMP_polyGenResults_singleSNP) %>%
  mutate(primerPool = "1")
#view results
View(p1_singleSNP_summary)
View(p1_LWED_singleSNP_summary)
View(p1_SIMP_singleSNP_summary)
#write results
write.table(p1_singleSNP_summary,"p1_singleSNP_summary.txt",quote=FALSE,sep="\t",row.names=FALSE)
write.table(p1_LWED_singleSNP_summary,"p1_LWED_singleSNP_summary.txt",quote=FALSE,sep="\t",row.names=FALSE)
write.table(p1_SIMP_singleSNP_summary,"p1_SIMP_singleSNP_summary.txt",quote=FALSE,sep="\t",row.names=FALSE)
```

#### 4.1.1.2 Single SNP summaries: Pool 2

```{r}
#summarize single SNP results
p2_singleSNP_summary<-summarizeGTscore(p2_singleSNP_alleleReads, p2_singleSNP_locusTable, p2_polyGenResults_singleSNP) %>%
  mutate(primerPool = "2")
p2_LWED_singleSNP_summary<-summarizeGTscore(p2_LWED_singleSNP_alleleReads, p2_LWED_singleSNP_locusTable, p2_LWED_polyGenResults_singleSNP) %>%
  mutate(primerPool = "2")
p2_SIMP_singleSNP_summary<-summarizeGTscore(p2_SIMP_singleSNP_alleleReads, p2_SIMP_singleSNP_locusTable, p2_SIMP_polyGenResults_singleSNP) %>%
  mutate(primerPool = "2")
#view results
View(p2_singleSNP_summary)
View(p2_LWED_singleSNP_summary)
View(p2_SIMP_singleSNP_summary)
#write results
write.table(p2_singleSNP_summary,"p2_singleSNP_summary.txt",quote=FALSE,sep="\t",row.names=FALSE)
write.table(p2_LWED_singleSNP_summary,"p2_LWED_singleSNP_summary.txt",quote=FALSE,sep="\t",row.names=FALSE)
write.table(p2_SIMP_singleSNP_summary,"p2_SIMP_singleSNP_summary.txt",quote=FALSE,sep="\t",row.names=FALSE)
```

#### 4.1.1.3 Single SNP summaries: Pool 3

```{r}
#summarize single SNP results
p3_singleSNP_summary<-summarizeGTscore(p3_singleSNP_alleleReads, p3_singleSNP_locusTable, p3_polyGenResults_singleSNP) %>%
  mutate(primerPool = "3")
p3_LWED_singleSNP_summary<-summarizeGTscore(p3_LWED_singleSNP_alleleReads, p3_LWED_singleSNP_locusTable, p3_LWED_polyGenResults_singleSNP) %>%
  mutate(primerPool = "3")
p3_SIMP_singleSNP_summary<-summarizeGTscore(p3_SIMP_singleSNP_alleleReads, p3_SIMP_singleSNP_locusTable, p3_SIMP_polyGenResults_singleSNP) %>%
  mutate(primerPool = "3")
#view results
View(p3_singleSNP_summary)
View(p3_LWED_singleSNP_summary)
View(p3_SIMP_singleSNP_summary)
#write results
write.table(p3_singleSNP_summary,"p3_singleSNP_summary.txt",quote=FALSE,sep="\t",row.names=FALSE)
write.table(p3_LWED_singleSNP_summary,"p3_LWED_singleSNP_summary.txt",quote=FALSE,sep="\t",row.names=FALSE)
write.table(p3_SIMP_singleSNP_summary,"p3_SIMP_singleSNP_summary.txt",quote=FALSE,sep="\t",row.names=FALSE)
```

### 4.1.2 Generate locus summary files with single SNP summaries + GTscore locus summaries created earlier

#### 4.1.2.1 Primer Pool 1

```{r}
# Load locus summaries
p1_ls <- read.table("p1_GTscore_locusSummary.txt", header = T, sep = "\t")
p1_lwed_ls <- read.table("p1_LWED_GTscore_locusSummary.txt", header = T, sep = "\t")
p1_simp_ls <- read.table("p1_SIMP_GTscore_locusSummary.txt", header = T, sep = "\t")

# Separate locus summaries and singleSNP summaries into results from shared and species-specific loci analyses
## Locus summaries
p1_ls1 <- p1_ls %>%
  filter(!str_detect(Locus, "LWED|SIMP"))
p1_lwed1_ls <- p1_lwed_ls %>%
  filter(str_detect(Locus, "LWED"))
p1_simp1_ls <- p1_simp_ls %>%
  filter(str_detect(Locus, "SIMP"))

## SingleSNP summaries
p1_ss <- p1_singleSNP_summary %>%
  filter(!str_detect(Locus_ID, "LWED|SIMP"))
p1_lwed_ss <- p1_LWED_singleSNP_summary %>%
  filter(str_detect(Locus_ID, "LWED"))
p1_simp_ss <- p1_SIMP_singleSNP_summary %>%
  filter(str_detect(Locus_ID, "SIMP"))

View(p1_ss)

# Recombine locus summaries & single snp summary files, then merge the two
p1_ls_recombine <- rbind(p1_ls1, p1_lwed1_ls, p1_simp1_ls)
View(p1_ls_recombine)

p1_ss_recombine <- rbind(p1_ss, p1_lwed_ss, p1_simp_ss)
p1_ss_recombine$Locus_ID <- sub("^([^_]*_[^_]*).*", "\\1", p1_ss_recombine$Locus_ID)
View(p1_ss_recombine)

p1_ls_ss <- merge(p1_ls_recombine, p1_ss_recombine, by.x = "Locus", by.y = "Locus_ID") 
View(p1_ls_ss)
```

#### 4.1.2.2 Primer Pool 2

```{r}
# Load locus summaries
p2_ls <- read.table("p2_GTscore_locusSummary.txt", header = T, sep = "\t")
p2_lwed_ls <- read.table("p2_LWED_GTscore_locusSummary.txt", header = T, sep = "\t")
p2_simp_ls <- read.table("p2_SIMP_GTscore_locusSummary.txt", header = T, sep = "\t")

# Separate locus summaries and singleSNP summaries into results from shared and species-specific loci analyses
## Locus summaries
p2_ls1 <- p2_ls %>%
  filter(!str_detect(Locus, "LWED|SIMP"))
p2_lwed1_ls <- p2_lwed_ls %>%
  filter(str_detect(Locus, "LWED"))
p2_simp1_ls <- p2_simp_ls %>%
  filter(str_detect(Locus, "SIMP"))

## SingleSNP summaries
p2_ss <- p2_singleSNP_summary %>%
  filter(!str_detect(Locus_ID, "LWED|SIMP"))
p2_lwed_ss <- p2_LWED_singleSNP_summary %>%
  filter(str_detect(Locus_ID, "LWED"))
p2_simp_ss <- p2_SIMP_singleSNP_summary %>%
  filter(str_detect(Locus_ID, "SIMP"))

View(p2_ss)

# Recombine locus summaries & single snp summary files, then merge the two
p2_ls_recombine <- rbind(p2_ls1, p2_lwed1_ls, p2_simp1_ls)
View(p1_ls_recombine)

p2_ss_recombine <- rbind(p2_ss, p2_lwed_ss, p2_simp_ss)
p2_ss_recombine$Locus_ID <- sub("^([^_]*_[^_]*).*", "\\1", p2_ss_recombine$Locus_ID)
View(p2_ss_recombine)

p2_ls_ss <- merge(p2_ls_recombine, p2_ss_recombine, by.x = "Locus", by.y = "Locus_ID") 
View(p2_ls_ss)
```

#### 4.1.2.3 Primer Pool 3

```{r}
# Load locus summaries
p3_ls <- read.table("p3_GTscore_locusSummary.txt", header = T, sep = "\t")
p3_lwed_ls <- read.table("p3_LWED_GTscore_locusSummary.txt", header = T, sep = "\t")
p3_simp_ls <- read.table("p3_SIMP_GTscore_locusSummary.txt", header = T, sep = "\t")

# Separate locus summaries and singleSNP summaries into results from shared and species-specific loci analyses
## Locus summaries
p3_ls1 <- p3_ls %>%
  filter(!str_detect(Locus, "LWED|SIMP"))
p3_lwed1_ls <- p3_lwed_ls %>%
  filter(str_detect(Locus, "LWED"))
p3_simp1_ls <- p3_simp_ls %>%
  filter(str_detect(Locus, "SIMP"))

## SingleSNP summaries
p3_ss <- p3_singleSNP_summary %>%
  filter(!str_detect(Locus_ID, "LWED|SIMP"))
p3_lwed_ss <- p3_LWED_singleSNP_summary %>%
  filter(str_detect(Locus_ID, "LWED"))
p3_simp_ss <- p3_SIMP_singleSNP_summary %>%
  filter(str_detect(Locus_ID, "SIMP"))

View(p3_ss)

# Recombine locus summaries & single snp summary files, then merge the two
p3_ls_recombine <- rbind(p3_ls1, p3_lwed1_ls, p3_simp1_ls)
View(p1_ls_recombine)

p3_ss_recombine <- rbind(p3_ss, p3_lwed_ss, p3_simp_ss)
p3_ss_recombine$Locus_ID <- sub("^([^_]*_[^_]*).*", "\\1", p3_ss_recombine$Locus_ID)
View(p3_ss_recombine)

p3_ls_ss <- merge(p3_ls_recombine, p3_ss_recombine, by.x = "Locus", by.y = "Locus_ID") 
View(p3_ls_ss)
```

#### 4.1.2.4 Create master locus summary file

```{r}
p123_ls_ss <- rbind(p1_ls_ss, p2_ls_ss, p3_ls_ss)
View(p123_ls_ss)

# Export
write.csv(p123_ls_ss, "./summaryFiles/p123_master_locusSummary.csv", row.names = F)
```

### 4.1.3 Generate plots for single SNP results

NOTE - plots below are for full dataset only (not LWED and SIMP subsets)

plot genotype rate

```{r locus genotype rate, warning=FALSE}
ggplot()+geom_histogram(data=singleSNP_summary,aes(x=GenotypeRate),binwidth=0.03)+xlim(-0.01,1.01)+
  labs(title="Locus Genotype Rate", x="Genotype Rate", y="Count")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))
```

plot average read depth for single SNP data

```{r locus read depth}
ggplot()+geom_histogram(data=singleSNP_summary,aes(x=AvgReadDepth),binwidth=20)+
  labs(title="Average Read Depth per SNP", x="Average Read Depth", y="Count")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))
```

plot genotype rate relative to average depth

```{r locus genotype rate vs read depth}
ggplot()+geom_point(data=singleSNP_summary,aes(x=AvgReadDepth,y=GenotypeRate))+ylim(0,1)+
  labs(title="Genotype Rate vs Average Depth per SNP", x="Average Depth", y="Genotype Rate")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))
```

plot distribution of minor allele frequency

```{r histogram of MAF, warning=FALSE}
ggplot()+geom_histogram(data=singleSNP_summary,aes(x=minAF),binwidth=0.01)+
  labs(title="Minor Allele Frequency Single SNP", x="Minor Allele Frequency", y="Count")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))
```

plot distribution of major allele frequency

```{r histogram of MajAF, warning=FALSE}
ggplot()+geom_histogram(data=singleSNP_summary,aes(x=majAF),binwidth=0.01)+
  labs(title="Major Allele Frequency Single SNP", x="Major Allele Frequency", y="Count")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))
```

## 4.2 Sample summaries

load sample summaries from AmpliconReadCounter

```{r}
# Pool 1
p1_GTscore_individualSummary<-read.delim("p1_GTscore_individualSummary.txt",header=TRUE,stringsAsFactors=FALSE)
p1_LWED_GTscore_individualSummary<-read.delim("p1_LWED_GTscore_individualSummary.txt",header=TRUE,stringsAsFactors=FALSE)
p1_SIMP_GTscore_individualSummary<-read.delim("p1_SIMP_GTscore_individualSummary.txt",header=TRUE,stringsAsFactors=FALSE)

# Pool 2
p2_GTscore_individualSummary<-read.delim("p2_GTscore_individualSummary.txt",header=TRUE,stringsAsFactors=FALSE)
p2_LWED_GTscore_individualSummary<-read.delim("p2_LWED_GTscore_individualSummary.txt",header=TRUE,stringsAsFactors=FALSE)
p2_SIMP_GTscore_individualSummary<-read.delim("p2_SIMP_GTscore_individualSummary.txt",header=TRUE,stringsAsFactors=FALSE)

# Pool 2
p3_GTscore_individualSummary<-read.delim("p3_GTscore_individualSummary.txt",header=TRUE,stringsAsFactors=FALSE)
p3_LWED_GTscore_individualSummary<-read.delim("p3_LWED_GTscore_individualSummary.txt",header=TRUE,stringsAsFactors=FALSE)
p3_SIMP_GTscore_individualSummary<-read.delim("p3_SIMP_GTscore_individualSummary.txt",header=TRUE,stringsAsFactors=FALSE)
```

#### 4.2.1) Summarize single SNP summaries for samples

```{r}
# Pool 1
p1_singleSNP_sampleSummary<-summarizeSamples(p1_polyGenResults_singleSNP,p1_singleSNP_alleleReads)
p1_LWED_singleSNP_sampleSummary<-summarizeSamples(p1_LWED_polyGenResults_singleSNP,p1_LWED_singleSNP_alleleReads)
p1_SIMP_singleSNP_sampleSummary<-summarizeSamples(p1_SIMP_polyGenResults_singleSNP,p1_SIMP_singleSNP_alleleReads)

# Pool 2
p2_singleSNP_sampleSummary<-summarizeSamples(p2_polyGenResults_singleSNP,p2_singleSNP_alleleReads)
p2_LWED_singleSNP_sampleSummary<-summarizeSamples(p2_LWED_polyGenResults_singleSNP,p2_LWED_singleSNP_alleleReads)
p2_SIMP_singleSNP_sampleSummary<-summarizeSamples(p2_SIMP_polyGenResults_singleSNP,p2_SIMP_singleSNP_alleleReads)

# Pool 3
p3_singleSNP_sampleSummary<-summarizeSamples(p3_polyGenResults_singleSNP,p3_singleSNP_alleleReads)
p3_LWED_singleSNP_sampleSummary<-summarizeSamples(p3_LWED_polyGenResults_singleSNP,p3_LWED_singleSNP_alleleReads)
p3_SIMP_singleSNP_sampleSummary<-summarizeSamples(p3_SIMP_polyGenResults_singleSNP,p3_SIMP_singleSNP_alleleReads)
```

#### 4.2.2) Pool 1: Combine AmpliconReadCounter individual summary with GTscore sample summary data

```{r}
# make new copies
p1_LWED_gtIndivSummary <- p1_LWED_GTscore_individualSummary
p1_SIMP_gtIndivSummary <- p1_SIMP_GTscore_individualSummary

#first adjust names from sample_genotypeRate_singleSNP to match GTscore_individualSummary (some of the GTscore functions change - to .)
p1_LWED_gtIndivSummary$Sample <- sub('tamRun2-', 'tamRun2.', p1_LWED_gtIndivSummary$Sample)
p1_LWED_gtIndivSummary<-merge(p1_LWED_gtIndivSummary,p1_LWED_singleSNP_sampleSummary,by.x="Sample",by.y="sample") %>%
  mutate(primerPool = "1") %>%
  mutate(lociSet = "LWED")

p1_SIMP_gtIndivSummary$Sample <- sub('tamRun2-', 'tamRun2.', p1_SIMP_gtIndivSummary$Sample)
p1_SIMP_gtIndivSummary<-merge(p1_SIMP_gtIndivSummary,p1_SIMP_singleSNP_sampleSummary,by.x="Sample",by.y="sample") %>%
  mutate(primerPool = "1") %>%
  mutate(lociSet = "SIMP")

# Combine LWED & SIMP to form one
p1_lwedSIMP_gtIndivSummary <- rbind(p1_LWED_gtIndivSummary, p1_SIMP_gtIndivSummary)
View(p1_lwedSIMP_gtIndivSummary)
```

#### 4.2.3) Pool 2: Combine AmpliconReadCounter individual summary data with GTscore sample summary

```{r}
# make new copies
p2_LWED_gtIndivSummary <- p2_LWED_GTscore_individualSummary
p2_SIMP_gtIndivSummary <- p2_SIMP_GTscore_individualSummary

#first adjust names from sample_genotypeRate_singleSNP to match GTscore_individualSummary (some of the GTscore functions change - to .)
p2_LWED_gtIndivSummary$Sample <- sub('tamRun2-', 'tamRun2.', p2_LWED_gtIndivSummary$Sample)
p2_LWED_gtIndivSummary<-merge(p2_LWED_gtIndivSummary,p2_LWED_singleSNP_sampleSummary,by.x="Sample",by.y="sample") %>%
  mutate(primerPool = "2") %>%
  mutate(lociSet = "LWED")

p2_SIMP_gtIndivSummary$Sample <- sub('tamRun2-', 'tamRun2.', p2_SIMP_gtIndivSummary$Sample)
p2_SIMP_gtIndivSummary<-merge(p2_SIMP_gtIndivSummary,p2_SIMP_singleSNP_sampleSummary,by.x="Sample",by.y="sample") %>%
  mutate(primerPool = "2") %>%
  mutate(lociSet = "SIMP")

# Combine LWED & SIMP to form one
p2_lwedSIMP_gtIndivSummary <- rbind(p2_LWED_gtIndivSummary, p2_SIMP_gtIndivSummary)
View(p2_lwedSIMP_gtIndivSummary)
```

#### 4.2.4) Pool 3: Combine AmpliconReadCounter individual summary data with GTscore sample summary

```{r}
# make new copies
p3_LWED_gtIndivSummary <- p3_LWED_GTscore_individualSummary
p3_SIMP_gtIndivSummary <- p3_SIMP_GTscore_individualSummary

#first adjust names from sample_genotypeRate_singleSNP to match GTscore_individualSummary (some of the GTscore functions change - to .)
p3_LWED_gtIndivSummary$Sample <- sub('tamRun2-', 'tamRun2.', p3_LWED_gtIndivSummary$Sample)
p3_LWED_gtIndivSummary<-merge(p3_LWED_gtIndivSummary,p3_LWED_singleSNP_sampleSummary,by.x="Sample",by.y="sample") %>%
  mutate(primerPool = "3") %>%
  mutate(lociSet = "LWED")

p3_SIMP_gtIndivSummary$Sample <- sub('tamRun2-', 'tamRun2.', p3_SIMP_gtIndivSummary$Sample)
p3_SIMP_gtIndivSummary<-merge(p3_SIMP_gtIndivSummary,p3_SIMP_singleSNP_sampleSummary,by.x="Sample",by.y="sample") %>%
  mutate(primerPool = "3") %>%
  mutate(lociSet = "SIMP")

# Combine LWED & SIMP to form one
p3_lwedSIMP_gtIndivSummary <- rbind(p3_LWED_gtIndivSummary, p3_SIMP_gtIndivSummary)
View(p3_lwedSIMP_gtIndivSummary)
```

#### 4.2.5) Create master sample summary file & add metadata

```{r}
# Read in new copy of metdata without changing sampleID format
md2 <- read.csv(here("./seqAnalysis/01_run2_fecalHairBlood/03_run2GTscore/metadata_tamRun2.csv")) %>%
  filter(included_inRun == "yes")
View(md2)

# Combine sample summaries from each primer pool & adjust sampleID format
p123_lwedSIMP_gtindivSummary <- rbind(p1_lwedSIMP_gtIndivSummary, p2_lwedSIMP_gtIndivSummary, p3_lwedSIMP_gtIndivSummary) %>%
  separate(Sample, into = "sampleID", sep = 11, remove = F)

p123_lwedSIMP_gtindivSummary$sampleID <- gsub("\\.", "_", p123_lwedSIMP_gtindivSummary$sampleID)

# Merge metadata & combined sample summaries
p123_master_sampleSummary <- merge(p123_lwedSIMP_gtindivSummary, md2, by = "sampleID")
View(p123_master_sampleSummary)

# Export
write.csv(p123_master_sampleSummary, "./summaryFiles/p123_master_sampleSummary.csv", row.names = F)
```

#### plots

plot histogram of genotype rate

```{r histogram of genotype rate, warning=FALSE}
ggplot()+geom_histogram(data=p123_master_sampleSummary,aes(x=GenotypeRate),binwidth=0.03)+xlim(-0.01,1.01)+
  labs(title="Sample Genotype Rate", x="Genotype Rate", y="Count")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))
```

plot histogram of heterozygosity

```{r histogram of heterozygosity, warning=FALSE}
ggplot()+geom_histogram(data=p123_master_sampleSummary,aes(x=Heterozygosity),binwidth=0.03)+xlim(-0.01,1.01)+
  labs(title="Sample Heterozygosity", x="Heterozygosity", y="Count")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))
```

plot genotype rate vs primer probe reads

```{r genotype rate vs primer probe reads}
#dashed line added at 90% genotype rate, this is not a strict threshold, just a goal to aim for
ggplot()+geom_point(data=p123_master_sampleSummary,aes(x=Primer.Probe.Reads,y=GenotypeRate))+
  labs(title="Genotype Rate vs Total Reads per Sample", x="Primer Probe Reads", y="Genotype Rate")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))+
  geom_hline(yintercept=0.9,lty="dashed")
```

Samples with unusually high heterozygosity may be contaminated or have
elevated ploidy. [[Given chimerism, however, this isn't super helpful
for blood samples]]

plot heterozygosity vs primer probe reads

```{r heterozygosity vs primer probe reads}
ggplot()+geom_point(data=p123_master_sampleSummary,aes(x=Primer.Probe.Reads,y=Heterozygosity))+
  labs(title="Heterozygosity vs Total Reads per Sample", x="Primer Probe Reads", y="Heterozygosity")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))+
  geom_hline(yintercept=0.3, lty="dashed")
```

# 5 Quality control

#### Identify duplicate samples

The IDduplicateSamples function does all pairwise comparisons of samples
and outputs two metrics:

-   proportionCommon - The proportion of loci that had genotypes for
    both samples in a pair
-   proportionMatch - The proportion of loci that have identical
    genotypes in the sample pair

```{r identify duplicate samples,eval=FALSE}
#convert missing genotypes "0" to NA
polyGenResults_singleSNP_NA<-polyGenResults_singleSNP
polyGenResults_singleSNP_NA[polyGenResults_singleSNP_NA=="0"]<-NA

#compare all samples, for each comparison get proportion of loci that have genotypes
#in both samples (proportionCommon) and proportion of shared loci that have identical
#genotypes (proportionMatch).
#Samples with a high proportionCommon and high proportionMatch are likely duplicates
polyGenResults_dupTest<-IDduplicateSamples(polyGenResults_singleSNP_NA)

write.table(polyGenResults_dupTest,"run2_polyGenResults_dupTest.txt",quote=FALSE,sep="\t",row.names=FALSE)

```

```{r duplicate sample results}
polyGenResults_dupTest<-read.delim("run2_polyGenResults_dupTest.txt",stringsAsFactors=FALSE)
head(polyGenResults_dupTest)
```

polyGenResults_dupTest

Plot results of IDduplicateSamples

McKinney says that he generally sets thresholds of proportionMatch \>
0.8 and proportionCommon \> 0.75 to identify duplicate sample pairs, but
the appropriate thresholds will depend on the marker set being used and
the relatedness among samples. In this plot, he notes that it is
possible that individuals at the lower range of identical genotypes
(\~0.85) are relatives rather than duplicated samples.

```{r plot IDduplicateSamples results}
#potential duplicates are proportionMatch>0.8 and proportionCommon>0.75
#feel free to adjust these thresholds as needed
matchThresh=0.8
commonThresh=0 #switched to 0, looks like some loci were successfully genotyped for one sample and some for the other

#plot results
ggplot()+geom_point(data=polyGenResults_dupTest,aes(x=proportionCommon,y=proportionMatch))+
  geom_segment(aes(x=commonThresh,xend=1,y=matchThresh,yend=matchThresh),lty="dashed")+
  geom_segment(aes(x=commonThresh,xend=commonThresh,y=matchThresh,yend=1),lty="dashed")
```

Identify duplicate sample pairs with thresholds set previously

```{r}
#filter to potentially duplicated samples using thresholds above
polyGenResults_dupTest %>% filter(proportionMatch>=matchThresh,proportionCommon>=commonThresh)

```

#### Identify contaminated samples

Contaminated samples can be identified through elevated heterozygosity.
NOTE- this isn't going to be helpful for us given the blood chimerism.

```{r identify contaminated samples (heterozygosity)}
#plot heterozygosity vs genotype rate per sample
#samples with unusually high heterozygosity relative to others are candidates for contamination
#the sample above the dashed line in this example is likely contaminated
ggplot()+geom_point(data=GTscore_individualSummary,aes(x=GenotypeRate,y=Heterozygosity))+
  labs(title="Heterozygosity vs Genotype Rate per Sample", x="Genotype Rate", y="Heterozygosity")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))+
  geom_hline(yintercept=0.30, lty="dashed")
```

Set heterozygosity treshold to identify likely contaminated sample

```{r}
#identify likely contaminated sample
contaminatedSample<-GTscore_individualSummary %>% filter(Heterozygosity>0.30) %>% pull(Sample)
contaminatedSample
```

Contaminated samples can also be identified by an elevated contamination
score. In this example, samples with a contamination score \> 0.3 are
known to be contaminated.

```{r }
#plot histogram of contamination score
ggplot()+geom_histogram(data=GTscore_individualSummary,aes(x=conScore),binwidth=0.02)+geom_vline(xintercept=0.3,lty="dashed")

```

Set contamination score treshold to identify contaminated samples

```{r}
#identify likely contaminated samples
contaminatedSamples2<-GTscore_individualSummary %>% filter(conScore>=0.3) %>% pull(Sample)
contaminatedSamples2
```

Plot genotype scatterplots for each sample

```{r}
#Scatter Plots can show evidence of contamination or elevated ploidy
plotGenotypes_sample(singleSNP_locusTable, singleSNP_alleleReads, polyGenResults_singleSNP, type='scatter', savePlot="Y", saveDir="scatterPlots_sample")
#look at plots for samples, particularly for putatively contaminated samples identified by high heterozygosity
```

```{r,echo = FALSE}
library(knitr)
```

#### Identify poor quality loci to remove

Flag SNPs with \< 50% genotype rate as candidates for removal. Will need
to do this with LWED and SIMP samples separately, then recombine.

```{r}
poorQualitySNPs <- p1_ls_ss %>% filter(GenotypeRate<0.5) %>% mutate(Locus=as.character(Locus)) %>% pull(Locus)

View(poorQualitySNPs)

pq_lwed <- data.frame(name=poorQualitySNPs_LWED) %>%
  mutate(species="LWED")
pq_simp<- data.frame(name=poorQualitySNPs_SIMP) %>%
  mutate(species="SIMP")

pq_both <- rbind(pq_lwed, pq_simp)
View(pq_both)

pq_both2 <- pq_both %>%
  group_by(name) %>%
  mutate(count=n()) %>%
  distinct(name, .keep_all = T) %>%
  within(species[count == '2'] <- "both")
View(pq_both2)

# Export file
write.csv(pq_both2, "./summaryFiles/poorQualitySNPs_combined.csv", row.names = F)
```

#### plots

Ratio & Scatter Plots can show evidence of systemic issues in read
counting (off-target reads, biases) or elevated ploidy

Plot genotype ratio & scatterplots for each locus

```{r}
#Allele Ratio Plots  
plotGenotypes(singleSNP_locusTable, singleSNP_alleleReads, polyGenResults_singleSNP, type='ratio', savePlot="Y", saveDir="ratioPlots_loci")
#Scatter Plots 
plotGenotypes(singleSNP_locusTable, singleSNP_alleleReads, polyGenResults_singleSNP, type='scatter', savePlot="Y", saveDir="scatterPlots_loci")
```

Plot histogram of contamination score for loci. An arbitrary score of
0.3 was set to identify problematic loci, but a lower or higher
threshold may be more suitable. Visual examination of loci with elevated
scores is recommended. In cases where there are very few heterozygous
individuals, a high contamination score may be not truly reflect locus
performance..

```{r, warning=FALSE}
#loci with high contamination scores should have scatterplots examined to ensure genotypes look accurate
singleSNP_summary %>% ggplot(data=.) + geom_histogram(aes(x=conScore),binwidth=0.01)+geom_vline(xintercept=0.3)
```

Plot contamination score vs minor allele frequency. Loci with both a
high contamination score and high minor allele frequency are likely to
be problematic.

```{r, warning=FALSE}
singleSNP_summary %>% ggplot(data=.) + geom_point(aes(x=conScore,y=minAF))
```

Get list of loci with high contamination score

```{r}
singleSNP_summary %>% filter(conScore>0.3)
```

Look at scatterplots for loci with high contamination score. See orignal
GTscore README.Rmd for examples of a paralog, locus w/likely off-target
sequence, locus w/high contamination score but may be fine.

# 6 Export genotype files

When exporting files, you can either export the full results and remove
any poor quality samples or loci afterwards, or you can use whitelists
or blacklists to filter during export. Both the exportGenepop and
exportRubias functions have the following options: sampleWhitelist,
locusWhitelist, sampleBlacklist, locusBlacklist. The whitelists are a
list of samples or loci to retain, the blacklists are lists of samples
or loci to discard.

#### Genepop format

export genepop format - no filtering

```{r}
#export genepop, no filtering
exportGenepop(polyGenResults_singleSNP,singleSNP_locusTable,filename="polyGenResults_singleSNP_genepop.txt")
```

export genepop format - poor quality loci removed

```{r}
#example with poor quality loci and contaminated sample removed
exportGenepop(polyGenResults_singleSNP,singleSNP_locusTable,
              locusBlacklist=poorQualitySNPs,
              filename="polyGenResults_singleSNP_genepop_filtered.txt")
```

#### Rubias format

Data output for Rubias should have metadata associated with each sample
that specifies the sample type, mixture if a mixture sample, reference
if a baseline sample, the reporting group, the sample collection, and
individual name.

Sample metadata columns should have the following names: sample_type,
repunit, collection, indiv

metadata can be created here or loaded from file

create sample metadata for mixture sample

```{r}
#load sample data file
sampleMetaData<-read.delim("sampleMetaData.csv",header=TRUE, sep = ",")
#adjust indiv names in metadata (some of the GTscore functions change - to .)
sampleMetaData$indiv <- sub('tamOpt-', 'tamOpt.', sampleMetaData$indiv)
#view
View(sampleMetaData)
```

export Rubias format with no filtering

```{r}
#export rubias format
exportRubias(polyGenResults_singleSNP,singleSNP_locusTable,sampleMetaData,filename="polyGenResults_singleSNP_rubias.txt")
exportRubias(polyGenResults_singleSNP_LWED,singleSNP_locusTable_LWED,sampleMetaData,filename="polyGenResults_singleSNP_rubias_LWED.txt")
exportRubias(polyGenResults_singleSNP_SIMP,singleSNP_locusTable_SIMP,sampleMetaData,filename="polyGenResults_singleSNP_rubias_SIMP.txt")
```

export Rubias format with poor quality loci and contaminated sample
removed

```{r}
exportRubias(polyGenResults_singleSNP,singleSNP_locusTable,sampleMetaData,
             locusBlacklist=poorQualitySNPs,
             filename="polyGenResults_singleSNP_rubias_filtered.txt")
exportRubias(polyGenResults_singleSNP_LWED,singleSNP_locusTable_LWED,sampleMetaData,
             locusBlacklist=poorQualitySNPs_LWED,
             filename="polyGenResults_singleSNP_rubias_filtered_LWED.txt")
exportRubias(polyGenResults_singleSNP_SIMP,singleSNP_locusTable_SIMP,sampleMetaData,
             locusBlacklist=poorQualitySNPs_SIMP,
             filename="polyGenResults_singleSNP_rubias_filtered_SIMP.txt")
```

# 7 Locus diagnostics

Diagnostic functions are provided to help in identifying patterns of
sequence variation for loci. This can assist in identifying SNPs that
were not accounted for in the initial probe design and in adjusting the
in-silico probes to exclude off-target sequence from genotyping.

There are two approaches used by GTscore: First, plotting the number of
nucleotide mismatches by position in the sequence data relative to the
reference sequence for each locus, and second, performing sequence
alignments using the program MSA (Bodenhofer et al. 2015). Plotting the
mismatches by position is fast and easy to interpret except in the case
of indels. The MSA alignments take longer to complete but facilitate the
visualization of indels.

The first step for both methods is to get the sequences that aligned to
each locus, this can be done based on primer alignments or primer-probe
alignments using the script matchReads.pl.

### Sequence alignment to each locus (Perl)

Input flags for this script are: \* --p a tab delimited file containing
primer/probe information for each locus \* --files a text file
containing a list of .fastq sequence files to count reads from \*
--matchType the match type chosen for retaining sequences for each
locus. Options are "primer" to retain sequences that match the primer
for a locus or "primerProbe" to retain sequences that match both the
primer and probe. primerProbe is the default if no option is specified.

Optional flags: \* --prefix optional prefix for output file names

You can run matchReads.pl from the command line using the following
example: perl matchReads.pl -p primerProbeFile.txt --files
sampleFiles.txt --matchType primerProbe [--prefix]

Alternatively, you can also run it through R:

```{r match reads, eval=FALSE}
#primer match
system2("perl",
        args="matchReads.pl -p primerProbeFile.txt --files sampleFiles.txt --matchType primer")
system2("perl",
        args="matchReads.pl -p primerProbeFile.txt --files sampleFiles_LWED.txt --matchType primer --prefix LWED_")
system2("perl",
        args="matchReads.pl -p primerProbeFile.txt --files sampleFiles_SIMP.txt --matchType primer --prefix SIMP_")

#primer AND probe match
system2("perl",
        args="matchReads.pl -p primerProbeFile.txt --files sampleFiles.txt --matchType primerProbe")
system2("perl",
        args="matchReads.pl -p primerProbeFile.txt --files sampleFiles_LWED.txt --matchType primerProbe --prefix LWED_")
system2("perl",
        args="matchReads.pl -p primerProbeFile.txt --files sampleFiles_SIMP.txt --matchType primerProbe --prefix SIMP_")
```

The default output file names are matchReads_primerAligned.txt or
matchReads_primerProbeAligned.txt depending on which match type was
chosen.

### Create reference amplicon sequences file

To conduct locus diagnostics, we need both a text file and fasta file of
reference amplicon sequences. The sequences are already in Sam's
pos_amplicon.csv file, we just need to get it in the right format:

Text file first:

```{r create reference sequences file}
# Packages
library(Biostrings)
library(tidyverse)

# Import data
amplicon_csv <- read.csv("pos_amplicon.csv", sep = ",")
View(amplicon_csv)
translation <- read.csv("primers_seqName_to_shortName.csv")
View(translation)

# Subset to get names and amplicon sequences only & remove brackets
amplicons <- amplicon_csv %>%
  select(c("SNP_name", "amplicon")) %>%
  mutate(amplicon = str_replace_all(amplicon, "\\[|\\]", ""))
View(amplicons)

# Add short names to to amplicon seqs
amplicons_shortnames <- merge(amplicons, translation, by.x = "SNP_name", by.y = "seqID1") %>%
  select(c("primerName2", "amplicon")) %>%
  dplyr::rename(Locus=primerName2, refSeq=amplicon)
View(amplicons_shortnames)
length(amplicons_shortnames$Locus) #226 - good!

# Create LWED and SIMP subsets
amplicons_lwed <- amplicons_shortnames %>%
  filter(!str_detect(Locus, "SIMP"))

amplicons_simp <- amplicons_shortnames %>%
  filter(!str_detect(Locus, "LWED"))


# Export
write.table(amplicons_shortnames, "./ampliconRefSeqs.txt", sep= "\t", row.names = F, quote = F)
write.table(amplicons_lwed, "./ampliconRefSeqs_LWED.txt", sep= "\t", row.names = F, quote = F)
write.table(amplicons_simp, "./ampliconRefSeqs_SIMP.txt", sep= "\t", row.names = F, quote = F)
```

Then fasta file:

```{r create amplicon fasta file}
library(phylotools)

amplicon_txt <- read.table("ampliconRefSeqs.txt", header = T) %>%
  dplyr::rename(c(seq.name=Locus, seq.text=refSeq))
View(amplicon_txt)

dat2fasta(amplicon_txt, outfile = "ampliconRefSeqs.fasta")

amplicon_txt_lwed <- read.table("ampliconRefSeqs_LWED.txt", header = T) %>%
  dplyr::rename(c(seq.name=Locus, seq.text=refSeq))
View(amplicon_txt_lwed)

dat2fasta(amplicon_txt_lwed, outfile = "ampliconRefSeqs_LWED.fasta")

amplicon_txt_simp <- read.table("ampliconRefSeqs_SIMP.txt", header = T) %>%
  dplyr::rename(c(seq.name=Locus, seq.text=refSeq))
View(amplicon_txt_simp)

dat2fasta(amplicon_txt_simp, outfile = "ampliconRefSeqs_SIMP.fasta")
```

### MSA alignment (GTscore.R)

MSA alignment of the matched reads can be done directly on the output
from matchReads.pl using the alignMatchedSeqs command in GTscore. Probe
sequence is incorporated into the alignment to visualize how probes may
be affecting read counting, and reference sequence can optionally be
included to facilitate comparison of the observed sequence with the
target locus. The probe sequence is obtained from the primer-probe file
originally used by AmpliconReadCounter.pl; the reference sequence file
has a two column format where the first column is the locus name and the
second column is the reference sequence for the locus amplicon. MSA will
take a very long time to run if too many sequences are included for
alignment so a minimum read threshold (minReads) is included as an
option in the alignment command (suggest begin with minReads=20). In
addition, a maximum of 100 unique sequences (ranked by number of reads)
will be aligned. The maximum number of reads allowed for alignment can
be changed using the maxAlignedSeqs option. Be sure the required perl
package has been installed (Excel-Writer-XLSX).

```{r MSA alignment}
#load reference sequences in table format
referenceSeqs<-read.delim("ampliconRefSeqs.txt", header=TRUE, stringsAsFactors=FALSE )
referenceSeqs_LWED<-read.delim("ampliconRefSeqs_LWED.txt", header=TRUE, stringsAsFactors=FALSE )
referenceSeqs_SIMP<-read.delim("ampliconRefSeqs_SIMP.txt", header=TRUE, stringsAsFactors=FALSE )
View(referenceSeqs)
length(referenceSeqs$Locus)

#load primer probe file
primerProbes<-read.delim("primerProbeFile.txt", header=TRUE, stringsAsFactors=FALSE)
primerProbes_LWED<-read.delim("primerProbeFile_LWED.txt", header=TRUE, stringsAsFactors=FALSE)
primerProbes_SIMP<-read.delim("primerProbeFile_SIMP.txt", header=TRUE, stringsAsFactors=FALSE)
View(primerProbes)
length(primerProbes$Locus)

#primer aligned reads
primerMatchedReads<-read.delim("matchedReads_primerAligned.txt", header=TRUE, stringsAsFactors=FALSE)
View(primerMatchedReads)
alignMatchedSeqs(referenceSeqs=referenceSeqs,primerProbes=primerProbes,matchedReads=primerMatchedReads,minReads=20, maxAlignedSeqs=100,type="primer",saveDir="MSA_primerMatched")

primerMatchedReads_LWED<-read.delim("LWED_matchedReads_primerAligned.txt", header=TRUE, stringsAsFactors=FALSE)
View(primerMatchedReads_LWED)
alignMatchedSeqs(referenceSeqs=referenceSeqs_LWED,primerProbes=primerProbes_LWED,matchedReads=primerMatchedReads_LWED,minReads=20, maxAlignedSeqs=100,type="primer",saveDir="MSA_primerMatched_LWED")

primerMatchedReads_SIMP<-read.delim("SIMP_matchedReads_primerAligned.txt", header=TRUE, stringsAsFactors=FALSE)
View(primerMatchedReads_SIMP)
alignMatchedSeqs(referenceSeqs=referenceSeqs_SIMP,primerProbes=primerProbes_SIMP,matchedReads=primerMatchedReads_SIMP,minReads=20, maxAlignedSeqs=100,type="primer",saveDir="MSA_primerMatched_SIMP")

#primer probe aligned reads
primerProbeMatchedReads<-read.delim("matchedReads_primerProbeAligned.txt", header=TRUE, stringsAsFactors=FALSE)
alignMatchedSeqs(referenceSeqs=referenceSeqs, primerProbes=primerProbes, matchedReads=primerProbeMatchedReads,minReads=20, maxAlignedSeqs=100,type="primerProbe",saveDir="MSA_primerProbeMatched")

primerProbeMatchedReads_LWED<-read.delim("LWED_matchedReads_primerProbeAligned.txt", header=TRUE, stringsAsFactors=FALSE)
alignMatchedSeqs(referenceSeqs=referenceSeqs_LWED, primerProbes=primerProbes_LWED, matchedReads=primerProbeMatchedReads_LWED,minReads=20, maxAlignedSeqs=100,type="primerProbe",saveDir="MSA_primerProbeMatched_LWED")

primerProbeMatchedReads_SIMP<-read.delim("SIMP_matchedReads_primerProbeAligned.txt", header=TRUE, stringsAsFactors=FALSE)
alignMatchedSeqs(referenceSeqs=referenceSeqs_SIMP, primerProbes=primerProbes_SIMP, matchedReads=primerProbeMatchedReads_SIMP,minReads=20, maxAlignedSeqs=100,type="primerProbe",saveDir="MSA_primerProbeMatched_SIMP")
```

Excel files are output for each locus within the directory specified by
savDir. The first row is a consensus sequence based on the sequence
alignments. This is followed by the probes, reference sequence if
included, and then the sequence alignments.

### Plotting mismatches by position (Perl and GTscore.R)

#### Calculate sequence mismatches by position (Perl)

Plotting the number of mismatches by position requires first comparing
each matched sequence against the reference sequence and summing the
number of mismatches for each nucleotide position. This is done with the
perl script seqMismatchPositions.pl.

Input flags for this script are \* --amplicon a fasta file containing
the reference amplicon sequence for each locus \* --matchedSeqs a tab
delimited file containing sequences that matched each locus. This file
is generated by matchReads.pl \* --matchType the match type chosen for
retaining sequences for each locus. Options are "primer" to retain
sequences that match the primer for a locus or "primerProbe" to retain
sequences that match both the primer and probe. primerProbe is the
default if no option is specified.

Optional flags \* --prefix optional prefix for output file names

You can run matchReads.pl from the command line using the following
example: perl seqMismatchPositions.pl --amplicon ampliconRefSeqs.fasta
--matchedSeqs matchedReads_primerAligned.txt --matchType primer
[--prefix]

Alternatively, you can also run it through R:

```{r sequence mismatches, eval=FALSE}
# Combined
system2("perl",
        args="seqMismatchPositions.pl --amplicon ampliconRefSeqs.fasta --matchedSeqs matchedReads_primerAligned.txt --matchType primer")
system2("perl",
        args="seqMismatchPositions.pl --amplicon ampliconRefSeqs.fasta --matchedSeqs matchedReads_primerProbeAligned.txt --matchType primerProbe")

# LWED
system2("perl",
        args="seqMismatchPositions.pl --amplicon ampliconRefSeqs_LWED.fasta --matchedSeqs LWED_matchedReads_primerAligned.txt --matchType primer --prefix LWED_")
system2("perl",
        args="seqMismatchPositions.pl --amplicon ampliconRefSeqs_LWED.fasta --matchedSeqs LWED_matchedReads_primerProbeAligned.txt --matchType primerProbe --prefix LWED_")

# SIMP
system2("perl",
        args="seqMismatchPositions.pl --amplicon ampliconRefSeqs_SIMP.fasta --matchedSeqs SIMP_matchedReads_primerAligned.txt --matchType primer --prefix SIMP_")
system2("perl",
        args="seqMismatchPositions.pl --amplicon ampliconRefSeqs_SIMP.fasta --matchedSeqs SIMP_matchedReads_primerProbeAligned.txt --matchType primerProbe --prefix SIMP_")
```

The default output file names are mismatchPositions_primer.txt or
mismatchPositions_primerProbe.txt depending on which match type was
chosen. The output files will be used by the summarizeMismatches
function in GTscore to generate plots of mismatches by position for each
locus.

#### Plot of sequence mismatches by position (GTscore.R)

```{r}
#load results from seqMismatchPositions.pl
#primer matched sequences
mismatchPositionData_primer<-read.delim("mismatchPositions_primer.txt", header=TRUE, stringsAsFactors=FALSE)
mismatchPositionData_primer_LWED<-read.delim("mismatchPositions_LWED_primer.txt", header=TRUE, stringsAsFactors=FALSE)
mismatchPositionData_primer_SIMP<-read.delim("mismatchPositions_SIMP_primer.txt", header=TRUE, stringsAsFactors=FALSE)
#primer probe matched sequences
mismatchPositionData_primerProbe<-read.delim("mismatchPositions_primerProbe.txt", header=TRUE, stringsAsFactors=FALSE)
mismatchPositionData_primerProbe_LWED<-read.delim("mismatchPositions_LWED_primerProbe.txt", header=TRUE, stringsAsFactors=FALSE)
mismatchPositionData_primerProbe_SIMP<-read.delim("mismatchPositions_SIMP_primerProbe.txt", header=TRUE, stringsAsFactors=FALSE)


#generate plots of mismatches by position
#primer matched sequences
summarizeMismatches(mismatchPositionData_primer,saveDir="mismatchPositionPlots_primer")
summarizeMismatches(mismatchPositionData_primer_LWED,saveDir="mismatchPositionPlots_primer_LWED")
summarizeMismatches(mismatchPositionData_primer_SIMP,saveDir="mismatchPositionPlots_primer_SIMP")
#primer probe matched sequences
summarizeMismatches(mismatchPositionData_primerProbe,saveDir="mismatchPositionPlots_primerProbe")
summarizeMismatches(mismatchPositionData_primerProbe_LWED,saveDir="mismatchPositionPlots_primerProbe_LWED")
summarizeMismatches(mismatchPositionData_primerProbe_SIMP,saveDir="mismatchPositionPlots_primerProbe_SIMP")
```
