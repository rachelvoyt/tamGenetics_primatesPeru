---
title: "GTscorePipeline_tamRun4_nanopore"
author: "Rachel Voyt"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1 Packages

```{r load packages, include=FALSE}
source("./GTscore_sourceScripts/GTscore_modified.R") # NOTE- added N=ATGC to script for later analyses (not included in original)
library(gsubfn)
library(phylotools)
library(TidyMultiqc)
library(tidyverse)
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager", version = "3.16")
BiocManager::install("Biostrings")
```

# 2 Overview

## 2.1 About the pipeline

This pipeline is to analyze data from the ONT (Nanopore) run of tamRun4 (the 30x3 sample type comparison project).

## 2.2 About the data

The sequencing data used in this pipeline is from the full set of hair and blood samples and includes data from two MiSeq runs of this library. There are a total of **96 samples**, including 30 fecal samples, 29 hair samples (xxx LWED, xxx SIMP), 30 blood samples (xxx LWED, xxx SIMP), and 6 negative controls.

**NOTE** that of these samples, hair_tx105A_e1 was not added to PCR1; found the second elution too late to be included in the run. Treat as a negative when analysing the data.

### 2.2.1 Metadata

The metadata was created in GTscorePipeline_tamRun4 (for the Illumina results); editing here so that sequencing sample names are the same as the fastq files recieved.

#### Sample files

```{bash}
cd ./../02_run4Interleaved_ont

for i in *fastq; do echo $i; done > ./../03_run4GTscore_ont/ont_sampleFiles_fullSet.txt
```

#### Update metadata

NOTE that Nanopore sequences are arranged rowwise on the plate.

```{r}
rowValues_plate <- rep(LETTERS[1:8], times = 12) %>%
  sort()
colValues_plate <- rep(1:12, times = 8) %>%
  as.character()
wellValues_plate <- str_c(rowValues_plate, colValues_plate)

sf_fullSet_ont <- read.table("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_fullSet_sampleFiles.txt") %>%
  mutate(well = wellValues_plate)

md_tamRun4_ont <- read.csv("04_tamRun4/ill_tamRun4_metadata.csv") %>%
  merge(., sf_fullSet_ont, by = "well") %>%
  select(-sampleFile) %>%
  dplyr::rename("sampleFile" = "V1") %>%
  relocate(sampleFile, .after = sampleID) %>%
  relocate(well, .after = i7_index) %>%
  mutate(sampleID = substr(sampleFile, 1, 9)) %>%
  arrange(as.numeric(substr(sampleID, 8, 9)))

write.csv(md_tamRun4_ont, "./04_tamRun4/ont_tamRun4_metadata.csv", row.names = F)
```

Quick-load metadata:

```{r}
md_fullSet <- read.csv("./04_tamRun4/ont_tamRun4_metadata.csv")

md_fullSet_noNegs <- md_fullSet %>%
  filter(!str_detect(sampleType, "Neg"))

md_lwed_noNegs <- md_fullSet_noNegs %>%
  filter(species == "LWED")

md_simp_noNegs <- md_fullSet_noNegs %>%
  filter(species == "SIMP")
```

#### Sample lists

```{r}
lwed_sampleIDs <- filter(md_tamRun4_ont, is.na(species) | !species == "SIMP") %>%
  select(sampleID) %>%
  pull()
lwed_sampleFiles <- filter(md_tamRun4_ont, is.na(species) | !species == "SIMP") %>%
  select(sampleFile) %>%
  pull()

simp_sampleIDs <- filter(md_tamRun4_ont, is.na(species) | !species == "LWED") %>%
  select(sampleID) %>%
  pull()
simp_sampleFiles <- filter(md_tamRun4_ont, is.na(species) | !species == "LWED") %>%
  select(sampleFile) %>%
  pull()

neg_sampleIDs <- md_tamRun4_ont %>%
  filter(str_detect(sampleType, "Neg")) %>%
  select(sampleID) %>%
  pull()
neg_sampleFiles <- md_tamRun4_ont %>%
  filter(str_detect(sampleType, "Neg")) %>%
  select(sampleFile) %>%
  pull()
```

# 4 Quality checks **NOT UPDATED**

To get sequence quality scores for each sample, we can use 'fastqc' paired with 'MultiQC' -- 'fastp' is better for paired-end reads, but doesn't play nice when it comes to getting quality scores from the MultiQC report. Note that we'll be running quality checks on reads 1 and 2 separately (vs. interleaved).

## 4.1 De-interleave

I received the ONT fastq files already interleaved -- so that I can stay consistent with my quality check methods, I'm de-interleaving them below so that I can use the same quality-check scripts.

```{bash}
# example usage
reformat.sh in=reads.fq out1=read1.fq out2=read2.fq

# my usage
cd /home/rachelvoyt/Documents/UT-Grad/Development/repos/tamGenetics_primatesPeru/04_tamRun4/01_nanopore

for i in 02_run4Interleaved/*; do name=$(basename $i .all.fastq); reformat.sh in=02_run4Interleaved/${name}.all.fastq out1=00_run4Seqs/${name}_r1.fastq out2=00_run4Seqs/${name}_r2.fastq; done
```

## 4.2 fastqc + multiqc

*Note*: use "\--interactive" to force plots to tell you which line belongs to which sample, otherwise it will remove this option since there are so many samples in this run

```{bash eval = F}
# Activate fastqc environment
cd /home/rachelvoyt/Documents/UT-Grad/Development/repos/tamGenetics_primatesPeru/04_tamRun4/01_nanopore/01_run4QualityChecks

conda activate fastqc-env

# Run fastqc
for i in ../00_run4Seqs/*; do fastqc $i; done

# Move fastqc files to quality checks folder
mv ../00_run4Seqs/*fastqc* .

# Activate multiqc environment
conda activate multiqc-env

# Run MultiQC on all files within the quality checks folder
multiqc --interactive .
```

## 4.2 TidyMultiqc

To convert the MultiQC into something more usable in R, we can use the package 'TidyMultiqc', which converts the 'multiqc_data.json' file into tidy data frames.

Load FastQC MultiQC report to R

```{r}
MultiQCfastQCpath <- file.path("/home/rachelvoyt/Documents/UT-Grad/Development/repos/tamGenetics_primatesPeru/04_tamRun4/01_nanopore/01_run4QualityChecks/multiqc_data", "multiqc_data.json")

MultiQCfastQC <- TidyMultiqc::load_multiqc(MultiQCfastQCpath, sections = c("general", "raw"))
```

### 4.2.1 Obtain median sequence quality scores

For the analyses in this section, I followed [this vignette](https://cran.r-project.org/web/packages/TidyMultiqc/vignettes/TidyMultiqc.html) provided by the makers of the TidyMultiqc package.

MultiQC reports do not provide a numerical summary statistic for read quality; they only have mapping quality and pass/fails for the per-base sequence quality. We instead need to pull this data from one of the plots -- I'm using the "Per Sequence Quality Scores" plot here:

```{r}
df <- TidyMultiqc::load_multiqc(
  MultiQCfastQCpath, 
  sections = 'plot',
  plots = "fastqc_per_sequence_quality_scores_plot")
```

This provides a nested data frame as a set of x, y pairs. As it's a histogram plot, we know that the `x` value is the quality score, and `y` is the number of times that score has been counted.

We can use tidyr to unnest the data, HistDat to create a HistDat object for each group, then purr to map each plot data frame into a row of summary statistics:

```{r}
df_unNest <- df %>%
  dplyr::mutate(
    purrr::map_dfr(plot.fastqc_per_sequence_quality_scores_plot, function(plot_df){
      hist = HistDat::HistDat(vals=plot_df$x, counts = plot_df$y)
      list(
        mean_qc = mean(hist),
        median_qc = median(hist),
        max_qc = max(hist)
      )
    }),
    plot.fastqc_per_sequence_quality_scores_plot = NULL
  )
```

This dataframe has separate rows for reads 1 & 2; we can rearrange that to make it easier to work with for our purposes. Since we're most interested in median quality, we'll just pull that value for each sample.

```{r}
seqQC_r1 <- df_unNest %>%
  select(c("metadata.sample_id", "median_qc")) %>%
  filter(grepl("r1", metadata.sample_id)) %>%
  dplyr::rename("medianQC_r1" = "median_qc") %>%
  mutate(sampleNo = substr(metadata.sample_id, start = 9, stop = 11))

seqQC_r2 <- df_unNest %>%
  select(c("metadata.sample_id", "median_qc")) %>%
  filter(grepl("r2", metadata.sample_id)) %>%
  dplyr::rename("medianQC_r2" = "median_qc") %>%
  mutate(sampleNo = substr(metadata.sample_id, start = 9, stop = 11))

seqQC <- merge(seqQC_r1, seqQC_r2, by = "sampleNo") %>%
  select(c("sampleNo", "medianQC_r1", "medianQC_r2")) %>%
  arrange(sampleNo)
```

Let's just take a peek at the distribution of sequence quality scores for now; we'll use it in our other analyses later on:

```{r}
ggplot(seqQC, aes(medianQC_r1)) +
  geom_bar(stat = "count") +
  theme_bw()

ggplot(seqQC, aes(medianQC_r2)) +
  geom_bar(stat = "count") +
  theme_bw()
```

## 4.3 QC originals

```{bash}
cd /home/rachelvoyt/Documents/UT-Grad/Development/repos/tamGenetics_primatesPeru/04_tamRun4/01_nanopore/01b_run4QualityChecks

conda activate fastqc-env

# Run fastqc
for i in ../02_run4Interleaved/*; do fastqc $i; done

# Move fastqc files to quality checks folder
mv ../02_run4Interleaved/*fastqc* .

# Activate multiqc environment
conda activate multiqc-env

# Run MultiQC on all files within the quality checks folder
multiqc --interactive .
```

# 5 Create primer-probe & sample files

Prior to running the GTscore pipeline itself, we need to make a few files, including 1) sample files 2) primer-probe files for each species. I'm separating them out like this so that we have more accurate read counts and genotype rates for each sample and locus.

## 5.1 Sample files

We need three sets of sample files total: 1) all samples 2) LWED samples only + all negatives 3) SIMP samples only + all negatives.

### 5.1.1 All samples

Full set of sample files created under section 2.2.1 above

```{r}
sf_fullSet_ont <- sf_fullSet_ont %>%
  select(-well)
```

### 5.1.2 Species subsets

Use md file to create sample file species subsets. Note that we're including the negative controls in both species subsets 

```{r}
# Create subsets
sf_lwed_ont <- sf_fullSet_ont %>%
  filter(V1 %in% lwed_sampleFiles)

sf_simp_ont <- sf_fullSet_ont %>%
  filter(V1 %in% simp_sampleFiles)

# Export sample files
write.table(sf_lwed_ont, file = "./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_lwed_sampleFiles.txt", sep = "\t", row.names = F, col.names = F, quote = F)

write.table(sf_simp_ont, file = "./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_simp_sampleFiles.txt", sep = "\t", row.names = F, col.names = F, quote = F)
```

### 5.1.3 Negs excluded

```{r}
sf_fullSet <- read.table("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_fullSet_sampleFiles.txt")

sf_fullSet_noNegs <- sf_fullSet %>%
  filter(V1 %in% md_fullSet_noNegs$sampleFile)

sf_lwed_noNegs <- sf_fullSet %>%
  filter(V1 %in% md_lwed_noNegs$sampleFile)

sf_simp_noNegs <- sf_fullSet %>%
  filter(V1 %in% md_simp_noNegs$sampleFile)
```

Export

```{r}
write.table(sf_fullSet_noNegs, file = "./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_noNegs_fullSet_sampleFiles.txt", sep = "\t", row.names = F, col.names = F, quote = F)

write.table(sf_lwed_noNegs, file = "./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_noNegs_lwed_sampleFiles.txt", sep = "\t", row.names = F, col.names = F, quote = F)

write.table(sf_simp_noNegs, file = "./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_noNegs_simp_sampleFiles.txt", sep = "\t", row.names = F, col.names = F, quote = F)
```

## 4.2 Primer probe files

Each primer-probe file contains the following:

1.  Locus - locus name
2.  Ploidy - in our case, all are diploid so ploidy = 2
3.  SNPpos - position of SNP in the amplicon, assuming that the first base = 0
4.  Allele1 - one of the options for the SNP
5.  Allele2 - the other option for the SNP
6.  Probe1 - a sequence containing bases 8 upstream and 8 downstream from SNP (including SNP); contains Allele1
7.  Probe2 - same as Probe1, but contains Allele2
8.  Primer - the forward primer sequence for each locus

### 4.2.1 Load in primer-probe files

Here I'm loading in version 3 primer-probe files (created in GTscorePipeline_tamRun5.Rmd)

```{r}
pp_fullSet <- read.table("./05_tamRun5/03_run5GTscore/primerProbeFileV3_fullSet.txt", header = T)
pp_lwed <- read.table("./05_tamRun5/03_run5GTscore/primerProbeFileV3_LWED.txt", header = T)
pp_simp <- read.table("./05_tamRun5/03_run5GTscore/primerProbeFileV3_SIMP.txt", header = T)
```

# 5 Count reads for amplicons

Once the files are created, we can proceed with the first step in the GTscore pipeline - counting amplicon reads. We'll be doing doing this for the full set of data (all samples, all loci) as well as the species subsets of the data to allow for more accurate analyses of loci and sample performance.

## 5.1 Info on AmpliconReadCounter.pl

The read counter is written in perl (AmpliconReadCounter.pl), but can be called from R. Running it does the following:

1.  Identifies each unique sequence, then counts the number of times each unique sequence occurs within an individual

2.  Aligns each unique sequence with primer and probe; if the sequence doesn't align, then it is excluded as an off-target sequence and reports by individual and by locus are given.

-   Note: By default, all primers are trimmed to the length of the shortest primer to increase speed. Optionally the full length primer can be used for the primer but this may significantly increase run timing depending on variation in primer lengths across loci.

Input flags for this script are:

-   --p a tab delimited file containing primer/probe information for each locus
-   --files a text file containing a list of .fastq sequence files to count reads from

Optional flags:

-   --prefix optional prefix for output file names
-   --inDir option to specify directory containing sequence data
-   --inputType fq or fastqgz (defaults to fastqgz)
-   --useFullPrimer uses the full primer for counting reads rather than the trimmed primer
-   --alleleOrder order of alleles output in locusTable file. Options are original (matches primer-probe file order) or alphabetical (default)
-   --printMatched outputs matched reads for each individual
-   --printDiscarded outputs discarded reads for each individual

## 5.2 Run AmpliconReadCounterl.pl

To run from the command line, use: perl AmpliconReadCounter.pl -p primerProbeFile.txt --files sampleList.txt. To run from R, use the scripts below.

### Negs included

```{r count reads for amplicons, eval=FALSE}
# All samples, all loci
system2("perl",
        args="./GTscore_sourceScripts/AmpliconReadCounter.pl -p ./05_tamRun5/03_run5GTscore/primerProbeFileV3_fullSet.txt --files ./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_fullSet_sampleFiles.txt --inDir ./04_tamRun4/01_nanopore/02_run4Interleaved_ont/ --outDir ./04_tamRun4/01_nanopore/03_run4GTscore_ont/ --prefix ont_fullSet_")

# LWED
## exclude simp-specific loci
system2("perl",
        args="./GTscore_sourceScripts/AmpliconReadCounter.pl -p ./05_tamRun5/03_run5GTscore/primerProbeFileV3_LWED.txt --files ./04_tamRun4/01_nanopore/03_run4GTscore/ont_lwed_sampleFiles.txt --inDir ./04_tamRun4/01_nanopore/02_run4Interleaved/ --outDir ./04_tamRun4/01_nanopore/03_run4GTscore/ --prefix ont_lwed_")

## include simp-specific loci
system2("perl",
        args="./GTscore_sourceScripts/AmpliconReadCounter_modified.pl -p ./05_tamRun5/03_run5GTscore/primerProbeFileV3_fullSet.txt --files ./04_tamRun4/01_nanopore/03_run4GTscore/ont_lwed_sampleFiles.txt --inDir ./04_tamRun4/01_nanopore/02_run4Interleaved/ --outDir ./04_tamRun4/01_nanopore/03_run4GTscore/ --prefix ont_lwed_lociAll_")

# SIMP
## exclude lwed-specific loci
system2("perl",
        args="./GTscore_sourceScripts/AmpliconReadCounter.pl -p ./05_tamRun5/03_run5GTscore/primerProbeFileV3_SIMP.txt --files ./04_tamRun4/01_nanopore/03_run4GTscore/ont_simp_sampleFiles.txt --inDir ./04_tamRun4/01_nanopore/02_run4Interleaved/ --outDir ./04_tamRun4/01_nanopore/03_run4GTscore/ --prefix ont_simp_")

## include lwed-specific loci
system2("perl",
        args="./GTscore_sourceScripts/AmpliconReadCounter_modified.pl -p ./05_tamRun5/03_run5GTscore/primerProbeFileV3_fullSet.txt --files ./04_tamRun4/01_nanopore/03_run4GTscore/ont_simp_sampleFiles.txt --inDir ./04_tamRun4/01_nanopore/02_run4Interleaved/ --outDir ./04_tamRun4/01_nanopore/03_run4GTscore/ --prefix ont_simp_lociAll_")
```

### Negs excluded

```{r}
# All samples, all loci
system2("perl",
        args = "./GTscore_sourceScripts/AmpliconReadCounter.pl -p ./05_tamRun5/03_run5GTscore/primerProbeFileV3_fullSet.txt --files ./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_noNegs_fullSet_sampleFiles.txt --inDir ./04_tamRun4/01_nanopore/02_run4Interleaved_ont/ --outDir ./04_tamRun4/01_nanopore/03_run4GTscore_ont/ --prefix ont_noNegs_fullSet_")

# LWED
## exclude simp-specific loci
system2("perl",
        args="./GTscore_sourceScripts/AmpliconReadCounter.pl -p ./05_tamRun5/03_run5GTscore/primerProbeFileV3_LWED.txt --files ./04_tamRun4/01_nanopore/03_run4GTscore/ont_noNegs_lwed_sampleFiles.txt --inDir ./04_tamRun4/01_nanopore/02_run4Interleaved/ --outDir ./04_tamRun4/01_nanopore/03_run4GTscore/ --prefix ont_noNegs_lwed_")

## include simp-specific loci
system2("perl",
        args="./GTscore_sourceScripts/AmpliconReadCounter.pl -p ./05_tamRun5/03_run5GTscore/primerProbeFileV3_fullSet.txt --files ./04_tamRun4/01_nanopore/03_run4GTscore/ont_noNegs_lwed_sampleFiles.txt --inDir ./04_tamRun4/01_nanopore/02_run4Interleaved/ --outDir ./04_tamRun4/01_nanopore/03_run4GTscore/ --prefix ont_noNegs_lwed_lociAll_")

# SIMP
## exclude lwed-specific loci
system2("perl",
        args="./GTscore_sourceScripts/AmpliconReadCounter.pl -p ./05_tamRun5/03_run5GTscore/primerProbeFileV3_SIMP.txt --files ./04_tamRun4/01_nanopore/03_run4GTscore/ont_noNegs_simp_sampleFiles.txt --inDir ./04_tamRun4/01_nanopore/02_run4Interleaved/ --outDir ./04_tamRun4/01_nanopore/03_run4GTscore/ --prefix ont_noNegs_simp_")

## include lwed-specific loci
system2("perl",
        args="./GTscore_sourceScripts/AmpliconReadCounter_modified.pl -p ./05_tamRun5/03_run5GTscore/primerProbeFileV3_fullSet.txt --files ./04_tamRun4/01_nanopore/03_run4GTscore/ont_noNegs_simp_sampleFiles.txt --inDir ./04_tamRun4/01_nanopore/02_run4Interleaved/ --outDir ./04_tamRun4/01_nanopore/03_run4GTscore/ --prefix ont_noNegs_simp_lociAll_")
```

AmpliconReadCounter.pl outputs a LocusTable file and an AlleleReads file for single-SNP and haplotype data, plus two summary files.

The default names for these files are as follows, with LWED and SIMP appended to files associated with species-specific analyses:

-   LocusTable_singleSNPs.txt - locus name, ploidy, and alleles for each SNP
-   AlleleReads_singleSNPs.txt - counts for each SNP allele (rows are loci, columns are individuals)
-   LocusTable_haplotypes.txt - same as above (doesn't matter for us since we're only using single SNPs)
-   AlleleReads_haplotypes.txt - same as above (doesn't matter for us since we're only using single SNPs)
-   GTscore_individualSummary.txt - counts by individual of total reads, off-target reads, primer-only reads, and primer probe reads
-   GTscore_locusSummary.txt - counts by locus of primer reads and primer probe reads

# 6 Genotyping

## 6.1 10x coverage

### Identify loci \<10x coverage

Genotyping by sequencing generally requires a minimum of 10x coverage to be considered reliable; however, the GTscore genotyping script doesn't include this cutoff, and will provide genotypes with as little as one read per allele for heterozygous calls and 3 reads (vs. 0) for a homozygous call. As such, I'm implementing a filtering step here to recode all loci with \<10 reads to "0" so that loci with lower than 10x coverage will not receive genotypes.

Step 1: Recode loci with \<10x coverage in the full set of allele read counts

```{r}
# Read in allele counts for the full dataset
readCounts_original <- read.table("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_fullSet_AlleleReads_singleSNPs.txt")

# Create read counts copy for 10x coverage
readCounts_10x <- readCounts_original

# Set up a function to sum the read counts per allele for each locus, using package gsubfn
repl <- function(x) gsubfn("(\\d+),(\\d+)", ~ as.numeric(x) + as.numeric(y), paste(x))

# Then apply the function to readCounts to sum each set of allele reads for each locus
readCounts_sum_10x <- replace(readCounts_10x, TRUE, lapply(readCounts_10x, repl)) %>%
  mutate(across(everything(),as.numeric))

# Recode <10x loci with "0"
readCounts_10x[readCounts_sum_10x < 10] <- "0,0"
```

Step 2: Create lwed & simp subsets & create new AlleleReads_singleSNPs files

```{r}
# Get lists of lwed- and simp-specific loci
lwed_loci <- read.delim("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_lwed_LocusTable_singleSNPs.txt",header=TRUE,stringsAsFactors=FALSE)
simp_loci <- read.delim("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_simp_LocusTable_singleSNPs.txt",header=TRUE,stringsAsFactors=FALSE)

readCounts_lwed_10x <- readCounts_10x %>%
  select(any_of(lwed_sampleIDs)) %>%
  rownames_to_column("Locus") %>%
  filter(Locus %in% lwed_loci$Locus_ID) %>%
  column_to_rownames("Locus")
readCounts_simp_10x <- readCounts_10x %>%
  select(any_of(simp_sampleIDs)) %>%
  rownames_to_column("Locus") %>%
  filter(Locus %in% simp_loci$Locus_ID) %>%
  column_to_rownames("Locus")
  
# Export new AlleleReads_singleSNPs files
write.table(readCounts_10x,"./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_fullSet_AlleleReads_singleSNPs_10x.txt",quote=FALSE,sep="\t")
write.table(readCounts_lwed_10x,"./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_lwed_AlleleReads_singleSNPs_10x.txt",quote=FALSE,sep="\t")
write.table(readCounts_simp_10x,"./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_simp_AlleleReads_singleSNPs_10x.txt",quote=FALSE,sep="\t")
```

Genotyping is accomplished using the polyGen function. The genotyping algorithm is described in McKinney et al. 2018 and is a maximum likelihood algorithm capable of genotyping any number of alleles and ploidy per locus. This allows genoyping of single SNPs as well as microhaplotypes, and loci with elevated ploidy.

Two arguments are required for polyGen, the locusTable and alleleReads files output by AmpliconReadCounter.

Optional arguments for polyGen are:

-   p_thresh - threshold p-value for likelihood ratio test (default 0.05)
-   epsilon - error rate for genotyping model (default 0.01)

**NOTE** that only primer probe reads are used in genotyping!

Note also that I'm making three genotype files, one for all loci vs. all samples and two species-specific sets - this allows our genotyping metrics to be more accurate.

### Full set

```{r}
#load locus table and 10x allele reads file
fullSet_singleSNP_locusTable <- read.delim("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_fullSet_LocusTable_singleSNPs.txt", header = TRUE, stringsAsFactors = FALSE)

fullSet_singleSNP_alleleReads_10x <- read.delim("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_fullSet_AlleleReads_singleSNPs_10x.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)

#generate singleSNP genotypes using the polyGen algorithm, adjust "0" formatting
fullSet_polyGenResults_singleSNP_10x <- polyGen(fullSet_singleSNP_locusTable, fullSet_singleSNP_alleleReads_10x)

# write results
write.table(fullSet_polyGenResults_singleSNP_10x,"./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_fullSet_polyGenResults_singleSNP_10x.txt",quote=FALSE,sep="\t")
```

### LWED

```{r Genotyping}
#load locus table and 10x allele reads file
LWED_singleSNP_locusTable <- read.delim("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_lwed_LocusTable_singleSNPs.txt", header=TRUE, stringsAsFactors=FALSE)
LWED_singleSNP_alleleReads_10x <- read.delim("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_lwed_AlleleReads_singleSNPs_10x.txt",header=TRUE, row.names=1, stringsAsFactors=FALSE)

#generate singleSNP genotypes using the polyGen algorithm
LWED_polyGenResults_singleSNP_10x <- polyGen(LWED_singleSNP_locusTable, LWED_singleSNP_alleleReads_10x)

#write results
write.table(LWED_polyGenResults_singleSNP_10x,"./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_lwed_polyGenResults_singleSNP_10x.txt",quote=FALSE,sep="\t")
```

### SIMP

```{r}
#load locus table and 10x allele reads file
SIMP_singleSNP_locusTable <- read.delim("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_simp_LocusTable_singleSNPs.txt", header=TRUE, stringsAsFactors=FALSE)
SIMP_singleSNP_alleleReads_10x <- read.delim("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_simp_AlleleReads_singleSNPs_10x.txt", header=TRUE, row.names=1, stringsAsFactors=FALSE)

#generate singleSNP genotypes using the polyGen algorithm
SIMP_polyGenResults_singleSNP_10x <- polyGen(SIMP_singleSNP_locusTable, SIMP_singleSNP_alleleReads_10x)

#write results
write.table(SIMP_polyGenResults_singleSNP_10x,"./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_simp_polyGenResults_singleSNP_10x.txt",quote=FALSE,sep="\t")
```

## 6.2 0x coverage

### Full set

```{r}
#load locus table and 10x allele reads file
fullSet_singleSNP_locusTable <- read.delim("./04_tamRun4/01_nanopore/03_run4GTscore/ont_fullSet_LocusTable_singleSNPs.txt", header = TRUE, stringsAsFactors = FALSE)

fullSet_singleSNP_alleleReads_0x <- read.delim("./04_tamRun4/01_nanopore/03_run4GTscore/ont_fullSet_AlleleReads_singleSNPs.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)

#generate singleSNP genotypes using the polyGen algorithm, adjust "0" formatting
fullSet_polyGenResults_singleSNP_0x <- polyGen(fullSet_singleSNP_locusTable, fullSet_singleSNP_alleleReads_0x)

# write results
write.table(fullSet_polyGenResults_singleSNP_0x,"./04_tamRun4/01_nanopore/03_run4GTscore/ont_fullSet_polyGenResults_singleSNP_0x.txt",quote=FALSE,sep="\t")
```


# 7 Data summaries

## 7.1 Locus summaries

### 10x coverage

Locus summary metrics are based on data without filtering for 10x/30x coverage EXCEPT for genotype rates.

#### Summarize single SNP results for loci

The summarizeGTscore command generates summary data for each locus in table form. The summary data includes genotype rate, average read depth, minor (least frequent) allele frequency, major (most frequent) allele frequency, alleles per locus, and frequency per allele. Minor allele frequency is a common metric for filtering loci that are likely to be uninformative for population genetics; however, loci with haplotype alleles may have an allele with very low frequency but still have appreciable frequency at multiple other alleles. Because of this, the major allele frequency is included in output, as well as the observed frequencies for all alleles at a given locus.

```{r}
# non-filtered singleSNP_alleleReads
fullSet_singleSNP_alleleReads <- read.delim("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_fullSet_AlleleReads_singleSNPs.txt", header = TRUE, row.names = 1, stringsAsFactors = FALSE)

LWED_singleSNP_alleleReads <- read.delim("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_lwed_AlleleReads_singleSNPs.txt", header = TRUE, row.names = 1, stringsAsFactors = FALSE)

SIMP_singleSNP_alleleReads <- read.delim("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_simp_AlleleReads_singleSNPs.txt", header = TRUE, row.names = 1, stringsAsFactors = FALSE)

#summarize single SNP results
fullSet_singleSNP_summary_10x <- summarizeGTscore(fullSet_singleSNP_alleleReads, fullSet_singleSNP_locusTable, fullSet_polyGenResults_singleSNP_10x)

LWED_singleSNP_summary_10x <- summarizeGTscore(LWED_singleSNP_alleleReads, LWED_singleSNP_locusTable, LWED_polyGenResults_singleSNP_10x)

SIMP_singleSNP_summary_10x <- summarizeGTscore(SIMP_singleSNP_alleleReads, SIMP_singleSNP_locusTable, SIMP_polyGenResults_singleSNP_10x)

#write results
write.table(fullSet_singleSNP_summary_10x, "./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_fullSet_singleSNP_summary_10x.txt", quote = FALSE, sep = "\t", row.names = FALSE)
write.table(LWED_singleSNP_summary_10x, "./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_lwed_singleSNP_summary_10x.txt", quote = FALSE, sep = "\t", row.names = FALSE)
write.table(SIMP_singleSNP_summary_10x, "./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_simp_singleSNP_summary_10x.txt", quote = FALSE, sep = "\t", row.names = FALSE)
```

#### Master locus summaries

Generate locus summary files with single SNP summaries + GTscore locus summaries created earlier

I also found it helpful to create a "master" locus summary file - this way, we have a single file for all loci that provides performance metrics that are specific to that locus's species. This file includes data from both the locus summaries and single SNP summaries created earlier.

In doing so, this means that...

-   values for LWED-specific loci reflect performance with LWED individuals only
-   values for SIMP-specific loci reflect performance with SIMP individuals only
-   all other loci reflect performance with LWED and SIMP individuals combined

```{r}
# Load locus summaries (not filtered for coverage)
ls <- read.table("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_fullSet_GTscore_locusSummary.txt", header = T, sep = "\t") %>%
  mutate(sampleSet = "full")
lwed_ls <- read.table("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_lwed_GTscore_locusSummary.txt", header = T, sep = "\t") %>%
  mutate(sampleSet = "LWED")
simp_ls <- read.table("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_simp_GTscore_locusSummary.txt", header = T, sep = "\t") %>%
  mutate(sampleSet = "SIMP")

# Separate locus summaries and singleSNP summaries into results from shared and species-specific loci analyses
## Locus summaries
ls1 <- ls %>%
  filter(!str_detect(Locus, "LWED|SIMP")) %>%
  mutate(sampleSet = "full")
lwed1_ls <- lwed_ls %>%
  filter(!str_detect(Locus, "SIMP")) %>%
  mutate(sampleSet = "LWED")
simp1_ls <- simp_ls %>%
  filter(!str_detect(Locus, "LWED")) %>%
  mutate(sampleSet = "SIMP")

## SingleSNP summaries
ss_10x <- fullSet_singleSNP_summary_10x %>%
  filter(!str_detect(Locus_ID, "LWED|SIMP")) %>%
  mutate(sampleSet = "full")
lwed_ss_10x <- LWED_singleSNP_summary_10x %>%
  filter(!str_detect(Locus_ID, "SIMP")) %>%
  mutate(sampleSet = "LWED")
simp_ss_10x <- SIMP_singleSNP_summary_10x %>%
  filter(!str_detect(Locus_ID, "LWED")) %>%
  mutate(sampleSet = "SIMP")

# Recombine locus summaries & single snp summary files, then merge the two
ls_recombine <- rbind(ls1, lwed1_ls, simp1_ls)

ss_recombine_10x <- rbind(ss_10x, lwed_ss_10x, simp_ss_10x) %>%
  dplyr::rename("Locus" = "Locus_ID") %>%
  mutate(Locus = sub("_[^_]+$", "\\1", Locus))

ls_ss_10x <- merge(ls_recombine, ss_recombine_10x, by = c("Locus", "sampleSet")) 

# Export
write.csv(ls_ss_10x, "./04_tamRun4/01_nanopore/03_run4GTscore_ont/summaryFiles_ont/ont_tamRun4_master_locusSummary_10x.csv", row.names = F)
```

#### Plots

plot genotype rate

```{r locus genotype rate, warning=FALSE}
ggplot()+geom_histogram(data=ls_ss_10x,aes(x=GenotypeRate),binwidth=0.03)+xlim(-0.01,1.01)+
  labs(title="Locus Genotype Rate", x="Genotype Rate", y="Count")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))
```

plot average read depth for single SNP data

```{r locus read depth}
ggplot()+geom_histogram(data=ls_ss_10x,aes(x=AvgReadDepth),binwidth=1)+
  labs(title="Average Read Depth per SNP", x="Average Read Depth", y="Count")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))
```

plot genotype rate relative to average depth

```{r locus genotype rate vs read depth}
ggplot()+geom_point(data=ls_ss_10x,aes(x=AvgReadDepth,y=GenotypeRate))+ylim(0,1)+
  labs(title="Genotype Rate vs Average Depth per SNP", x="Average Depth", y="Genotype Rate")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))
```

plot distribution of minor allele frequency

```{r histogram of MAF, warning=FALSE}
ggplot()+geom_histogram(data=ls_ss_10x,aes(x=minAF),binwidth=0.01)+
  labs(title="Minor Allele Frequency Single SNP", x="Minor Allele Frequency", y="Count")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))
```

plot distribution of major allele frequency

```{r histogram of MajAF, warning=FALSE}
ggplot()+geom_histogram(data=ls_ss_10x,aes(x=majAF),binwidth=0.01)+
  labs(title="Major Allele Frequency Single SNP", x="Major Allele Frequency", y="Count")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))
```

## 7.2 Sample summaries

Sample summary metrics are based on data without 10x/30x coverage cutoffs for everything EXCEPT genotype rate.

### 10x coverage

#### Load sample summaries

Sample summaries are output from AmpliconReadCounter (not filtered for coverage)

```{r}
# Full set
fullSet_GTscore_individualSummary <- read.delim("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_fullSet_GTscore_individualSummary.txt", header = TRUE, stringsAsFactors = FALSE)

# LWED
LWED_GTscore_individualSummary <-  read.delim("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_lwed_GTscore_individualSummary.txt", header = TRUE, stringsAsFactors = FALSE)

# SIMP
SIMP_GTscore_individualSummary <- read.delim("./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_simp_GTscore_individualSummary.txt", header = TRUE, stringsAsFactors = FALSE)
```

#### Summarize single SNP summaries for samples

```{r}
fullSet_singleSNP_sampleSummary_10x <- summarizeSamples(fullSet_polyGenResults_singleSNP_10x, fullSet_singleSNP_alleleReads_10x)

LWED_singleSNP_sampleSummary_10x <- summarizeSamples(LWED_polyGenResults_singleSNP_10x, LWED_singleSNP_alleleReads_10x)

SIMP_singleSNP_sampleSummary_10x <- summarizeSamples(SIMP_polyGenResults_singleSNP_10x, SIMP_singleSNP_alleleReads_10x)

# Export
write.csv(fullSet_singleSNP_sampleSummary_10x, "./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_fullSet_singleSNP_sampleSummary_10x.csv", row.names = F)

write.csv(LWED_singleSNP_sampleSummary_10x, "./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_lwed_singleSNP_sampleSummary_10x.csv", row.names = F)

write.csv(SIMP_singleSNP_sampleSummary_10x, "./04_tamRun4/01_nanopore/03_run4GTscore_ont/ont_simp_singleSNP_sampleSummary_10x.csv", row.names = F)
```

#### Combine AmpliconReadCounter individual summary with GTscore sample summary data

```{r}
# make new copies & add column to note which loci-set the values are based on
fullSet_gtIndivSummary_10x <- fullSet_GTscore_individualSummary %>%
  merge(., fullSet_singleSNP_sampleSummary_10x, by.x = "Sample", by.y = "sample") %>%
  filter(Sample %in% negSamples) %>%
  mutate(lociSet = "full")

LWED_gtIndivSummary_10x <- LWED_GTscore_individualSummary %>%
  merge(., LWED_singleSNP_sampleSummary_10x, by.x = "Sample", by.y = "sample") %>%
  mutate(lociSet = "LWED")

SIMP_gtIndivSummary_10x <- SIMP_GTscore_individualSummary %>%
  merge(., SIMP_singleSNP_sampleSummary_10x, by.x = "Sample", by.y = "sample") %>%
  mutate(lociSet = "SIMP")

# Combine LWED & SIMP to form one, adjust sample name
lwedSIMP_gtIndivSummary_10x <- rbind(LWED_gtIndivSummary_10x, SIMP_gtIndivSummary_10x) %>%
  rbind(., fullSet_gtIndivSummary_10x) %>%
  mutate(
    sampleFile = paste0(Sample, ".all.fastq")
         ) %>%
  relocate(lociSet, .after = Sample)
```

#### Create master sample summary file & add metadata

```{r}
# Merge metadata & fullSet sample summaries
master_sampleSummary_10x <- merge(lwedSIMP_gtIndivSummary_10x, md_tamRun4_ont, by = "sampleFile") %>%
  mutate(
    sampleID_unique = case_when(
      str_detect(sampleType, "Neg") ~ str_c(sampleID_unique, "_", lociSet),
      .default = sampleID_unique
      )) %>%
  relocate(sampleID_unique)

# Export
write.csv(master_sampleSummary_10x, "./04_tamRun4/01_nanopore/03_run4GTscore_ont/summaryFiles_ont/ont_tamRun4_master_sampleSummary_10x.csv", row.names = F)
```

#### Plots

plot histogram of genotype rate

```{r histogram of genotype rate, warning=FALSE}
ggplot()+geom_histogram(data=master_sampleSummary_10x,aes(x=GenotypeRate),binwidth=0.01)+xlim(-0.01,1.01)+
  labs(title="Sample Genotype Rate (10x)", x="Genotype Rate", y="Count")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))
```

plot histogram of heterozygosity

```{r histogram of heterozygosity, warning=FALSE}
ggplot()+geom_histogram(data=master_sampleSummary_10x,aes(x=Heterozygosity),binwidth=0.03)+xlim(-0.01,1.01)+
  labs(title="Sample Heterozygosity", x="Heterozygosity", y="Count")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))
```

plot genotype rate vs primer probe reads

```{r genotype rate vs primer probe reads}
#dashed line added at 90% genotype rate, this is not a strict threshold, just a goal to aim for
ggplot(data=master_sampleSummary_10x,aes(x=Primer.Probe.Reads,y=GenotypeRate,color=sampleType))+
  geom_point(stat = "identity")+
  geom_smooth(method = "loess")+
  labs(title="Genotype Rate vs Total Reads per Sample", x="Primer Probe Reads", y="Genotype Rate")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))+
  geom_hline(yintercept=0.5,lty="dashed")
```

Samples with unusually high heterozygosity may be contaminated or have elevated ploidy. [[Given chimerism, however, this isn't super helpful for blood samples]]

plot heterozygosity vs primer probe reads

```{r heterozygosity vs primer probe reads}
ggplot()+geom_point(data=master_sampleSummary_10x,aes(x=Primer.Probe.Reads,y=Heterozygosity))+
  labs(title="Heterozygosity vs Total Reads per Sample", x="Primer Probe Reads", y="Heterozygosity")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))+
  geom_hline(yintercept=0.3, lty="dashed")
```

# 8 Quality control

## 8.1 Identify duplicate samples

The IDduplicateSamples function does all pairwise comparisons of samples and outputs two metrics:

-   proportionCommon - The proportion of loci that had genotypes for both samples in a pair
-   proportionMatch - The proportion of loci that have identical genotypes in the sample pair

```{r identify duplicate samples,eval=FALSE}
#convert missing genotypes "0" to NA
polyGenResults_singleSNP_NA<-fullSet_polyGenResults_singleSNP
polyGenResults_singleSNP_NA[polyGenResults_singleSNP_NA=="0"]<-NA

#compare all samples, for each comparison get proportion of loci that have genotypes
#in both samples (proportionCommon) and proportion of shared loci that have identical
#genotypes (proportionMatch).
#Samples with a high proportionCommon and high proportionMatch are likely duplicates
polyGenResults_dupTest<-IDduplicateSamples(polyGenResults_singleSNP_NA)

write.table(polyGenResults_dupTest,"./04_tamRun4/01_nanopore/03_run4GTscore/Run4_polyGenResults_dupTest.txt",quote=FALSE,sep="\t",row.names=FALSE)
```

```{r duplicate sample results}
polyGenResults_dupTest<-read.delim("./04_tamRun4/01_nanopore/03_run4GTscore/Run4_polyGenResults_dupTest.txt",stringsAsFactors=FALSE)
head(polyGenResults_dupTest)
```

Plot results of IDduplicateSamples

McKinney says that he generally sets thresholds of proportionMatch \> 0.8 and proportionCommon \> 0.75 to identify duplicate sample pairs, but the appropriate thresholds will depend on the marker set being used and the relatedness among samples. In this plot, he notes that it is possible that individuals at the lower range of identical genotypes (\~0.85) are relatives rather than duplicated samples.

```{r plot IDduplicateSamples results}
#potential duplicates are proportionMatch>0.8 and proportionCommon>0.75
#feel free to adjust these thresholds as needed
matchThresh=0.8
commonThresh=0.75 #switched to 0, looks like some loci were successfully genotyped for one sample and some for the other

#plot results
ggplot()+geom_point(data=polyGenResults_dupTest,aes(x=proportionCommon,y=proportionMatch))+
  geom_segment(aes(x=commonThresh,xend=1,y=matchThresh,yend=matchThresh),lty="dashed")+
  geom_segment(aes(x=commonThresh,xend=commonThresh,y=matchThresh,yend=1),lty="dashed")
```

Identify duplicate sample pairs with thresholds set previously

```{r}
#filter to potentially duplicated samples using thresholds above
polyGenResults_dupTest %>% filter(proportionMatch>=matchThresh,proportionCommon>=commonThresh)
```

## 8.2 Identify contaminated samples

Contaminated samples can be identified through elevated heterozygosity. NOTE- this isn't going to be helpful for us given the blood chimerism.

```{r identify contaminated samples (heterozygosity)}
#plot heterozygosity vs genotype rate per sample
#samples with unusually high heterozygosity relative to others are candidates for contamination
#the sample above the dashed line in this example is likely contaminated
ggplot()+geom_point(data=master_sampleSummary,aes(x=GenotypeRate,y=Heterozygosity))+
  labs(title="Heterozygosity vs Genotype Rate per Sample", x="Genotype Rate", y="Heterozygosity")+
  theme_bw()+theme(plot.title=element_text(hjust=0.5),plot.subtitle=element_text(hjust=0.5))+
  geom_hline(yintercept=0.30, lty="dashed")
```

Set heterozygosity treshold to identify likely contaminated sample

```{r}
#identify likely contaminated sample
contaminatedSample<-master_sampleSummary %>% filter(Heterozygosity>0.30) %>% pull(Sample)
contaminatedSample
```

Contaminated samples can also be identified by an elevated contamination score. In this example, samples with a contamination score \> 0.3 are known to be contaminated.

```{r }
#plot histogram of contamination score
ggplot()+geom_histogram(data=master_sampleSummary,aes(x=conScore),binwidth=0.02)+geom_vline(xintercept=0.3,lty="dashed")

```

Set contamination score threshold to identify contaminated samples

```{r}
#identify likely contaminated samples
contaminatedSamples2<-master_sampleSummary %>% filter(conScore>=0.3) %>% pull(Sample)
contaminatedSamples2
```

Plot genotype scatterplots for each sample

```{r}
#Scatter Plots can show evidence of contamination or elevated ploidy
plotGenotypes_sample(fullSet_singleSNP_locusTable, fullSet_singleSNP_alleleReads, fullSet_polyGenResults_singleSNP, type='scatter', savePlot="Y", saveDir="./scatterPlots_sample")
#look at plots for samples, particularly for putatively contaminated samples identified by high heterozygosity
```

## 8.3 Identify poor quality loci to remove

Flag SNPs with \< 50% genotype rate as candidates for removal. Will need to do this with LWED and SIMP samples separately, then recombine.

```{r}
poorQualitySNPs <- ls_ss %>% filter(GenotypeRate<0.5) %>% mutate(Locus=as.character(Locus)) %>% pull(Locus)

View(poorQualitySNPs)

pq_lwed <- data.frame(name=poorQualitySNPs_LWED) %>%
  mutate(species="LWED")
pq_simp<- data.frame(name=poorQualitySNPs_SIMP) %>%
  mutate(species="SIMP")

pq_both <- rbind(pq_lwed, pq_simp)
View(pq_both)

pq_both2 <- pq_both %>%
  group_by(name) %>%
  mutate(count=n()) %>%
  distinct(name, .keep_all = T) %>%
  within(species[count == '2'] <- "both")
View(pq_both2)

# Export file
write.csv(pq_both2, "./summaryFiles/poorQualitySNPs_fullSet.csv", row.names = F)
```

## 8.4 Plots

Ratio & Scatter Plots can show evidence of systemic issues in read counting (off-target reads, biases) or elevated ploidy

Plot genotype ratio & scatterplots for each locus

```{r}
#Allele Ratio Plots  
plotGenotypes(singleSNP_locusTable, singleSNP_alleleReads, polyGenResults_singleSNP, type='ratio', savePlot="Y", saveDir="ratioPlots_loci")
#Scatter Plots 
plotGenotypes(singleSNP_locusTable, singleSNP_alleleReads, polyGenResults_singleSNP, type='scatter', savePlot="Y", saveDir="scatterPlots_loci")
```

Plot histogram of contamination score for loci. An arbitrary score of 0.3 was set to identify problematic loci, but a lower or higher threshold may be more suitable. Visual examination of loci with elevated scores is recommended. In cases where there are very few heterozygous individuals, a high contamination score may be not truly reflect locus performance..

```{r, warning=FALSE}
#loci with high contamination scores should have scatterplots examined to ensure genotypes look accurate
fullSet_singleSNP_summary %>% ggplot(data=.) + geom_histogram(aes(x=conScore),binwidth=0.01)+geom_vline(xintercept=0.3)
```

Plot contamination score vs minor allele frequency. Loci with both a high contamination score and high minor allele frequency are likely to be problematic.

```{r, warning=FALSE}
fullSet_singleSNP_summary %>% ggplot(data=.) + geom_point(aes(x=conScore,y=minAF))
```

Get list of loci with high contamination score

```{r}
singleSNP_summary %>% filter(conScore>0.3)
```

Look at scatterplots for loci with high contamination score. See orignal GTscore README.Rmd for examples of a paralog, locus w/likely off-target sequence, locus w/high contamination score but may be fine.

# 9 Export genotype files

When exporting files, you can either export the full results and remove any poor quality samples or loci afterwards, or you can use whitelists or blacklists to filter during export. Both the exportGenepop and exportRubias functions have the following options: sampleWhitelist, locusWhitelist, sampleBlacklist, locusBlacklist. The whitelists are a list of samples or loci to retain, the blacklists are lists of samples or loci to discard.

## 9.1 Genepop format



export genepop format - poor quality loci removed

```{r}
#example with poor quality loci and contaminated sample removed
exportGenepop(polyGenResults_singleSNP,singleSNP_locusTable,
              locusBlacklist=poorQualitySNPs,
              filename="polyGenResults_singleSNP_genepop_filtered.txt")
```

## 9.2 Rubias format

export Rubias format with poor quality loci and contaminated sample removed

```{r}
exportRubias(polyGenResults_singleSNP,singleSNP_locusTable,sampleMetaData,
             locusBlacklist=poorQualitySNPs,
             filename="polyGenResults_singleSNP_rubias_filtered.txt")
exportRubias(polyGenResults_singleSNP_LWED,singleSNP_locusTable_LWED,sampleMetaData,
             locusBlacklist=poorQualitySNPs_LWED,
             filename="polyGenResults_singleSNP_rubias_filtered_LWED.txt")
exportRubias(polyGenResults_singleSNP_SIMP,singleSNP_locusTable_SIMP,sampleMetaData,
             locusBlacklist=poorQualitySNPs_SIMP,
             filename="polyGenResults_singleSNP_rubias_filtered_SIMP.txt")
```
