---
title: "tamRun3_lociAnalyses"
author: "Rachel Voyt"
date: "`r Sys.Date()`"
output: 
  rmdformats::downcute:
    downcute_theme: "chaos"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F)
```

```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto
}

pre[class] {
  max-height: 100px;
}
```

# 1 Overview

This pipeline is to investigate locus performance using the combined sequencing results from both runs of the tamRun3 library (each run on MiSeq v2 300 cycles).

# 2 Packages

```{r}
library(gsubfn) # to calculate locus total read counts
library(janitor) # duptest
library(kableExtra) # pretty tables
library(matrixStats)
library(phylotools) # txt to fastq
library(tidyverse)
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager", version = "3.16")
BiocManager::install("Biostrings")
```

MSA requires the package "igraph", which might not play nice when installing. If you run into issues, follow the steps below:

```
$ whereis anaconda
$ # some output
$ # adjust the next line based on the output from the whereis command
$ sudo mv mv /home/rachelvoyt/anaconda3/ /home/rachelvoyt/anaconda3.bak
$ R
> install.packages("igraph")
> q()
> n
$ # again, adjust the next line based on the output from the whereis command
$ sudo mv /home/rachelvoyt/anaconda3.bak /home/rachelvoyt/anaconda3/
```

Double check that igraph has installed properly by loading in the library, then install MSA and the GTscore source script (which requires MSA): 

```{r}
library(igraph)
BiocManager::install("msa")
library(msa) # GTscore locus diagnostics
source("./03_tamRun3/03_run3GTscore/GTscore_modified.R") # NOTE- added N=ATGC to lines 616 and 617 for later analyses (not included in original)
```

# 3 Data

## 3.1 Data summaries

Here I'm loading in the master locus and sample summaries, both products of GTscorePipeline_tamRun3.Rmd. The sample master summary includes all metadata as well.

Some things to note:

-   In the locus summary, species-specific locus metrics represent only their performance for their respective species
-   Genotype rate is based on genotypes given only to loci with at least 10x coverage

```{r}
# Locus summaries
locusSum <- read.csv("./03_tamRun3/03_run3GTscore/summaryFiles/master_cat_locusSummary.csv") %>%
  select(!conScore)

# Sample summaries
sampleSum <- read.csv("./03_tamRun3/03_run3GTscore/summaryFiles/master_cat_sampleSummary.csv") %>%
  mutate(Sample = gsub("-", "\\.", Sample))
sampleSum_lwed <- sampleSum %>%
  filter(species == "LWED")
sampleSum_simp <- sampleSum %>%
  filter(species == "SIMP")
sampleSum_blood <- sampleSum %>%
  filter(sampleType == "blood")
sampleSum_hair <- sampleSum %>%
  filter(sampleType == "hair")
```

## 3.2 Genotypes

Genotypes include only those called for loci with at least 10x coverage.

```{r}
genos_tamRun3 <- read.table("./03_tamRun3/03_run3GTscore/fullSet_cat_polyGenResults_singleSNP_10x.txt", header = T) %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub('[_][^_]+$', '', locus)) %>%
  column_to_rownames("locus")

genos_lwed <- read.table("./03_tamRun3/03_run3GTscore/LWED_cat_polyGenResults_singleSNP.txt", header = T) %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub('[_][^_]+$', '', locus)) %>%
  column_to_rownames("locus")

genos_simp <- read.table("./03_tamRun3/03_run3GTscore/SIMP_cat_polyGenResults_singleSNP.txt", header = T) %>%
  rownames_to_column("locus") %>%
  mutate(locus = sub('[_][^_]+$', '', locus)) %>%
  column_to_rownames("locus")
```

## 3.3 Loci lists

```{r}
# Alleles for all loci
locusTable <- read.table("./03_tamRun3/03_run3GTscore/fullSet_cat_LocusTable_singleSNPs.txt", header = T) %>%
  select(!ploidy) %>%
  mutate(Locus_ID = sub('[_][^_]+$', '', Locus_ID))

# LWED loci set
lociLWED <- read.table("./03_tamRun3/03_run3GTscore/primerProbeFile_LWED.txt", header = T) %>%
  select(Locus)

# SIMP loci set
lociSIMP <- read.table("./03_tamRun3/03_run3GTscore/primerProbeFile_SIMP.txt", header = T) %>%
  select(Locus)
```

## 3.4 Sample lists

Note that negative controls are included in both LWED and SIMP sample lists.

```{r}
samplesAll <- sampleSum %>%
  select(Sample) %>%
  distinct()

samplesLWED <- sampleSum %>%
  filter(species == "LWED") %>%
  select(Sample)

samplesSIMP <- sampleSum %>%
  filter(species == "SIMP") %>%
  select(Sample)

negatives <- sampleSum %>%
  filter(sampleType %in% c("XTN (-)", "PCR1 (-)")) %>%
  select(sampleID) %>%
  distinct()
```

# 4 Preliminary locus assessment

This preliminary loci assessment includes locus performance from all samples, regardless of sample performance. I'll be looking to see if any loci have fixed alleles, high major allele frequencies, or consistently heterozygous calls.

## 4.1 Fixed alleles

Two loci seem to be entirely fixed (LWED_248 and SIMP_318)

```{r, echo=FALSE}
fixedLoci <- locusSum %>%
  filter(majAF == 1) 

fixedLoci %>%
  kable() %>%
  kable_material(full_width = F) %>%
  scroll_box(fixed_thead = list(enabled = T, background = "#363636"))
```

## 4.2 High majAF

21 loci have a high major allele frequency (\> 90%)

```{r, echo=FALSE}
highMajAF <- locusSum %>%
  filter(majAF > 0.9) %>%
  arrange(desc(majAF)) %>%
  mutate(x = row_number()) %>%
  relocate(x) %>%
  dplyr::rename(" " = "x") 

highMajAF %>%
  kable() %>%
  kable_material(full_width = F) %>%
  scroll_box(fixed_thead = list(enabled = T, background = "#363636"))
```

## 4.3 Consistently heterozygous loci

To see whether any loci are consistently giving heterozygous calls, we first need to get counts of each genotype per locus - I'm doing this separately for each species since some species-specific loci will still amplify in the other.

Note that I included both blood and hair samples even though blood samples are expected to have higher heterozygosity due to chimerism - even in doing so though, no loci were heterozygous for more than 90% of samples.

### 4.3.1 Count genotypes for each locus

```{r}
genoSum_lwed <- genos_lwed %>%
  mutate("AA" = rowSums(. == "A,A")) %>%
  mutate("AC" = rowSums(. == "A,C")) %>%
  mutate("AG" = rowSums(. == "A,G")) %>%
  mutate("AT" = rowSums(. == "A,T")) %>%
  mutate("CC" = rowSums(. == "C,C")) %>%
  mutate("CG" = rowSums(. == "C,G")) %>%
  mutate("CT" = rowSums(. == "C,T")) %>%
  mutate("GG" = rowSums(. == "G,G")) %>%
  mutate("GT" = rowSums(. == "G,T")) %>%
  mutate("TT" = rowSums(. == "T,T")) %>%
  mutate(lociSet = "LWED") %>%
  select(AA, AC, AG, AT, CC, CG, CT, GG, GT, TT, lociSet) %>%
  rownames_to_column("Locus_ID") %>%
  as.data.frame() %>%
  merge(., locusTable, by = "Locus_ID", all.x = T, all.y = F) %>%
  column_to_rownames("Locus_ID") %>%
  mutate(alleles = gsub(",", "", alleles)) %>%
  mutate(totalGenos = rowSums(.[1:10])) %>%
  mutate(propHet = (rowSums(select(., matches(alleles))))/totalGenos)

genoSum_simp <- genos_simp %>%
  mutate("AA" = rowSums(. == "A,A")) %>%
  mutate("AC" = rowSums(. == "A,C")) %>%
  mutate("AG" = rowSums(. == "A,G")) %>%
  mutate("AT" = rowSums(. == "A,T")) %>%
  mutate("CC" = rowSums(. == "C,C")) %>%
  mutate("CG" = rowSums(. == "C,G")) %>%
  mutate("CT" = rowSums(. == "C,T")) %>%
  mutate("GG" = rowSums(. == "G,G")) %>%
  mutate("GT" = rowSums(. == "G,T")) %>%
  mutate("TT" = rowSums(. == "T,T")) %>%
  mutate(lociSet = "SIMP") %>%
  dplyr::select(c(AA, AC, AG, AT, CC, CG, CT, GG, GT, TT, lociSet)) %>%
  rownames_to_column("Locus_ID") %>%
  as.data.frame() %>%
  merge(., locusTable, by = "Locus_ID", all.x = T, all.y = F) %>%
  column_to_rownames("Locus_ID") %>%
  mutate(alleles = gsub(",", "", alleles)) %>%
  mutate(totalGenos = rowSums(.[1:10])) %>%
  mutate(propHet = (rowSums(select(., matches(alleles))))/totalGenos)
```

### 4.3.2 Identify loci heterozygous for \>90% of samples

No loci have heterozygous calls for \>90% of samples in either species; the highest proportion of heterozygous calls for a locus was 75% for LWED samples and 79% for SIMP samples.

```{r, echo=FALSE}
matrix(c(mean(genoSum_lwed$propHet),
         min(genoSum_lwed$propHet),
         max(genoSum_lwed$propHet),
         mean(genoSum_simp$propHet),
         min(genoSum_simp$propHet),
         max(genoSum_simp$propHet)),
       byrow = T,
       nrow = 2,
       ncol = 3) %>%
  signif(., digits = 2) %>%
  `rownames<-`(., c("LWED", "SIMP")) %>%
  `colnames<-`(., c("median % het", "min % het", "max % het")) %>%
  kable() %>%
  kable_material(full_width = F) %>%
  scroll_box(fixed_thead = list(enabled = T, background = "#363636"))
```

# 5 Identify & remove underperforming samples

## 5.1 Identify underperforming samples

To make sure our additional assessments of loci performance isn't skewed by underperforming samples, first we need to remove any samples that did not work well in the run.

To do that, first we need to take out any loci with zero reads -- turns out we don't have any, which is good!

```{r}
locusSum %>%
  filter(Primer.Probe.Reads == "0") %>%
  sum()
```

Next we'll identify samples with \<50% of loci genotyped successfully

```{r}
failedSamples <- sampleSum %>%
  filter(GenotypeRate < 0.5) %>%
  distinct_at(vars(sampleID), .keep_all = T)

matrix(c(length(failedSamples$sampleID),
         sum(failedSamples$sampleType == "blood"),
         sum(failedSamples$sampleType == "hair"),
         sum(failedSamples$sampleType %in% c("XTN (-)", "PCR1 (-)")),
         length(samplesAll$Sample),
         length(samplesLWED$Sample),
         length(samplesSIMP$Sample),
         length(negatives$sampleID)),
       nrow = 4,
       ncol = 2) %>%
  `rownames<-`(., c("TOTAL SAMPLES", "blood samples", "hair samples", "(-) controls")) %>%
  `colnames<-`(., c("Fail", "Total")) %>%
  as.data.frame() %>%
  mutate(Pass = Total - Fail, .after = Fail) %>%
  kable() %>%
  kable_material(full_width = F) %>%
  scroll_box(fixed_thead = list(enabled = T, background = "#363636"))
```

## 5.2 Create new sample files

And now we can create new sample files with only the samples with at least 50% genotype success.

```{r}
# Original sample files
sf_fullSet <- read.table("./03_tamRun3/03_run3GTscore/sampleFiles_fullSet_cat.txt")
sf_lwed <- read.table("./03_tamRun3/03_run3GTscore/sampleFiles_LWED_cat.txt")
sf_simp <- read.table("./03_tamRun3/03_run3GTscore/sampleFiles_SIMP_cat.txt")

# Remove failed samples from each sample file
sf_fullSet_samplePass <- sf_fullSet %>%
  filter(!V1 %in% failedSamples$sampleFile)
sf_lwed_samplePass <- sf_lwed %>%
  filter(!V1 %in% failedSamples$sampleFile)
sf_simp_samplePass <- sf_simp %>%
  filter(!V1 %in% failedSamples$sampleFile)
```

```{r, eval=FALSE}
# Export new sample files
write.table(sf_fullSet_samplePass, file = "./03_tamRun3/04_genoAnalyses/samplePass_sampleFiles_fullSet.txt", sep = "\t", row.names = F, col.names = F, quote = F)
write.table(sf_lwed_samplePass, file = "./03_tamRun3/04_genoAnalyses/samplePass_sampleFiles_LWED.txt", sep = "\t", row.names = F, col.names = F, quote = F)
write.table(sf_simp_samplePass, file = "./03_tamRun3/04_genoAnalyses/samplePass_sampleFiles_SIMP.txt", sep = "\t", row.names = F, col.names = F, quote = F)
```

## 5.3 Rerun GTscore post-filtering failed samples

We can now rerun the pertinent GTscore scripts with the filtered sample files.

### 5.3.1 Count amplicon reads

First step of the pipeline is to count amplicon reads - this includes updated counts for each locus.

```{r, eval=FALSE}
# All samples, all loci
system2("perl",
        args="./03_tamRun3/03_run3GTscore/AmpliconReadCounter.pl -p ./03_tamRun3/03_run3GTscore/primerProbeFile_fullSet.txt --files ./03_tamRun3/04_genoAnalyses/samplePass_sampleFiles_fullSet.txt --inDir ./03_tamRun3/02_run3Interleaved/ --outDir ./03_tamRun3/04_genoAnalyses/ --prefix samplePass_fullSet_")

# LWED
system2("perl",
        args="./03_tamRun3/03_run3GTscore/AmpliconReadCounter.pl -p ./03_tamRun3/03_run3GTscore/primerProbeFile_LWED.txt --files ./03_tamRun3/04_genoAnalyses/samplePass_sampleFiles_LWED.txt --inDir ./03_tamRun3/02_run3Interleaved/ --outDir ./03_tamRun3/04_genoAnalyses/ --prefix samplePass_LWED_")

# SIMP
system2("perl",
        args="./03_tamRun3/03_run3GTscore/AmpliconReadCounter.pl -p ./03_tamRun3/03_run3GTscore/primerProbeFile_SIMP.txt --files ./03_tamRun3/04_genoAnalyses/samplePass_sampleFiles_SIMP.txt --inDir ./03_tamRun3/02_run3Interleaved/ --outDir ./03_tamRun3/04_genoAnalyses/ --prefix samplePass_SIMP_")
```

### 5.3.2 Identify loci \<10x coverage

Next we need to recode loci with \<10x coverage in the full set of allele read counts to prepare for genotyping

```{r}
# Read in allele counts for the full dataset
readCounts <- read.table("./03_tamRun3/04_genoAnalyses/samplePass_fullSet_AlleleReads_singleSNPs.txt")

# Set up a function to sum the read counts per allele for each locus, using package gsubfn
repl <- function(x) gsubfn("(\\d+),(\\d+)", ~ as.numeric(x) + as.numeric(y), paste(x))

# Then apply the function to readCounts to sum each set of allele reads for each locus
readCounts_sum <- replace(readCounts, TRUE, lapply(readCounts, repl)) %>%
  mutate(across(everything(),as.numeric))

# Recode <10x loci with "0"
readCounts[readCounts_sum < 10] <- "0,0"
```

This includes creating new lwed & simp subsets

```{r}
# Passed LWED and SIMP sample names
lwedSamples_pass <- sf_lwed_samplePass %>%
  mutate(V1 = gsub("\\..*","", V1)) %>% # adjust sample names to ditch everything after "."
  mutate(V1 = gsub("-", "\\.", V1)) # change "-" to "."
simpSamples_pass <- sf_simp_samplePass %>%
  mutate(V1 = gsub("\\..*","", V1)) %>% # adjust sample names to ditch everything after "."
  mutate(V1 = gsub("-", "\\.", V1)) # change "-" to "."

# Species-specific read counts
readCounts_lwed <- readCounts %>%
  select(all_of(lwedSamples_pass$V1)) %>%
  rownames_to_column("Locus") %>%
  mutate(Locus = sub('[_][^_]+$', '', Locus)) %>%
  filter(Locus %in% lociLWED$Locus) %>%
  column_to_rownames("Locus")
readCounts_simp <- readCounts %>%
  select(all_of(simpSamples_pass$V1)) %>%
  rownames_to_column("Locus") %>%
  mutate(Locus = sub('[_][^_]+$', '', Locus)) %>%
  filter(Locus %in% lociSIMP$Locus) %>%
  column_to_rownames("Locus")
```

Then we can export the new 10x versions of the AlleleReads_singleSNPs files for passing samples

```{r, eval=FALSE}
write.table(readCounts,"./03_tamRun3/04_genoAnalyses/samplePass_fullSet_AlleleReads_singleSNPs_10x.txt",quote=FALSE,sep="\t")
write.table(readCounts_lwed,"./03_tamRun3/04_genoAnalyses/samplePass_LWED_AlleleReads_singleSNPs_10x.txt",quote=FALSE,sep="\t")
write.table(readCounts_simp,"./03_tamRun3/04_genoAnalyses/samplePass_SIMP_AlleleReads_singleSNPs_10x.txt",quote=FALSE,sep="\t")
```

### 5.3.3 Genotyping

Now that we've removed failed samples and recoded allele read counts, we can run the GTscore genotyping script - I'm running it three times so that we have genotypes for the full set of samples + full set of loci as well as species-specific sets with their species-specific loci.

Full set

```{r}
#load locus table and 10x allele reads file
fullSet_singleSNP_locusTable<-read.delim("./03_tamRun3/04_genoAnalyses/samplePass_fullSet_LocusTable_singleSNPs.txt",header=TRUE,stringsAsFactors=FALSE)
fullSet_singleSNP_alleleReads_10x<-read.delim("./03_tamRun3/04_genoAnalyses/samplePass_fullSet_AlleleReads_singleSNPs_10x.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)

#generate singleSNP genotypes using the polyGen algorithm, adjust "0" formatting
fullSet_polyGenResults_singleSNP_10x<-polyGen(fullSet_singleSNP_locusTable,fullSet_singleSNP_alleleReads_10x)
```

```{r, eval=FALSE}
#write results
write.table(fullSet_polyGenResults_singleSNP_10x,"./03_tamRun3/04_genoAnalyses/samplePass_fullSet_polyGenResults_singleSNP_10x.txt",quote=FALSE,sep="\t")
```

LWED

```{r}
#load locus table and 10x allele reads file
LWED_singleSNP_locusTable<-read.delim("./03_tamRun3/04_genoAnalyses/samplePass_LWED_LocusTable_singleSNPs.txt",header=TRUE,stringsAsFactors=FALSE) %>%
  mutate(Locus_ID = sub('[_][^_]+$', '', Locus_ID))
LWED_singleSNP_alleleReads_10x<-read.delim("./03_tamRun3/04_genoAnalyses/samplePass_LWED_AlleleReads_singleSNPs_10x.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)

#generate singleSNP genotypes using the polyGen algorithm
LWED_polyGenResults_singleSNP_10x<-polyGen(LWED_singleSNP_locusTable,LWED_singleSNP_alleleReads_10x)
```

```{r, eval=FALSE}
#write results
write.table(LWED_polyGenResults_singleSNP_10x,"./03_tamRun3/04_genoAnalyses/samplePass_LWED_polyGenResults_singleSNP_10x.txt",quote=FALSE,sep="\t")
```

SIMP

```{r}
#load locus table and 10x allele reads file
SIMP_singleSNP_locusTable<-read.delim("./03_tamRun3/04_genoAnalyses/samplePass_SIMP_LocusTable_singleSNPs.txt",header=TRUE,stringsAsFactors=FALSE) %>%
  mutate(Locus_ID = sub('[_][^_]+$', '', Locus_ID))
SIMP_singleSNP_alleleReads_10x<-read.delim("./03_tamRun3/04_genoAnalyses/samplePass_SIMP_AlleleReads_singleSNPs_10x.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)

#generate singleSNP genotypes using the polyGen algorithm
SIMP_polyGenResults_singleSNP_10x<-polyGen(SIMP_singleSNP_locusTable,SIMP_singleSNP_alleleReads_10x)
```

```{r, eval=FALSE}
#write results
write.table(SIMP_polyGenResults_singleSNP_10x,"./03_tamRun3/04_genoAnalyses/samplePass_SIMP_polyGenResults_singleSNP_10x.txt",quote=FALSE,sep="\t")
```

### 5.3.4 Locus summaries

We can now re-create our locus summaries. Note that for these summaries, allele read counts reflect those PRIOR to recoding those with less than 10x coverage, while genotype rates reflect calls for loci with 10x coverage.

#### Single-SNP locus summary

```{r}
# Read in original allele read counts
fullSet_singleSNP_alleleReads<-read.delim("./03_tamRun3/04_genoAnalyses/samplePass_fullSet_AlleleReads_singleSNPs.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE)
LWED_singleSNP_alleleReads<-read.delim("./03_tamRun3/04_genoAnalyses/samplePass_LWED_AlleleReads_singleSNPs.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE) %>%
  rownames_to_column("Locus_ID") %>%
  mutate(Locus_ID = sub('[_][^_]+$', '', Locus_ID)) %>%
  column_to_rownames("Locus_ID")
SIMP_singleSNP_alleleReads<-read.delim("./03_tamRun3/04_genoAnalyses/samplePass_SIMP_AlleleReads_singleSNPs.txt",header=TRUE,row.names=1,stringsAsFactors=FALSE) %>%
  rownames_to_column("Locus_ID") %>%
  mutate(Locus_ID = sub('[_][^_]+$', '', Locus_ID)) %>%
  column_to_rownames("Locus_ID")

# Summarize single SNP results
fullSet_singleSNP_summary <- summarizeGTscore(fullSet_singleSNP_alleleReads, fullSet_singleSNP_locusTable, fullSet_polyGenResults_singleSNP_10x)

LWED_singleSNP_summary<-summarizeGTscore(LWED_singleSNP_alleleReads, LWED_singleSNP_locusTable, LWED_polyGenResults_singleSNP_10x)

SIMP_singleSNP_summary<-summarizeGTscore(SIMP_singleSNP_alleleReads, SIMP_singleSNP_locusTable, SIMP_polyGenResults_singleSNP_10x)
```

```{r, eval=FALSE}
#write results
write.table(fullSet_singleSNP_summary,"./03_tamRun3/04_genoAnalyses/samplePass_fullSet_singleSNP_summary.txt",quote=FALSE,sep="\t",row.names=FALSE)
write.table(LWED_singleSNP_summary,"./03_tamRun3/04_genoAnalyses/samplePass_LWED_singleSNP_summary.txt",quote=FALSE,sep="\t",row.names=FALSE)
write.table(SIMP_singleSNP_summary,"./03_tamRun3/04_genoAnalyses/samplePass_SIMP_singleSNP_summary.txt",quote=FALSE,sep="\t",row.names=FALSE)
```

### Master locus summary

I also found it helpful to create a "master" locus summary file - this way, we have a single file for all loci that provides performance metrics that are specific to that locus's species. This file includes data from both the locus summaries and single SNP summaries created earlier.

In doing so, this means that...

-   values for LWED-specific loci reflect performance with LWED individuals only
-   values for SIMP-specific loci reflect performance with SIMP individuals only
-   all other loci reflect performance with LWED and SIMP individuals combined

```{r}
# Load locus summaries
ls <- read.table("./03_tamRun3/04_genoAnalyses/samplePass_fullSet_GTscore_locusSummary.txt", header = T, sep = "\t")
lwed_ls <- read.table("./03_tamRun3/04_genoAnalyses/samplePass_LWED_GTscore_locusSummary.txt", header = T, sep = "\t")
simp_ls <- read.table("./03_tamRun3/04_genoAnalyses/samplePass_SIMP_GTscore_locusSummary.txt", header = T, sep = "\t")

# Separate locus summaries and singleSNP summaries into results from shared and species-specific loci analyses
## Locus summaries
ls1 <- ls %>%
  filter(!str_detect(Locus, "LWED|SIMP"))
lwed1_ls <- lwed_ls %>%
  filter(str_detect(Locus, "LWED"))
simp1_ls <- simp_ls %>%
  filter(str_detect(Locus, "SIMP"))

## SingleSNP summaries
ss <- fullSet_singleSNP_summary %>%
  mutate(Locus_ID = sub('[_][^_]+$', '', Locus_ID)) %>%
  filter(!str_detect(Locus_ID, "LWED|SIMP"))
lwed_ss <- LWED_singleSNP_summary %>%
  filter(str_detect(Locus_ID, "LWED"))
simp_ss <- SIMP_singleSNP_summary %>%
  filter(str_detect(Locus_ID, "SIMP"))

# Recombine locus summaries & single snp summary files, then merge the two
ls_recombine <- rbind(ls1, lwed1_ls, simp1_ls)

ss_recombine <- rbind(ss, lwed_ss, simp_ss)

ls_ss <- merge(ls_recombine, ss_recombine, by.x = "Locus", by.y = "Locus_ID") 
```

```{r, eval=FALSE}
# Export
write.csv(ls_ss, "./03_tamRun3/04_genoAnalyses/samplePass_master_locusSummary.csv", row.names = F)
```

# 6 Overamplifiers

Now that we've removed underperforming samples, we can look at total and median read counts per locus to see if any are overamplifying.

### Sum allele reads for each locus

First we need to get the total read counts per locus (vs. per allele) - this process is similar to what I did previously to identify loci with less than 10x coverage. Here though, I'm keeping all read counts (so no 10x filter).

Load read counts for samples with \>50% genotype success

```{r}
readCounts_samplePass <- read.table("./03_tamRun3/04_genoAnalyses/samplePass_fullSet_AlleleReads_singleSNPs.txt")
```

Set up a function to sum allele reads for each locus (use package gsubfn) and apply to readCounts_samplePass

```{r}
# Define function
repl <- function(x) gsubfn("(\\d+),(\\d+)", ~ as.numeric(x) + as.numeric(y), paste(x))

# Sum allele reads for each locus
readCounts_all <- replace(readCounts_samplePass, TRUE, lapply(readCounts_samplePass, repl)) %>%
  rownames_to_column("Locus") %>%
  mutate(Locus = sub("_[^_]+$", "\\1", Locus)) %>%
  column_to_rownames("Locus")
```

Recode species-specific loci with "NA" for samples of the non-informative species

```{r}
readCounts_lwedSIMP <- readCounts_all %>%
  rownames_to_column("locus") %>%
  pivot_longer(!locus,
               names_to = "sampleID",
               values_to = "readCounts") %>%
  mutate(readCounts =
           ifelse(sampleID %in% samplesLWED$Sample & grepl("SIMP", locus), NA, 
                  ifelse(sampleID %in% samplesSIMP$Sample & grepl("LWED", locus), NA, readCounts))) %>%
  pivot_wider(names_from = sampleID,
              values_from = readCounts) %>%
  column_to_rownames("locus")
```

Get total and median read counts for all samples combined

```{r}
readCounts_allCombined_summary <- readCounts_all %>%
  mutate_if(is.character, as.numeric) %>%
  rownames_to_column("locus") %>%
  pivot_longer(!locus,
               names_to = "sampleID",
               values_to = "readCounts") %>%
  group_by(locus) %>%
  summarise(readSum = sum(as.numeric(readCounts)),
            readMedian = median(as.numeric(readCounts))) %>%
  as.data.frame()
```

Get total and median read counts per locus for each species

```{r}
readCounts_lwedSIMP_summary <- readCounts_lwedSIMP %>%
  t() %>%
  as.data.frame() %>%
  mutate(species = ifelse(row.names(.) %in% samplesLWED$Sample, "LWED",
                          ifelse(row.names(.) %in% samplesSIMP$Sample, "SIMP", NA))) %>%
  rownames_to_column("sampleID") %>%
  pivot_longer(!c(species, sampleID),
               names_to = "locus",
               values_to = "readCounts") %>%
  select(!sampleID) %>%
  filter(!is.na(species)) %>%
  group_by(species, locus) %>%
  summarise(readSum = sum(as.numeric(readCounts)),
            readMedian = median(as.numeric(readCounts))) %>%
  as.data.frame()
```

### Find overamplifiers

First define a function to find outliers. The function is set so that it will return the name of the locus when applied to our dataset.

```{r}
findoutlier <- function(x) {
  return(x < quantile(x, .25) - 1.5*IQR(x) | x > quantile(x, .75) + 1.5*IQR(x))
}
```

Then apply the function - here we're identifying loci that are outliers based on their total reads as well as their median reads (run with all samples combined as well as separately for each species).

```{r}
# All samples combined
readCounts_outliers_allCombined <- readCounts_allCombined_summary %>%
  mutate(sumOutlier = ifelse(findoutlier(readSum), locus, NA)) %>%
  relocate(sumOutlier, .after = readSum) %>%
  mutate(medianOutlier = ifelse(findoutlier(readMedian), locus, NA)) %>%
  relocate(medianOutlier, .after = readMedian) %>%
  arrange(-readSum)

# LWED-specific loci
readCounts_outliers_lwed <- readCounts_lwedSIMP_summary %>%
  filter(species == "LWED") %>%
  select(!species) %>%
  na.omit() %>%
  mutate(sumOutlier = ifelse(findoutlier(readSum), locus, NA)) %>%
  relocate(sumOutlier, .after = readSum) %>%
  mutate(medianOutlier = ifelse(findoutlier(readMedian), locus, NA)) %>%
  relocate(medianOutlier, .after = readMedian) %>%
  arrange(-readSum)

# SIMP-specific loci
readCounts_outliers_simp <- readCounts_lwedSIMP_summary %>%
  filter(species == "SIMP") %>%
  select(!species) %>%
  na.omit() %>%
  mutate(sumOutlier = ifelse(findoutlier(readSum), locus, NA)) %>%
  relocate(sumOutlier, .after = readSum) %>%
  mutate(medianOutlier = ifelse(findoutlier(readMedian), locus, NA)) %>%
  relocate(medianOutlier, .after = readMedian) %>%
  arrange(-readSum)

# General loci that are outliers in both species
readCounts_outliers_lwedSIMP <- readCounts_outliers_lwed %>%
  filter(sumOutlier %in% readCounts_outliers_simp$sumOutlier) %>%
  filter(medianOutlier %in% readCounts_outliers_simp$medianOutlier) %>%
  select(c(locus, sumOutlier, readSum, medianOutlier, readMedian)) %>%
  na.omit() %>%
  rename("readSum" = "readSum_lwed") %>%
  rename("readMedian" = "readMedian_lwed") %>%
  merge(., readCounts_outliers_simp, by = "locus") %>%
  rename("readSum" = "readSum_simp") %>%
  rename("readMedian" = "readMedian_simp") %>%
  select(c(locus, readSum_lwed, readSum_simp, readMedian_lwed, readMedian_simp))
```

### Tables

Overamplifying loci when looking at all samples combined:

```{r, echo=FALSE}
allCombined_outliers <- readCounts_outliers_allCombined %>%
  filter(!is.na(sumOutlier)) %>%
  filter(!is.na(medianOutlier)) %>%
  select(-sumOutlier, -medianOutlier) %>%
  mutate(readSum_avg = mean(readCounts_allCombined_summary$readSum)) %>%
  relocate(readSum_avg, .after = readSum) %>%
  mutate(readMedian_avg = mean(readCounts_allCombined_summary$readMedian)) %>%
  relocate(readMedian_avg, .after = readMedian) %>%
  arrange(desc(readSum)) %>%
  tibble::rowid_to_column(., "#") %>%
  dplyr::rename(" " = "#")

allCombined_outliers %>%
  kable(caption = "Overamplifiers (all samples combined)") %>%
  kable_material(full_width = F) %>%
  scroll_box(fixed_thead = list(enabled = T, background = "#363636"))
```

Overamplifying loci for each species (note that general loci are only included as overamplifiers if they were outliers for sum/median reads in both species):

```{r, echo=FALSE}
lwedOutliers <- readCounts_outliers_lwed %>%
  filter(!is.na(sumOutlier)) %>%
  filter(!is.na(medianOutlier)) %>%
  filter(str_detect(locus, "LWED")) %>%
  select(., -sumOutlier, -medianOutlier) %>%
  dplyr::rename("readSum_lwed" = "readSum") %>%
  dplyr::rename("readMedian_lwed" = "readMedian") %>%
  mutate(readSum_simp = NA) %>%
  relocate(readSum_simp, .after = readSum_lwed) %>%
  mutate(readMedian_simp = NA) %>%
  relocate(readMedian_simp, .after = readMedian_lwed)

simpOutliers <- readCounts_outliers_simp %>%
  filter(!is.na(sumOutlier)) %>%
  filter(!is.na(medianOutlier)) %>%
  filter(str_detect(locus, "SIMP")) %>%
  select(., -sumOutlier, -medianOutlier) %>%
  dplyr::rename("readSum_simp" = "readSum") %>%
  dplyr::rename("readMedian_simp" = "readMedian") %>%
  mutate(readSum_lwed = NA) %>%
  relocate(readSum_lwed, .before = readSum_simp) %>%
  mutate(readMedian_lwed = NA) %>%
  relocate(readMedian_lwed, .before = readMedian_simp)

generalOutliers <- readCounts_outliers_lwedSIMP %>%
  arrange(desc(readSum_lwed))

allOutliers <- rbind(lwedOutliers, simpOutliers, generalOutliers) %>%
  rowwise() %>%
  mutate(readSum_lwedSimp = sum(readSum_lwed, readSum_simp, na.rm = T)) %>%
  relocate(readSum_lwedSimp, .after = locus) %>%
  arrange(desc(readSum_lwedSimp)) %>%
  tibble::rowid_to_column(., "#") %>%
  dplyr::rename(" " = "#")

allOutliers %>%
  kable(caption = "Overamplifiers (by species subset)") %>%
  kable_material(full_width = F) %>%
  scroll_box(fixed_thead = list(enabled = T, background = "#363636"))
```

### Plots

All samples combined:

```{r}
ggplot(readCounts_allCombined_summary, aes(x=readSum, y=factor(0))) +
  geom_boxplot() +
  geom_point(data = allCombined_outliers,
             aes(color = locus)) +
  labs(title = "Total reads per locus", x = "Total number of reads", y = "") +
  theme_bw()
```

Species subsets:

```{r, echo=FALSE}
ppReads_outliers_shared <- readCounts_outliers_lwedSIMP %>%
  select(c(locus, readSum_lwed, readSum_simp)) %>%
  pivot_longer(!locus,
               names_to = "species",
               values_to = "readSum") %>%
  mutate(species = gsub("readSum_lwed", "LWED", species)) %>%
  mutate(species = gsub("readSum_simp", "SIMP", species))

ggplot(readCounts_lwedSIMP_summary, aes(x=readSum, y=species)) +
  geom_boxplot() +
  geom_point(data = ppReads_outliers_shared,
             aes(color = locus)) +
  labs(title = "Total reads per locus", x = "Total number of reads", y = "") +
  theme_bw()
```

```{r, eval=FALSE}
ggplot(readCounts_lwedSIMP_summary, aes(x=readMedian, y=species)) +
  geom_boxplot() +
  labs(title = "Median reads per locus per sample", x = "Median number of reads", y = "") +
  theme_bw()
```

# 7 Poor genotype success

Now that we're looking at only samples that "passed", we can begin to assess the performance of individual loci. First we'll look at genotype success rate.

## 7.1 Full set of loci

In total, there are **35 loci with \<50% genotype success** (i.e., were genotyped in less than 50% of all samples). Of these, we have 27 INDID, 3 LWED, 1 SPECIES, and 4 SEXID loci (including 3 general and 1 each of SIMP-specific sex loci).

```{r}
# First add a column to note which set each locus belongs to
loci_samplePass <- read.csv("./03_tamRun3/04_genoAnalyses/samplePass_master_locusSummary.csv") %>%
  mutate(set = ifelse(str_detect(Locus, "INDID"),"INDID",
                      ifelse(str_detect(Locus, "SEXID_LWED"), "SEXID_LWED",
                             ifelse(str_detect(Locus, "SEXID_SIMP"), "SEXID_SIMP",
                                    ifelse(str_detect(Locus, "SEXID"), "SEXID",
                                           ifelse(str_detect(Locus, "LWED"), "LWED",
                                                  ifelse(str_detect(Locus, "SIMP"), "SIMP",
                                                         ifelse(str_detect(Locus, "SPECIES"), "SPECIES",
                                                                NA
                                                                ))))))))

# Get loci with under 50% genotype rate & create column for locus set
lociPF_under50 <- loci_samplePass %>%
  filter(GenotypeRate < 0.5)
```

```{r, echo=FALSE}
lociPF_under50 %>%
  arrange(set, GenotypeRate) %>%
  select(-conScore) %>%
  relocate(set, .before = Locus) %>%
  relocate(c(GenotypeRate, AvgReadDepth), .after = Locus) %>%
  mutate(x = row_number()) %>%
  relocate(x) %>%
  dplyr::rename(" " = "x") %>%
  kable(caption = "Loci with under 50% genotype success") %>%
  kable_material(full_width = F) %>%
  scroll_box(fixed_thead = list(enabled = T, background = "#363636"))
```

```{r}
knitr::knit_exit()
```

## 5.2 Sex & species loci

Of the sex and species loci that failed, I think that SEXID_215 and SEXID_219 are the only two worth pulling from the primer pool. They have the lowest percentage of genotype success of this group, and are the only two loci with an average read depth under 10.

```{r}
lociPF_under50_sexSpecies <- lociPF_under50 %>%
  filter(set %in% c("SEXID", "SEXID_LWED", "SEXID_SIMP", "SPECIES"))
```

## 5.3 Hair vs. blood samples

I also want to check to see if locus performance differs between hair and blood samples, especially since hair samples were run with split primer pools.

```{r}
# Subset [[REWORK THIS]]
genos_md <- genos_fullSet %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("sampleID") %>%
  merge(., md_tamRun3[,c("sampleID", "animalID", "sampleType")], by = "sampleID")

genos_hair <- genos_md %>%
  filter(sampleType == "hair")

genos_blood <- genos_md %>%
  filter(sampleType == "blood")
```

# 8 Genotype consistency

I assessed genotype consistency across runs in tamRun3_genoAnalyses.Rmd - the data below was derived from analyses in that script.

```{r}

```


# 9 Artifact sequences, unaccounted for in-silico probe variations, & low-specificity in-silico probe sequences

The proportion of primer-probe reads to primer reads is helpful in assessing primer performance, where large discrepancies in primer, probe, and primer-probe reads can indicate artifact sequences, unaccounted for in-silico probe variations, or an in-silico probe sequence that's not specific to the target amplicon.

GTseq documentation provides the following as examples of read counts for poorly performing loci (locus name, primer reads, probe reads, primer-probe reads):

```         
Example 1: Artifact sequences.
    LocusName1, 325096 ,2609, 2367
Example 2: Unaccounted for in-silico probe variation or possibly entirely off-target amplification.
    LocusName2, 32252, 0, 0
Example 3: in-silico probe not specific enough.
    LocusName3, 34435, 3400826, 33213
```

We can use these examples with the GTscore locus summary output to see which loci aren't performing optimally.

## 9.1 Artifact sequences

We can see which primers might be resulting in artifact sequences by identifying the loci with < 50% primer-probe proportion, which represents the proportion of primer reads for which the probe sequence also matches.

```{r}
low_primerProbeProp <- locusSum %>%
  filter(Primer.Probe.Proportion < 0.5) %>%
  arrange(Primer.Probe.Proportion) %>%
  select(c("Locus", "Primer.Reads", "Primer.Probe.Reads", "Primer.Probe.Proportion", "AvgReadDepth", "GenotypeRate")) %>%
  tibble::rowid_to_column(., "#") %>%
  dplyr::rename(" " = "#")

low_primerProbeProp %>% 
  kable(caption = "Loci with under 50% probe reads:primer reads") %>%
  kable_material(full_width = F) %>%
  scroll_box(fixed_thead = list(enabled = T, background = "#363636"))
```

Despite the low probe:primer proportion, many of these loci still have decent average read depths (all > 20) and genotype success rates (ranging from 10% to 67% of samples genotyped). 

# 9 GTscore locus diagnostics

## 9.1 Background info

This section is taken directly from the GTscore pipeline - I've transferred it here so that all locus analyses are in one place.

Diagnostic functions are provided to help in identifying patterns of sequence variation for loci. This can assist in identifying SNPs that were not accounted for in the initial probe design and in adjusting the in-silico probes to exclude off-target sequence from genotyping.

There are two approaches used by GTscore: First, plotting the number of nucleotide mismatches by position in the sequence data relative to the reference sequence for each locus, and second, performing sequence alignments using the program MSA (Bodenhofer et al. 2015). Plotting the mismatches by position is fast and easy to interpret except in the case of indels. The MSA alignments take longer to complete but facilitate the visualization of indels.

The first step for both methods is to get the sequences that aligned to each locus, this can be done based on primer alignments or primer-probe alignments using the script matchReads.pl.

## 9.2 Set-up

### Sequence alignment to each locus (Perl)

NOTE - I made a small edit to the matchReads.pl script from GTscore; I added an option to designate an "inDir" to avoid having to copy/paste all of the sequences into another folder.

Input flags for this script are:

-   --p a tab delimited file containing primer/probe information for each locus
-   --files a text file containing a list of .fastq sequence files to count reads from
-   --matchType the match type chosen for retaining sequences for each locus. Options are "primer" to retain sequences that match the primer for a locus or "primerProbe" to retain sequences that match both the primer and probe. primerProbe is the default if no option is specified.

Optional flags:

-   --prefix optional prefix for output file names

You can run matchReads.pl from the command line using the following example: perl matchReads.pl -p primerProbeFile.txt --files sampleFiles.txt --matchType primerProbe [--prefix]

Alternatively, you can also run it through R:

```{r match reads, eval=FALSE}
#primer match
system2("perl",
        args="./03_tamRun3/03_run3GTscore/matchReads_modified.pl -p ./03_tamRun3/03_run3GTscore/primerProbeFile_fullSet.txt --files ./03_tamRun3/03_run3GTscore/sampleFiles_fullSet_cat.txt --matchType primer --prefix fullSet_ --inDir ./03_tamRun3/02_run3Interleaved/")

#primer AND probe match
system2("perl",
        args="./03_tamRun3/03_run3GTscore/matchReads_modified.pl -p ./03_tamRun3/03_run3GTscore/primerProbeFile_fullSet.txt --files ./03_tamRun3/03_run3GTscore/sampleFiles_fullSet_cat.txt --matchType primerProbe --prefix fullSet_ --inDir ./03_tamRun3/02_run3Interleaved/")
```

The default output file names are matchReads_primerAligned.txt or matchReads_primerProbeAligned.txt depending on which match type was chosen.

Take a peak at output:

```{r}
matchReads_primerAligned <- read.table("./03_tamRun3/04_genoAnalyses/fullSet_matchedReads_primerAligned.txt")
head(matchReads_primerAligned)
matchReads_primerProbeAligned <- read.table("./03_tamRun3/04_genoAnalyses/fullSet_matchedReads_primerProbeAligned.txt")
head(matchReads_primerProbeAligned)

matchReads_primerAligned_run1 <- read.table('/home/rachelvoyt/Documents/UT-Grad/Development/repos/tamarinGenetics_primatesPeru/seqAnalysis/00_optimization/03_gtScore/archived/matchedReads_SIMP_primerAligned.txt')
head(matchReads_primerAligned_run1)
```

### Create reference amplicon sequences file

To conduct locus diagnostics, we need both a text file and fasta file of reference amplicon sequences. These sequences are in Sam's pos_amplicon.csv file, which I reformatted in the first sequencing run for use in this pipeline. Now we just need to do a bit more tweaking to ensure that 1) we have only the optimized amplicon sequences and 2) the names match up correctly

**NOTE** that the reference sequences don't include the loci that originally had the bp3 error

Text file first:

```{r}
# Original file
refseqs_original <- read.table("./00_tamRun1_optimization/ampliconRefSeqs.txt", header = T) %>%
  mutate(Locus = gsub("\\..*","", Locus)) %>% # adjust locus names to ditch everything after "."
  mutate(Locus = str_replace(Locus, 'SEXID_195', 'SEXID_LWED_195')) %>%
  mutate(Locus = str_replace(Locus, 'SEXID_197', 'SEXID_SIMP_197')) %>%
  mutate(Locus = str_replace(Locus, 'SEXID_198', 'SEXID_SIMP_198')) %>%
  mutate(Locus = str_replace(Locus, 'SEXID_203', 'SEXID_SIMP_203')) %>%
  mutate(Locus = str_replace(Locus, 'SEXID_208', 'SEXID_LWED_208')) %>%
  mutate(Locus = str_replace(Locus, 'SEXID_211', 'SEXID_LWED_211')) %>%
  mutate(Locus = str_replace(Locus, 'SEXID_218', 'SEXID_SIMP_218'))

# Subset to optimized loci only
refseqs_updated <- refseqs_original %>%
  filter(Locus %in% locusTable$Locus_ID)

# Export
write.table(refseqs_updated, "./03_tamRun3/04_genoAnalyses/ampliconRefSeqs_psRun3.txt", sep= "\t", row.names = F, quote = F)
```

Then fasta file:

```{r}
amplicon_txt <- read.table("./03_tamRun3/04_genoAnalyses/ampliconRefSeqs_psRun3.txt", header = T) %>%
  dplyr::rename(c(seq.name=Locus, seq.text=refSeq))

phylotools::dat2fasta(amplicon_txt, outfile = "./03_tamRun3/04_genoAnalyses/ampliconRefSeqs_psRun3.fasta")
```

## 9.3 MSA alignment (GTscore.R)

MSA alignment of the matched reads can be done directly on the output from matchReads.pl using the alignMatchedSeqs command in GTscore. Probe sequence is incorporated into the alignment to visualize how probes may be affecting read counting, and reference sequence can optionally be included to facilitate comparison of the observed sequence with the target locus. The probe sequence is obtained from the primer-probe file originally used by AmpliconReadCounter.pl; the reference sequence file has a two column format where the first column is the locus name and the second column is the reference sequence for the locus amplicon. 

MSA will take a very long time to run if too many sequences are included for alignment so a minimum read threshold (minReads) is included as an option in the alignment command (suggest begin with minReads=20). In addition, a maximum of 100 unique sequences (ranked by number of reads) will be aligned. The maximum number of reads allowed for alignment can be changed using the maxAlignedSeqs option. Be sure the required perl package has been installed (Excel-Writer-XLSX).

### Load data

```{r}
# load reference sequences in table format
referenceSeqs <- read.delim("./03_tamRun3/04_genoAnalyses/ampliconRefSeqs_psRun3.txt", header=TRUE, stringsAsFactors=FALSE )

# load primer probe file
primerProbes <- read.delim("./03_tamRun3/03_run3GTscore/primerProbeFile_fullSet.txt", header=TRUE, stringsAsFactors=FALSE) %>%
  filter(Locus %in% referenceSeqs$Locus)

# primer aligned reads
primerMatchedReads <- read.delim("./03_tamRun3/04_genoAnalyses/fullSet_matchedReads_primerAligned.txt", header = TRUE, stringsAsFactors = FALSE)

# primer-probe aligned reads
primerProbeMatchedReads <- read.delim("./03_tamRun3/04_genoAnalyses/fullSet_matchedReads_primerProbeAligned.txt", header = TRUE, stringsAsFactors = FALSE)
```

### Run script

**NOTE** that the formatMSAalignments.pl script needs to be in your current working directory for this to work; at some point I'll edit the GTscore source script to allow for it to be in a different place, but today is not that day. :)

```{r, eval=FALSE}
# primer aligned reads
alignMatchedSeqs(referenceSeqs = referenceSeqs,
                 primerProbes = primerProbes,
                 matchedReads = primerMatchedReads,
                 minReads = 20,
                 maxAlignedSeqs = 100,
                 type = "primer",
                 saveDir = "./03_tamRun3/04_genoAnalyses/MSA_primerMatched")

# try without ref seqs (maybe it'll help??)
alignMatchedSeqs(primerProbes = primerProbes,
                 matchedReads = primerMatchedReads,
                 minReads = 20,
                 maxAlignedSeqs = 100,
                 type = "primer",
                 saveDir = "./03_tamRun3/04_genoAnalyses/MSA_primerMatched")

#primer probe aligned reads
alignMatchedSeqs(referenceSeqs = referenceSeqs,
                 primerProbes = primerProbes,
                 matchedReads = primerProbeMatchedReads,
                 minReads = 20,
                 maxAlignedSeqs = 100,
                 type = "primerProbe",
                 saveDir = "./03_tamRun3/04_genoAnalyses/MSA_primerProbeMatched")
```

#### Troubleshooting

Script runs and returns "locus completed", but doesn't provide excel file output and prints the following:

NOT WORKING: ERROR: Empty sequences found: Seq1

Error in msaFun(inputSeqs = inputSeqs, cluster = cluster, gapOpening = gapOpening, : ClustalW finished with errors

Looking back at the GTscore_modified.R source script, it seems like the problem is coming from the formatMSAalignments.pl script, which is called by the alignMatchedseqs() function.

To attempt to fix this, I installed igraph (which did not install properly when I originally installed msa) and re-ran... at first it gave me the same error, but then I did it again and it said everything was completed, but no error message appeared. HOWEVER the excel files are still missing.

Comparing .txt outputs between this run and tamRun1, there are some little differences -- e.g., in this run, the probes and ref sequence is at the top, whereas before they were the last lines. ALSO, looking at INDID_21 (and others too), in this run there are spaces added within the probe sequence. Odd.

Let's see what happens if we run the perl script by itself:

```{r}
system2("perl",
        args="./03_tamRun3/03_run3GTscore/formatMSAalignments.pl -p ./03_tamRun3/03_run3GTscore/primerProbeFile_fullSet.txt --files ./03_tamRun3/03_run3GTscore/sampleFiles_fullSet_cat.txt --matchType primer --prefix fullSet_ --inDir ./03_tamRun3/02_run3Interleaved/")
```





Original alignMatchedSeqs function from GTscore.R:
```{r}
alignMatchedSeqs<-function(referenceSeqs=NULL,primerProbes,matchedReads,minReads=1,maxAlignedSeqs=100,type="primerProbe",saveDir=""){
  outDir=paste(saveDir,"/",sep="")
  #loci<-unique(primerProbes$Locus)
  loci<-primerProbes
  for (x in 1:dim(loci)[1]){
    locus<-loci$Locus[x]
    if(type=="primerProbe"){
      locusSNP<-paste(loci$Locus[x],loci$SNP[x],sep="_")
      locusReads<-matchedReads[matchedReads$Locus==locusSNP,]
      #make new column of combined locus name and SNP position
      primerProbes$LocusSNP<-paste(primerProbes$Locus,primerProbes$SNPpos,sep="_")
      #filter to retain probes from one locus
      probes<-primerProbes[primerProbes$LocusSNP==locusSNP,]
      #convert problem characters in locus name
      safeLocusName<-gsub("-","_",locusSNP)
      safeLocusName<-gsub("\\.","_",safeLocusName)
      safeLocusName<-gsub("'","prime",safeLocusName)
    }else if(type=="primer"){
      locusReads<-matchedReads[matchedReads$Locus==locus,]
      #filter to retain probes from one locus
      probes<-primerProbes[primerProbes$Locus==locus,]
      #convert problem characters in locus name
      safeLocusName<-gsub("-","_",locus)
      safeLocusName<-gsub("\\.","_",safeLocusName)
      safeLocusName<-gsub("'","prime",safeLocusName)
    }
    
    
    if(dim(locusReads)[1]>0){
      #filter to retain unique reads and sum counts for each unique read
      uniqueLocusReads<-aggregate(Count ~ Sequence, data=locusReads, sum)
    }else{
      if(type=="primerProbe"){
        noReads<-paste(locusSNP,"No Reads", sep=" ")
      }else if(type=="primer"){
        noReads<-paste(locus,"No Reads", sep=" ")
      }
      print(noReads)
      next
    }
    if(max(uniqueLocusReads$Count>=minReads)){
      uniqueLocusReads<-uniqueLocusReads[uniqueLocusReads$Count>=minReads,]
      #restrict MSA alignment to N unique sequences ranked by number of reads (high to low)
      uniqueLocusReads<-head(uniqueLocusReads[order(-uniqueLocusReads$Count),], n=maxAlignedSeqs)
      
      #make fasta file of retained sequences
      makeFasta<-function(refSeq=NULL,sequences,probes,safeLocusName){
        #initialize fasta output file
        fastaOut<-paste(outDir,safeLocusName,".fasta",sep="")
        cat(NULL,file=fastaOut,append=FALSE)
        if(!is.null(refSeq)){
          #add reference sequence to fasta file
          cat(">Reference",as.character(refSeq$refSeq),sep="\n",file=fastaOut,append=TRUE)
        }
        #add matched sequence reads to fasta file
        for (i in 1:dim(sequences)[1]){
          #locusName<-paste(">",sequences$Locus[i],"Reads: ", sequences$Count[i],sep="")
          locusName<-paste(">", sequences$Count[i], "Reads",sep=" ")
          locusSequence<-as.character(sequences$Sequence[i])
          cat(locusName,locusSequence,sep="\n",file=fastaOut,append=TRUE)
        }
        for (i in 1:dim(probes)[1]){
          probe1Name<-">probe1"
          probe2Name<-">probe2"
          #primer<-as.character(probes$Primer[i])
          probe1<-as.character(probes$Probe1[i])
          probe2<-as.character(probes$Probe2[i])
          #replace any brackets in probe with IUB code
          probe1<-str_replace_all(probe1,c("\\[ATGC\\]"="N","\\[AG\\]"="R","\\[GA\\]"="R","\\[CT\\]"="Y","\\[TC\\]"="Y","\\[GT\\]"="K","\\[TG\\]"="K","\\[AC\\]"="M","\\[CA\\]"="M","\\[GC\\]"="S","\\[CG\\]"="S","\\[AT\\]"="W","\\[TA\\]"="W"))
          probe2<-str_replace_all(probe2,c("\\[ATGC\\]"="N","\\[AG\\]"="R","\\[GA\\]"="R","\\[CT\\]"="Y","\\[TC\\]"="Y","\\[GT\\]"="K","\\[TG\\]"="K","\\[AC\\]"="M","\\[CA\\]"="M","\\[GC\\]"="S","\\[CG\\]"="S","\\[AT\\]"="W","\\[TA\\]"="W"))
          
          cat(probe1Name,probe1,sep="\n",file=fastaOut,append=TRUE)
          cat(probe2Name,probe2,sep="\n",file=fastaOut,append=TRUE)
        }
      }
      
      if(is.null(referenceSeqs)){
        makeFasta(sequences=uniqueLocusReads,probes=probes,safeLocusName=safeLocusName)
      }else{
        #filter to retain reference sequence from one locus
        refSeq<-referenceSeqs[as.character(referenceSeqs$Locus)==as.character(locus),]
        #force uppercase to prevent errors in sequence alignment
        refSeq$refSeq<-toupper(refSeq$refSeq)
        
        makeFasta(refSeq,uniqueLocusReads,probes,safeLocusName)
      }
      
      #load fasta file of retained sequences
      locusSequences<-readAAStringSet(paste(outDir,safeLocusName,".fasta",sep=""))
      #align sequences
      #use capture.output to suppress stdout from msa alignment
      capture.output(locusAlignments<-msa(locusSequences),file=NULL)
      #convert alignments to dataframe
      seqCount<-names(locusAlignments@unmasked)
      seq<-paste(locusAlignments)
      seqDF<-data.frame(seqCount, seq)
      #head(seqDF)
      
      #write dataframe output
      dfOut<-paste(outDir,safeLocusName,".txt",sep="")
      write.table(seqDF,dfOut,sep="\t",quote=FALSE,row.names=FALSE)
      
      #call formatMSAalignments.pl to convert file to conditionally formatted excel file
      formatMSAcmd<-paste("perl formatMSAalignments.pl", dfOut, sep=" ")
      system(formatMSAcmd)
      
      #report that locus sequence alignment was completed
      if(type=="primerProbe"){
        completed<-paste(locusSNP,"completed", sep=" ")
      }else if(type=="primer"){
        completed<-paste(locus,"completed", sep=" ")
      }
      print(completed)
    }else{
      if(type=="primerProbe"){
        noReads<-paste(locusSNP,"No Reads", sep=" ")
      }else if(type=="primer"){
        noReads<-paste(locus,"No Reads", sep=" ")
      }
      print(noReads)
    }
  }
}
```


Excel files are output for each locus within the directory specified by savDir. The first row is a consensus sequence based on the sequence alignments. This is followed by the probes, reference sequence if included, and then the sequence alignments.

## 9.4 Plotting mismatches by position (Perl and GTscore.R)

### Calculate sequence mismatches by position (Perl)

Plotting the number of mismatches by position requires first comparing each matched sequence against the reference sequence and summing the number of mismatches for each nucleotide position. This is done with the perl script seqMismatchPositions.pl.

Input flags for this script are:

-   --amplicon a fasta file containing the reference amplicon sequence for each locus
-   --matchedSeqs a tab delimited file containing sequences that matched each locus. This file is generated by matchReads.pl
-   --matchType the match type chosen for retaining sequences for each locus
    -   Options are "primer" to retain sequences that match the primer for a locus or "primerProbe" to retain sequences that match both the primer and probe. primerProbe is the default if no option is specified.

Optional flags:

-   --prefix optional prefix for output file names

You can run seqMismatchPositions.pl from the command line using the following example: perl seqMismatchPositions.pl --amplicon ampliconRefSeqs.fasta --matchedSeqs matchedReads_primerAligned.txt --matchType primer [--prefix]

Alternatively, you can also run it through R:

```{r sequence mismatches, eval=FALSE}
# fullSet
system2("perl",
        args="./03_tamRun3/03_run3GTscore/seqMismatchPositions.pl --amplicon ./03_tamRun3/04_genoAnalyses/ampliconRefSeqs_psRun3.txt --matchedSeqs ./03_tamRun3/04_genoAnalyses/fullSet_matchedReads_primerAligned.txt --matchType primer")

system2("perl",
        args="./03_tamRun3/03_run3GTscore/seqMismatchPositions.pl --amplicon ./03_tamRun3/04_genoAnalyses/ampliconRefSeqs_psRun3.txt --matchedSeqs ./03_tamRun3/04_genoAnalyses/fullSet_matchedReads_primerProbeAligned.txt --matchType primerProbe")
```

The default output file names are mismatchPositions_primer.txt or mismatchPositions_primerProbe.txt depending on which match type was chosen. The output files will be used by the summarizeMismatches function in GTscore to generate plots of mismatches by position for each locus.

### Troubleshooting

The script ran fine, but the output file just as the column headings but nothing else. 

### Plot of sequence mismatches by position (GTscore.R)

```{r}
#load results from seqMismatchPositions.pl
#primer matched sequences
mismatchPositionData_primer<-read.delim("mismatchPositions_primer.txt", header=TRUE, stringsAsFactors=FALSE)
mismatchPositionData_primer_LWED<-read.delim("mismatchPositions_LWED_primer.txt", header=TRUE, stringsAsFactors=FALSE)
mismatchPositionData_primer_SIMP<-read.delim("mismatchPositions_SIMP_primer.txt", header=TRUE, stringsAsFactors=FALSE)
#primer probe matched sequences
mismatchPositionData_primerProbe<-read.delim("mismatchPositions_primerProbe.txt", header=TRUE, stringsAsFactors=FALSE)
mismatchPositionData_primerProbe_LWED<-read.delim("mismatchPositions_LWED_primerProbe.txt", header=TRUE, stringsAsFactors=FALSE)
mismatchPositionData_primerProbe_SIMP<-read.delim("mismatchPositions_SIMP_primerProbe.txt", header=TRUE, stringsAsFactors=FALSE)


#generate plots of mismatches by position
#primer matched sequences
summarizeMismatches(mismatchPositionData_primer,saveDir="mismatchPositionPlots_primer")
summarizeMismatches(mismatchPositionData_primer_LWED,saveDir="mismatchPositionPlots_primer_LWED")
summarizeMismatches(mismatchPositionData_primer_SIMP,saveDir="mismatchPositionPlots_primer_SIMP")
#primer probe matched sequences
summarizeMismatches(mismatchPositionData_primerProbe,saveDir="mismatchPositionPlots_primerProbe")
summarizeMismatches(mismatchPositionData_primerProbe_LWED,saveDir="mismatchPositionPlots_primerProbe_LWED")
summarizeMismatches(mismatchPositionData_primerProbe_SIMP,saveDir="mismatchPositionPlots_primerProbe_SIMP")
```

# 7 Species loci performance

Beyond genotype success, we also need to know if loci are actually informative. So that we have as much data as possible, I'm going to include genotypes from samples with under 50% overall genotyping success.

## 7.1 Genotypes & species key

```{r}
# Genotypes
genos_fullSet <- read.table("./../03_run3GTscore/fullSet_polyGenResults_singleSNP.txt", header = T)

# Species key
speciesKey <- read.csv("speciesSNP_key_14Dec2022.csv")
```

## 7.2 Species assignments

The following script uses the speciesKey to replace genotypes with either "LWED" or "SIMP" and includes the following columns: - the species assigned based on genotyped loci, where species is only assigned when 100% of genotypes are either F or M - the total number of species loci genotyped - the proportion of species loci genotyped relative to total species loci (n = 12) - the proportion of loci genotyped as LWED vs. SIMP - the proportion of mismatches if there's a mix of LWED vs. SIMP assignments

```{r}
genos_species <- genos_fullSet %>%
  rownames_to_column("Locus") %>%
  filter(str_detect(Locus, "SPECIES")) %>%
  mutate(Locus = sub('[_][^_]+$', '', Locus)) %>%
  mutate(across(everything(), as.character)) %>%
  pivot_longer(!Locus,
               names_to = "sampleID",
               values_to = "genotype") %>%
  left_join(speciesKey, by = c("Locus", "genotype")) %>%
  mutate(species = coalesce(species, genotype)) %>%
  select(c(Locus, sampleID, species)) %>%
  pivot_wider(names_from = sampleID,
              values_from = species) %>%
  column_to_rownames("Locus") %>%
  t() %>%
  as.data.frame() %>%
  mutate(totalGenos_sp = (rowSums(. == "LWED") + rowSums(. == "SIMP"))) %>%
  mutate(propGenos_sp = (totalGenos_sp/12)) %>%
  mutate(propLWED = (rowSums(. == "LWED")/totalGenos_sp)) %>%
  mutate(propSIMP = (rowSums(. == "SIMP")/totalGenos_sp)) %>%
  mutate(propMismatch_species = (1 - abs(propLWED - propSIMP))) %>%
  mutate(speciesAssigned = ifelse(propLWED == 1, "LWED", ifelse(propSIMP == 1, "SIMP", NA))) %>%
  rownames_to_column("sampleID") %>%
  filter(!sampleID %in% negatives$sampleID) %>%
  filter(!sampleID == "Undetermined") %>%
  relocate(c(speciesAssigned, totalGenos_sp, propMismatch_species, propLWED, propSIMP, propGenos_sp), .after = sampleID)
```

315 out of 429 samples (excluding the 9 negatives) received species genotypes.

```{r}
# Number of samples assigned species
length(na.omit(genos_species$speciesAssigned))

# Total samples minus negatives & undetermined
length(genos_species$sampleID)
```

For all 315 samples, the species assigned were in 100% agreement across all genotyped loci (propMismatch = 0).

```{r}
table(genos_species$propMismatch_species)
```

## 7.3 Mismatch checks

Out of those 315 samples that received a species assignment, 15 received assignments that do not match the metadata. 8 of these mismatches are hair samples and 9 are blood samples.

```{r}
# Identify (mis)matches
genos_species_md <- samples %>%
  select(c(sampleID, animalID, species, sampleType)) %>%
  merge(., genos_species, by = "sampleID") %>%
  mutate(mdMatch_sp = ifelse(species == speciesAssigned,"TRUE", "FALSE")) %>%
  relocate(animalID, .after = sampleID) %>%
  relocate(mdMatch_sp, .after = animalID)

# Extract mismatches
genos_species_mismatch <- genos_species_md %>%
  filter(mdMatch_sp == "FALSE")
length(genos_species_mismatch$sampleID)

# How many hair mismatches?
genos_species_mismatch %>%
  filter(sampleType == "hair")
```

One individual (animalID 276) was mismatched in both hair and blood samples, suggesting an issue with the metadata vs. the sample/sequencing.

```{r}
genos_species_mismatch %>%
  get_dupes(animalID)
```

# 8 Sex loci performance

As with species-loci performance checks, I'll be including samples with under 50% genotype success to check sex-loci performance as well.

## 8.1 Sex key

```{r}
# Sex key
sexKey <- read.csv("sexSNP_key_8Dec2022.csv") %>%
  na.omit() %>%
  unique()
```

## 8.2 Sex assignments

The following script uses the sexKey to replace genotypes with either "F" or "M" and includes the following columns: - the sex assigned based on genotyped loci, where sex is only assigned when 100% of genotypes are either F or M - the total number of sex loci genotyped - the proportion of sex loci genotyped relative to total sex loci (n = 12) - the proportion of loci genotyped as F and M - the proportion of mismatches if there's a mix of F and M assignments

```{r}
genos_sex <- genos_fullSet %>%
  rownames_to_column("Locus") %>%
  filter(str_detect(Locus, "SEXID")) %>%
  mutate(Locus = sub('[_][^_]+$', '', Locus)) %>%
  mutate(across(everything(), as.character)) %>%
  pivot_longer(!Locus,
               names_to = "sampleID",
               values_to = "genotype") %>%
  left_join(sexKey, by = c("Locus", "genotype")) %>%
  mutate(sex = coalesce(sex, genotype)) %>%
  select(c(Locus, sampleID, sex)) %>%
  pivot_wider(names_from = sampleID,
              values_from = sex) %>%
  column_to_rownames("Locus") %>%
  t() %>%
  as.data.frame() %>%
  mutate(totalGenos_sex = (rowSums(. == "F") + rowSums(. == "M"))) %>%
  mutate(propGenos_sex = (totalGenos_sex/12)) %>%
  mutate(propF = (rowSums(. == "F")/totalGenos_sex)) %>%
  mutate(propM = (rowSums(. == "M")/totalGenos_sex)) %>%
  mutate(propMismatch_sex = (1 - abs(propF - propM))) %>%
  mutate(sexAssigned = ifelse(propF == 1, "F", ifelse(propM == 1, "M", NA))) %>%
  rownames_to_column("sampleID") %>%
  relocate(c(sexAssigned, totalGenos_sex, propMismatch_sex, propF, propM, propGenos_sex), .after = sampleID) %>%
  filter(!sampleID %in% negatives$sampleID) %>%
  filter(!sampleID == "Undetermined") %>%
  relocate(c(SEXID_SIMP_197, SEXID_SIMP_198, SEXID_200, SEXID_SIMP_203, SEXID_SIMP_218, SEXID_219, SEXID_222), .after = propGenos_sex)
```

Add metadata

```{r}
genos_sex_md <- samples %>%
  select(c(sampleID, sex, species, sampleType)) %>%
  merge(., genos_sex, by = "sampleID") %>%
  mutate(mdMatch_sex = ifelse(sex == sexAssigned,"TRUE", "FALSE")) %>%
  relocate(mdMatch_sex, .after = sampleID)
```

235 out of 429 samples (excluding the 9 negatives) received sex genotypes. Of these samples, 162 are blood samples and 235 are hair samples.

```{r}
# Number of samples assigned sex
length(na.omit(genos_sex$sexAssigned))

# Sample types
table(genos_sex_md$sampleType)
```

## 8.3 Mismatch checks (hair only)

Next I'm checking to see which hair samples were assigned a sex that doesn't match the metadata. I'm excluding samples that were already identified as having a species assignment mismatch, since these likely have other issues.

Of the 227 hair samples that i) were successfully assigned a sex (i.e., all loci were 100% F or M) and ii) whose species assignment matches the metadata, 6 of these have sex assignments that do not match the metadata.

-   5 of these have only one genotype called, 1 has 3 genotypes called

```{r}
# Subset to hair samples only
genos_sex_hair <- genos_sex_md %>%
  filter(!sampleID %in% genos_species_mismatch$sampleID) %>%
  filter(sampleType == "hair")
length(genos_sex_hair$sampleID)

# Identify samples that don't match metadata
genos_sex_hair_mismatch <- genos_sex_hair %>%
  filter(mdMatch_sex == "FALSE")

length(genos_sex_hair_mismatch$sampleID)
```

## 8.4 Mixed calls

An additional 25 hair samples were assigned sex genotypes that were mixed (i.e., some loci were called as F, some as M).

```{r}
genos_sex_hair_mixed <- genos_sex_hair %>%
  filter(propMismatch_sex > 0)

length(genos_sex_hair_mixed$sampleID)

table(genos_sex_hair_mixed$totalGenos_sex)
```

### 8.4.1 Loci leading to the mixed calls?

Among metadata-females, there are 7 loci contributing to M genotypes. 4 of these loci only had one M call; 2 loci had two M calls, and 1 loci had 3 M calls. Note that no species-specific sex loci were called for the other species.

```{r}
mixedSex_lociF <- genos_sex_hair_mixed %>%
  filter(sex == "F") %>%
  column_to_rownames("sampleID") %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("Locus") %>%
  filter(str_detect(Locus, "SEXID")) %>%
  mutate(totalM = (rowSums(. == "M"))) %>%
  filter(totalM > 0)

table(mixedSex_lociF$totalM)
```

Among metadata-males, there are 4 loci contributing to F genotypes. - SEXID_LWED_208 has 10 F calls; but that 9 of these are SIMP individuals - SEXID_222 has 5 F calls - SEXID_SIMP_198 has 2 F calls (both for SIMP individuals) - SEXID_209 has 1 F call

```{r}
mixedSex_lociM <- genos_sex_hair_mixed %>%
  filter(sex == "M") %>%
  column_to_rownames("sampleID") %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("Locus") %>%
  #filter(str_detect(Locus, "SEXID")) %>%
  mutate(totalM = (rowSums(. == "F"))) %>%
  filter(totalM > 0)
```

## 8.4 Species-specific sex loci

Next I want to see if species-specific sex loci are being genotyped in the other species. For now, I'm excluding samples whose species assignments did not match metadata.

### 8.4.1 LWED samples

No LWED samples were genotyped for simp-specific sex loci.

```{r}
# LWED sex genotypes
genos_sex_lwed <- genos_sex_md %>%
  filter(!sampleID %in% genos_species_mismatch$sampleID) %>%
  filter(species == "LWED") %>%
  filter(!is.na(sexAssigned))

table(genos_sex_lwed$SEXID_SIMP_197)
table(genos_sex_lwed$SEXID_SIMP_198)
table(genos_sex_lwed$SEXID_SIMP_203)
table(genos_sex_lwed$SEXID_SIMP_218)
```

### 8.4.2 SIMP samples

No SIMP samples received genotypes for SEXID_LWED_195, but 12 SIMP samples received genotypes for SEXID_LWED_208 (all genotyped as F).

```{r}
# SIMP sex genotypes
genos_sex_simp <- genos_sex_md %>%
  filter(!sampleID %in% genos_species_mismatch$sampleID) %>%
  filter(species == "SIMP") %>%
  filter(!is.na(sexAssigned))

table(genos_sex_simp$SEXID_LWED_195)
table(genos_sex_simp$SEXID_LWED_208)
```

#### 8.4.2.1 SEXID_LWED_208

Of the 12 SIMP samples that were genotyped at SEXID_LWED_208, 7 are blood samples and 5 are hair samples.

```{r}
sexLWED208 <- genos_sex_simp %>%
  filter(SEXID_LWED_208 == "F") %>%
  merge(., samples[, c("sampleID", "animalID")], by = "sampleID") %>%
  relocate("animalID", .after = "sampleID")

table(sexLWED208$sampleType)
```

One SIMP individual (animalID 73) is genotyped at SEXID_LWED_208 in both the blood and hair samples.

```{r}
sexLWED208 %>%
  get_dupes(animalID)
```

Does this matter?? Does this mean we should ditch SEXID_LWED_208 or just treat it with caution?

Since twin chimerism will affect sex assignments in blood samples, I'm going to look at hair samples only.

```{r}
# Extract samples with mismatches
genos_sex_mismatch <- genos_sex_md %>%
  filter(mdMatch_sex == "FALSE")

# Extract samples with mismatches - hair samples only for now
genos_sex_mismatch_hair <- genos_sex_mismatch %>%
  filter(sampleType == "hair")

# Hair only
samplesHair <- samples %>%
  filter(sampleType == "hair") %>%
  select(Sample)

genos_sex_hair <- genos_sex %>%
  filter(sampleID %in% samplesHair$Sample) %>%
  filter(!is.na(sexAssigned))
```

Mismatches in hair due to allelic dropout?? 7 out of 9 were assigned female when should have been male

88, 177, 192 - has simp sex genos, but supposed to be lwed; next question - do SIMP loci often give genotypes for LWED individuals?



# 10 Recommendations

Below is a table of loci to consider removing from the SNP set or diluting before adding to the primer pool as well as justification for their removal/dilution.

```{r}
toDilute_overamp <- allCombined_outliers %>%
  select(locus) %>%
  mutate(action = "dilute") %>%
  mutate(reason = "overamplifier")
toRemove_fixedLoci <- fixedLoci %>%
  select(Locus) %>%
  dplyr::rename("locus" = "Locus") %>%
  mutate(action = "remove") %>%
  mutate(reason = "fixed alleles")
toRemove_genoFail <- lociPF_under50 %>%
  filter(GenotypeRate < 0.2) %>%
  select(Locus) %>%
  dplyr::rename("locus" = "Locus") %>%
  mutate(action = "remove") %>%
  mutate(reason = "geno succes < 20%")

lociRecs <- rbind(toDilute_overamp, toRemove_fixedLoci, toRemove_genoFail)
```

Export final loci recommendations

```{r, eval=FALSE}
write.csv(lociRecs, "./03_tamRun3/04_genoAnalyses/lociChoices_finalRecommendations.csv", row.names = F)
```
